{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","Styling/scoped-styles",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","04-styling/01-scoped-styles.md",true,{"fulltext":8,"digest":9,"short_digest":10},411,236,109,{"input":12,"output":13,"details":14},1451,465,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: Scoped styles\n---\n\nSvelte components can include a `\u003Cstyle>` element containing CSS that belongs to the component. This CSS is _scoped_ by default, meaning that styles will not apply to any elements on the page outside the component in question.\n\nThis works by adding a class to affected elements, which is based on a hash of the component styles (e.g. `svelte-123xyz`).\n\n```svelte\n\u003Cstyle>\n\tp {\n\t\t/* this will only affect \u003Cp> elements in this component */\n\t\tcolor: burlywood;\n\t}\n\u003C/style>\n```\n\n## Specificity\n\nEach scoped selector receives a [specificity](https://developer.mozilla.org/en-US/docs/Web/CSS/Specificity) increase of 0-1-0, as a result of the scoping class (e.g. `.svelte-123xyz`) being added to the selector. This means that (for example) a `p` selector defined in a component will take precedence over a `p` selector defined in a global stylesheet, even if the global stylesheet is loaded later.\n\nIn some cases, the scoping class must be added to a selector multiple times, but after the first occurrence it is added with `:where(.svelte-xyz123)` in order to not increase specificity further.\n\n## Scoped keyframes\n\nIf a component defines `@keyframes`, the name is scoped to the component using the same hashing approach. Any `animation` rules in the component will be similarly adjusted:\n\n```svelte\n\u003Cstyle>\n\t.bouncy {\n\t\tanimation: bounce 10s;\n\t}\n\n\t/* these keyframes are only accessible inside this component */\n\t@keyframes bounce {\n\t\t/* ... */\n\t}\n\u003C/style>\n```\n","Svelte components can include a `\u003Cstyle>` element with CSS that is scoped to the component by default. Scoped styles are implemented by adding a hash-based class (e.g., `svelte-123xyz`) to affected elements, preventing styles from leaking outside the component.\n\nEach scoped selector receives a specificity increase of 0-1-0 from the scoping class. This means component selectors take precedence over global stylesheets, even if the global stylesheet loads later. When the scoping class must be added multiple times to a selector, subsequent occurrences use `:where(.svelte-xyz123)` to avoid further specificity increases.\n\nKeyframe animations defined in a component are also scoped using the same hashing approach. Animation rules referencing these keyframes are automatically adjusted:\n\n```svelte\n\u003Cstyle>\n\t.bouncy {\n\t\tanimation: bounce 10s;\n\t}\n\n\t@keyframes bounce {\n\t\t/* scoped to this component only */\n\t}\n\u003C/style>\n```","Svelte scopes component styles by adding a hash-based class (e.g., `svelte-123xyz`) to elements. Scoped selectors get a 0-1-0 specificity boost, taking precedence over global styles. Keyframes are also scoped automatically:\n\n```svelte\n\u003Cstyle>\n\t@keyframes bounce { /* ... */ }\n\t.bouncy { animation: bounce 10s; }\n\u003C/style>\n```","Svelte automatically scopes component styles using hash-based classes, preventing style leakage and giving component styles higher specificity than global styles."],"uses":{"params":["name","path"]}}]}
