{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-sveltekit","core-concepts/page-options",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","20-core-concepts/40-page-options.md",true,{"fulltext":8,"digest":9,"short_digest":10},3503,405,184,{"input":12,"output":13,"details":14},4548,705,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: Page options\n---\n\nBy default, SvelteKit will render (or [prerender](glossary#Prerendering)) any component first on the server and send it to the client as HTML. It will then render the component again in the browser to make it interactive in a process called [_hydration_](glossary#Hydration). For this reason, you need to ensure that components can run in both places. SvelteKit will then initialize a [_router_](routing) that takes over subsequent navigations.\n\nYou can control each of these on a page-by-page basis by exporting options from [`+page.js`](routing#page-page.js) or [`+page.server.js`](routing#page-page.server.js), or for groups of pages using a shared [`+layout.js`](routing#layout-layout.js) or [`+layout.server.js`](routing#layout-layout.server.js). To define an option for the whole app, export it from the root layout. Child layouts and pages override values set in parent layouts, so — for example — you can enable prerendering for your entire app then disable it for pages that need to be dynamically rendered.\n\nYou can mix and match these options in different areas of your app. For example, you could prerender your marketing page for maximum speed, server-render your dynamic pages for SEO and accessibility and turn your admin section into an SPA by rendering it on the client only. This makes SvelteKit very versatile.\n\n## prerender\n\nIt's likely that at least some routes of your app can be represented as a simple HTML file generated at build time. These routes can be [_prerendered_](glossary#Prerendering).\n\n```js\n/// file: +page.js/+page.server.js/+server.js\nexport const prerender = true;\n```\n\nAlternatively, you can set `export const prerender = true` in your root `+layout.js` or `+layout.server.js` and prerender everything except pages that are explicitly marked as _not_ prerenderable:\n\n```js\n/// file: +page.js/+page.server.js/+server.js\nexport const prerender = false;\n```\n\nRoutes with `prerender = true` will be excluded from manifests used for dynamic SSR, making your server (or serverless/edge functions) smaller. In some cases you might want to prerender a route but also include it in the manifest (for example, with a route like `/blog/[slug]` where you want to prerender your most recent/popular content but server-render the long tail) — for these cases, there's a third option, 'auto':\n\n```js\n/// file: +page.js/+page.server.js/+server.js\nexport const prerender = 'auto';\n```\n\n> [!NOTE] If your entire app is suitable for prerendering, you can use [`adapter-static`](adapter-static), which will output files suitable for use with any static webserver.\n\nThe prerenderer will start at the root of your app and generate files for any prerenderable pages or `+server.js` routes it finds. Each page is scanned for `\u003Ca>` elements that point to other pages that are candidates for prerendering — because of this, you generally don't need to specify which pages should be accessed. If you _do_ need to specify which pages should be accessed by the prerenderer, you can do so with [`config.kit.prerender.entries`](configuration#prerender), or by exporting an [`entries`](#entries) function from your dynamic route.\n\nWhile prerendering, the value of `building` imported from [`$app/environment`]($app-environment) will be `true`.\n\n### Prerendering server routes\n\nUnlike the other page options, `prerender` also applies to `+server.js` files. These files are _not_ affected by layouts, but will inherit default values from the pages that fetch data from them, if any. For example if a `+page.js` contains this `load` function...\n\n```js\n/// file: +page.js\nexport const prerender = true;\n\n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch }) {\n\tconst res = await fetch('/my-server-route.json');\n\treturn await res.json();\n}\n```\n\n...then `src/routes/my-server-route.json/+server.js` will be treated as prerenderable if it doesn't contain its own `export const prerender = false`.\n\n### When not to prerender\n\nThe basic rule is this: for a page to be prerenderable, any two users hitting it directly must get the same content from the server.\n\n> [!NOTE] Not all pages are suitable for prerendering. Any content that is prerendered will be seen by all users. You can of course fetch personalized data in `onMount` in a prerendered page, but this may result in a poorer user experience since it will involve blank initial content or loading indicators.\n\nNote that you can still prerender pages that load data based on the page's parameters, such as a `src/routes/blog/[slug]/+page.svelte` route.\n\nAccessing [`url.searchParams`](load#Using-URL-data-url) during prerendering is forbidden. If you need to use it, ensure you are only doing so in the browser (for example in `onMount`).\n\nPages with [actions](form-actions) cannot be prerendered, because a server must be able to handle the action `POST` requests.\n\n### Route conflicts\n\nBecause prerendering writes to the filesystem, it isn't possible to have two endpoints that would cause a directory and a file to have the same name. For example, `src/routes/foo/+server.js` and `src/routes/foo/bar/+server.js` would try to create `foo` and `foo/bar`, which is impossible.\n\nFor that reason among others, it's recommended that you always include a file extension — `src/routes/foo.json/+server.js` and `src/routes/foo/bar.json/+server.js` would result in `foo.json` and `foo/bar.json` files living harmoniously side-by-side.\n\nFor _pages_, we skirt around this problem by writing `foo/index.html` instead of `foo`.\n\n### Troubleshooting\n\nIf you encounter an error like 'The following routes were marked as prerenderable, but were not prerendered' it's because the route in question (or a parent layout, if it's a page) has `export const prerender = true` but the page wasn't reached by the prerendering crawler and thus wasn't prerendered.\n\nSince these routes cannot be dynamically server-rendered, this will cause errors when people try to access the route in question. There are a few ways to fix it:\n\n* Ensure that SvelteKit can find the route by following links from [`config.kit.prerender.entries`](configuration#prerender) or the [`entries`](#entries) page option. Add links to dynamic routes (i.e. pages with `[parameters]` ) to this option if they are not found through crawling the other entry points, else they are not prerendered because SvelteKit doesn't know what value the parameters should have. Pages not marked as prerenderable will be ignored and their links to other pages will not be crawled, even if some of them would be prerenderable.\n* Ensure that SvelteKit can find the route by discovering a link to it from one of your other prerendered pages that have server-side rendering enabled.\n* Change `export const prerender = true` to `export const prerender = 'auto'`. Routes with `'auto'` can be dynamically server rendered\n\n## entries\n\nSvelteKit will discover pages to prerender automatically, by starting at _entry points_ and crawling them. By default, all your non-dynamic routes are considered entry points — for example, if you have these routes...\n\n```sh\n/             # non-dynamic\n/blog         # non-dynamic\n/blog/[slug]  # dynamic, because of `[slug]`\n```\n\n...SvelteKit will prerender `/` and `/blog`, and in the process discover links like `\u003Ca href=\"/blog/hello-world\">` which give it new pages to prerender.\n\nMost of the time, that's enough. In some situations, links to pages like `/blog/hello-world` might not exist (or might not exist on prerendered pages), in which case we need to tell SvelteKit about their existence.\n\nThis can be done with [`config.kit.prerender.entries`](configuration#prerender), or by exporting an `entries` function from a `+page.js`, a `+page.server.js` or a `+server.js` belonging to a dynamic route:\n\n```js\n/// file: src/routes/blog/[slug]/+page.server.js\n/** @type {import('./$types').EntryGenerator} */\nexport function entries() {\n\treturn [\n\t\t{ slug: 'hello-world' },\n\t\t{ slug: 'another-blog-post' }\n\t];\n}\n\nexport const prerender = true;\n```\n\n`entries` can be an `async` function, allowing you to (for example) retrieve a list of posts from a CMS or database, in the example above.\n\n## ssr\n\nNormally, SvelteKit renders your page on the server first and sends that HTML to the client where it's [hydrated](glossary#Hydration). If you set `ssr` to `false`, it renders an empty 'shell' page instead. This is useful if your page is unable to be rendered on the server (because you use browser-only globals like `document` for example), but in most situations it's not recommended ([see appendix](glossary#SSR)).\n\n```js\n/// file: +page.js\nexport const ssr = false;\n// If both `ssr` and `csr` are `false`, nothing will be rendered!\n```\n\nIf you add `export const ssr = false` to your root `+layout.js`, your entire app will only be rendered on the client — which essentially means you turn your app into an SPA.\n\n> [!NOTE] If all your page options are boolean or string literal values, SvelteKit will evaluate them statically. If not, it will import your `+page.js` or `+layout.js` file on the server (both at build time, and at runtime if your app isn't fully static) so it can evaluate the options. In the second case, browser-only code must not run when the module is loaded. In practice, this means you should import browser-only code in your `+page.svelte` or `+layout.svelte` file instead.\n\n## csr\n\nOrdinarily, SvelteKit [hydrates](glossary#Hydration) your server-rendered HTML into an interactive client-side-rendered (CSR) page. Some pages don't require JavaScript at all — many blog posts and 'about' pages fall into this category. In these cases you can disable CSR:\n\n```js\n/// file: +page.js\nexport const csr = false;\n// If both `csr` and `ssr` are `false`, nothing will be rendered!\n```\n\nDisabling CSR does not ship any JavaScript to the client. This means:\n\n* The webpage should work with HTML and CSS only.\n* `\u003Cscript>` tags inside all Svelte components are removed.\n* `\u003Cform>` elements cannot be [progressively enhanced](form-actions#Progressive-enhancement).\n* Links are handled by the browser with a full-page navigation.\n* Hot Module Replacement (HMR) will be disabled.\n\nYou can enable `csr` during development (for example to take advantage of HMR) like so:\n\n```js\n/// file: +page.js\nimport { dev } from '$app/environment';\n\nexport const csr = dev;\n```\n\n## trailingSlash\n\nBy default, SvelteKit will remove trailing slashes from URLs — if you visit `/about/`, it will respond with a redirect to `/about`. You can change this behaviour with the `trailingSlash` option, which can be one of `'never'` (the default), `'always'`, or `'ignore'`.\n\nAs with other page options, you can export this value from a `+layout.js` or a `+layout.server.js` and it will apply to all child pages. You can also export the configuration from `+server.js` files.\n\n```js\n/// file: src/routes/+layout.js\nexport const trailingSlash = 'always';\n```\n\nThis option also affects [prerendering](#prerender). If `trailingSlash` is `always`, a route like `/about` will result in an `about/index.html` file, otherwise it will create `about.html`, mirroring static webserver conventions.\n\n> [!NOTE] Ignoring trailing slashes is not recommended — the semantics of relative paths differ between the two cases (`./y` from `/x` is `/y`, but from `/x/` is `/x/y`), and `/x` and `/x/` are treated as separate URLs which is harmful to SEO.\n\n## config\n\nWith the concept of [adapters](adapters), SvelteKit is able to run on a variety of platforms. Each of these might have specific configuration to further tweak the deployment — for example on Vercel you could choose to deploy some parts of your app on the edge and others on serverless environments.\n\n`config` is an object with key-value pairs at the top level. Beyond that, the concrete shape is dependent on the adapter you're using. Every adapter should provide a `Config` interface to import for type safety. Consult the documentation of your adapter for more information.\n\n```js\n// @filename: ambient.d.ts\ndeclare module 'some-adapter' {\n\texport interface Config { runtime: string }\n}\n\n// @filename: index.js\n// ---cut---\n/// file: src/routes/+page.js\n/** @type {import('some-adapter').Config} */\nexport const config = {\n\truntime: 'edge'\n};\n```\n\n`config` objects are merged at the top level (but _not_ deeper levels). This means you don't need to repeat all the values in a `+page.js` if you want to only override some of the values in the upper `+layout.js`. For example this layout configuration...\n\n```js\n/// file: src/routes/+layout.js\nexport const config = {\n\truntime: 'edge',\n\tregions: 'all',\n\tfoo: {\n\t\tbar: true\n\t}\n}\n```\n\n...is overridden by this page configuration...\n\n```js\n/// file: src/routes/+page.js\nexport const config = {\n\tregions: ['us1', 'us2'],\n\tfoo: {\n\t\tbaz: true\n\t}\n}\n```\n\n...which results in the config value `{ runtime: 'edge', regions: ['us1', 'us2'], foo: { baz: true } }` for that page.\n\n## Further reading\n\n- [Tutorial: Page options](/tutorial/kit/page-options)\n","## prerender\nExport `export const prerender = true` from `+page.js`, `+page.server.js`, `+server.js`, or layout files to generate static HTML at build time. Use `prerender = false` to disable for specific pages when enabled globally. Use `prerender = 'auto'` to allow dynamic server rendering as fallback.\n\nPages must return identical content for all users to be prerenderable. Cannot prerender pages with form actions. Specify which dynamic routes to prerender via `entries()` function:\n```js\nexport function entries() {\n  return [{ slug: 'hello-world' }, { slug: 'another-blog-post' }];\n}\nexport const prerender = true;\n```\n\n## ssr\nSet `export const ssr = false` to skip server-side rendering and send an empty shell to the client instead. Useful for pages using browser-only APIs. Setting in root layout converts entire app to SPA.\n\n## csr\nSet `export const csr = false` to disable client-side rendering. Results in no JavaScript shipped to client—pages work with HTML/CSS only, no script tags, no form progressive enhancement, full-page navigation only.\n\nCan conditionally enable during development:\n```js\nimport { dev } from '$app/environment';\nexport const csr = dev;\n```\n\n## trailingSlash\nControl trailing slash behavior with `export const trailingSlash = 'never' | 'always' | 'ignore'` (default: `'never'`). Affects both routing and prerendering output structure.\n\n## config\nExport adapter-specific configuration as `export const config = { ... }`. Objects merge at top level only, allowing child pages to override parent layout values without repeating unchanged properties.","## prerender\n`export const prerender = true/false/'auto'` generates static HTML at build time. Specify dynamic routes via `entries()` function. Pages must return identical content for all users.\n\n## ssr\n`export const ssr = false` skips server rendering, sends empty shell. Setting in root layout makes entire app client-only (SPA).\n\n## csr\n`export const csr = false` disables client-side rendering—no JavaScript shipped, HTML/CSS only, full-page navigation.\n\n## trailingSlash\n`export const trailingSlash = 'never' | 'always' | 'ignore'` controls URL trailing slash behavior.\n\n## config\n`export const config = { ... }` sets adapter-specific configuration, merged at top level only.","Export page options from layout and page files to control server rendering, prerendering, client rendering, trailing slashes, and adapter-specific configuration."],"uses":{"params":["name","path"]}}]}
