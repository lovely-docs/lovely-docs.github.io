{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","Runes/$derived",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","02-runes/03-$derived.md",true,{"fulltext":8,"digest":9,"short_digest":10},1739,487,157,{"input":12,"output":13,"details":14},2778,760,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: $derived\n---\n\nDerived state is declared with the `$derived` rune:\n\n```svelte\n\u003Cscript>\n\tlet count = $state(0);\n\tlet doubled = $derived(count * 2);\n\u003C/script>\n\n\u003Cbutton onclick={() => count++}>\n\t{doubled}\n\u003C/button>\n\n\u003Cp>{count} doubled is {doubled}\u003C/p>\n```\n\nThe expression inside `$derived(...)` should be free of side-effects. Svelte will disallow state changes (e.g. `count++`) inside derived expressions.\n\nAs with `$state`, you can mark class fields as `$derived`.\n\n> [!NOTE] Code in Svelte components is only executed once at creation. Without the `$derived` rune, `doubled` would maintain its original value even when `count` changes.\n\n## `$derived.by`\n\nSometimes you need to create complex derivations that don't fit inside a short expression. In these cases, you can use `$derived.by` which accepts a function as its argument.\n\n```svelte\n\u003Cscript>\n\tlet numbers = $state([1, 2, 3]);\n\tlet total = $derived.by(() => {\n\t\tlet total = 0;\n\t\tfor (const n of numbers) {\n\t\t\ttotal += n;\n\t\t}\n\t\treturn total;\n\t});\n\u003C/script>\n\n\u003Cbutton onclick={() => numbers.push(numbers.length + 1)}>\n\t{numbers.join(' + ')} = {total}\n\u003C/button>\n```\n\nIn essence, `$derived(expression)` is equivalent to `$derived.by(() => expression)`.\n\n## Understanding dependencies\n\nAnything read synchronously inside the `$derived` expression (or `$derived.by` function body) is considered a _dependency_ of the derived state. When the state changes, the derived will be marked as _dirty_ and recalculated when it is next read.\n\nTo exempt a piece of state from being treated as a dependency, use [`untrack`](svelte#untrack).\n\n## Overriding derived values\n\nDerived expressions are recalculated when their dependencies change, but you can temporarily override their values by reassigning them (unless they are declared with `const`). This can be useful for things like _optimistic UI_, where a value is derived from the 'source of truth' (such as data from your server) but you'd like to show immediate feedback to the user:\n\n```svelte\n\u003Cscript>\n\tlet { post, like } = $props();\n\n\tlet likes = $derived(post.likes);\n\n\tasync function onclick() {\n\t\t// increment the `likes` count immediately...\n\t\tlikes += 1;\n\n\t\t// and tell the server, which will eventually update `post`\n\t\ttry {\n\t\t\tawait like();\n\t\t} catch {\n\t\t\t// failed! roll back the change\n\t\t\tlikes -= 1;\n\t\t}\n\t}\n\u003C/script>\n\n\u003Cbutton {onclick}>ðŸ§¡ {likes}\u003C/button>\n```\n\n> [!NOTE] Prior to Svelte 5.25, deriveds were read-only.\n\n## Deriveds and reactivity\n\nUnlike `$state`, which converts objects and arrays to [deeply reactive proxies]($state#Deep-state), `$derived` values are left as-is. For example, [in a case like this](/playground/untitled#H4sIAAAAAAAAE4VU22rjMBD9lUHd3aaQi9PdstS1A3t5XvpQ2Ic4D7I1iUUV2UjjNMX431eS7TRdSosxgjMzZ45mjt0yzffIYibvy0ojFJWqDKCQVBk2ZVup0LJ43TJ6rn2aBxw-FP2o67k9oCKP5dziW3hRaUJNjoYltjCyplWmM1JIIAn3FlL4ZIkTTtYez6jtj4w8WwyXv9GiIXiQxLVs9pfTMR7EuoSLIuLFbX7Z4930bZo_nBrD1bs834tlfvsBz9_SyX6PZXu9XaL4gOWn4sXjeyzftv4ZWfyxubpzxzg6LfD4MrooxELEosKCUPigQCMPKCZh0OtQE1iSxcsmdHuBvCiHZXALLXiN08EL3RRkaJ_kDVGle0HcSD5TPEeVtj67O4Nrg9aiSNtBY5oODJkrL5QsHtN2cgXp6nSJMWzpWWGasdlsGEMbzi5jPr5KFr0Ep7pdeM2-TCelCddIhDxAobi1jqF3cMaC1RKp64bAW9iFAmXGIHfd4wNXDabtOLN53w8W53VvJoZLh7xk4Rr3CoL-UNoLhWHrT1JQGcM17u96oES5K-kc2XOzkzqGCKL5De79OUTyyrg1zgwXsrEx3ESfx4Bz0M5UjVMHB24mw9SuXtXFoN13fYKOM1tyUT3FbvbWmSWCZX2Er-41u5xPoml45svRahl9Wb9aasbINJixDZwcPTbyTLZSUsAvrg_cPuCR7s782_WU8343Y72Qtlb8OYatwuOQvuN13M_hJKNfxann1v1U_B1KZ_D_mzhzhz24fw85CSz2irtN9w9HshBK7AQAAA==)...\n\n```svelte\nlet items = $state([...]);\n\nlet index = $state(0);\nlet selected = $derived(items[index]);\n```\n\n...you can change (or `bind:` to) properties of `selected` and it will affect the underlying `items` array. If `items` was _not_ deeply reactive, mutating `selected` would have no effect.\n\n## Update propagation\n\nSvelte uses something called _push-pull reactivity_ â€” when state is updated, everything that depends on the state (whether directly or indirectly) is immediately notified of the change (the 'push'), but derived values are not re-evaluated until they are actually read (the 'pull').\n\nIf the new value of a derived is referentially identical to its previous value, downstream updates will be skipped. In other words, Svelte will only update the text inside the button when `large` changes, not when `count` changes, even though `large` depends on `count`:\n\n```svelte\n\u003Cscript>\n\tlet count = $state(0);\n\tlet large = $derived(count > 10);\n\u003C/script>\n\n\u003Cbutton onclick={() => count++}>\n\t{large}\n\u003C/button>\n```\n","## $derived\n\nDeclare derived state that automatically updates when dependencies change:\n\n```svelte\n\u003Cscript>\n\tlet count = $state(0);\n\tlet doubled = $derived(count * 2);\n\u003C/script>\n\n\u003Cbutton onclick={() => count++}>{doubled}\u003C/button>\n```\n\nExpressions must be side-effect free. Svelte prevents state mutations inside derived expressions.\n\n### $derived.by\n\nFor complex derivations, use `$derived.by` with a function:\n\n```svelte\n\u003Cscript>\n\tlet numbers = $state([1, 2, 3]);\n\tlet total = $derived.by(() => {\n\t\tlet sum = 0;\n\t\tfor (const n of numbers) sum += n;\n\t\treturn sum;\n\t});\n\u003C/script>\n```\n\n`$derived(expression)` is equivalent to `$derived.by(() => expression)`.\n\n### Dependencies\n\nAnything read synchronously inside the derived expression becomes a dependency. When dependencies change, the derived is marked dirty and recalculated on next read. Use `untrack` to exempt state from being treated as a dependency.\n\n### Overriding derived values\n\nYou can temporarily reassign derived values (unless declared with `const`) for optimistic UI:\n\n```svelte\n\u003Cscript>\n\tlet { post, like } = $props();\n\tlet likes = $derived(post.likes);\n\n\tasync function onclick() {\n\t\tlikes += 1;\n\t\ttry {\n\t\t\tawait like();\n\t\t} catch {\n\t\t\tlikes -= 1;\n\t\t}\n\t}\n\u003C/script>\n\n\u003Cbutton {onclick}>ðŸ§¡ {likes}\u003C/button>\n```\n\n### Reactivity behavior\n\nUnlike `$state`, `$derived` values are not converted to deeply reactive proxies. However, if a derived contains an object/array from reactive state, mutating its properties will affect the source.\n\n### Update propagation\n\nSvelte uses push-pull reactivity: state changes immediately notify dependents (push), but derived values only re-evaluate when read (pull). If a derived's new value is referentially identical to its previous value, downstream updates are skipped.","## $derived\n\nDeclare derived state that automatically updates when dependencies change:\n\n```svelte\nlet count = $state(0);\nlet doubled = $derived(count * 2);\n```\n\nFor complex logic, use `$derived.by(() => { ... })`. Expressions must be side-effect free.\n\nCan temporarily override derived values for optimistic UI. Unlike `$state`, derived values aren't deeply reactive proxies, but mutations to objects/arrays from reactive state still affect the source.\n\nUses push-pull reactivity: dependents are notified immediately, but derived values only re-evaluate when read. Skips downstream updates if the new value is referentially identical to the previous one.","Derived state automatically updates when its dependencies change, with support for complex expressions via $derived.by and temporary value overrides for optimistic UI."],"uses":{"params":["name","path"]}}]}
