{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","Legacy Mode/reactive-assignments-with-$:-statements",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","99-legacy/02-legacy-reactive-assignments.md",true,{"fulltext":8,"digest":9,"short_digest":10},760,460,156,{"input":12,"output":13,"details":14},1801,734,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: Reactive $: statements\n---\n\nIn runes mode, reactions to state updates are handled with the [`$derived`]($derived) and [`$effect`]($effect) runes.\n\nIn legacy mode, any top-level statement (i.e. not inside a block or a function) can be made reactive by prefixing it with a `$:` [label](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/label). These statements run after other code in the `\u003Cscript>` and before the component markup is rendered, then whenever the values that they depend on change.\n\n```svelte\n\u003Cscript>\n\tlet a = 1;\n\tlet b = 2;\n\n\t// this is a 'reactive statement', and it will re-run\n\t// when `a`, `b` or `sum` change\n\t$: console.log(`${a} + ${b} = ${sum}`);\n\n\t// this is a 'reactive assignment' — `sum` will be\n\t// recalculated when `a` or `b` change. It is\n\t// not necessary to declare `sum` separately\n\t$: sum = a + b;\n\u003C/script>\n```\n\nStatements are ordered _topologically_ by their dependencies and their assignments: since the `console.log` statement depends on `sum`, `sum` is calculated first even though it appears later in the source.\n\nMultiple statements can be combined by putting them in a block:\n\n```js\n// @noErrors\n$: {\n\t// recalculate `total` when `items` changes\n\ttotal = 0;\n\n\tfor (const item of items) {\n\t\ttotal += item.value;\n\t}\n}\n```\n\nThe left-hand side of a reactive assignments can be an identifier, or it can be a destructuring assignment:\n\n```js\n// @noErrors\n$: ({ larry, moe, curly } = stooges);\n```\n\n## Understanding dependencies\n\nThe dependencies of a `$:` statement are determined at compile time — they are whichever variables are referenced (but not assigned to) inside the statement.\n\nIn other words, a statement like this will _not_ re-run when `count` changes, because the compiler cannot 'see' the dependency:\n\n```js\n// @noErrors\nlet count = 0;\nlet double = () => count * 2;\n\n$: doubled = double();\n```\n\nSimilarly, topological ordering will fail if dependencies are referenced indirectly: `z` will never update, because `y` is not considered 'dirty' when the update occurs. Moving `$: z = y` below `$: setY(x)` will fix it:\n\n```svelte\n\u003Cscript>\n\tlet x = 0;\n\tlet y = 0;\n\n\t$: z = y;\n\t$: setY(x);\n\n\tfunction setY(value) {\n\t\ty = value;\n\t}\n\u003C/script>\n```\n\n## Browser-only code\n\nReactive statements run during server-side rendering as well as in the browser. This means that any code that should only run in the browser must be wrapped in an `if` block:\n\n```js\n// @noErrors\n$: if (browser) {\n\tdocument.title = title;\n}\n```\n","## Reactive $: Statements (Legacy Mode)\n\nIn legacy Svelte, prefix top-level statements with `$:` to make them reactive. These run after other script code and before markup renders, then re-run whenever their dependencies change.\n\n**Basic reactive statement and assignment:**\n```svelte\n\u003Cscript>\n\tlet a = 1;\n\tlet b = 2;\n\n\t$: console.log(`${a} + ${b} = ${sum}`);\n\t$: sum = a + b;\n\u003C/script>\n```\n\nStatements are ordered topologically by dependencies—`sum` calculates before the console.log even though it appears later.\n\n**Multiple statements in a block:**\n```js\n$: {\n\ttotal = 0;\n\tfor (const item of items) {\n\t\ttotal += item.value;\n\t}\n}\n```\n\n**Destructuring assignment:**\n```js\n$: ({ larry, moe, curly } = stooges);\n```\n\n## Understanding Dependencies\n\nDependencies are determined at compile time based on which variables are referenced (not assigned). Indirect dependencies won't trigger re-runs:\n\n```js\nlet count = 0;\nlet double = () => count * 2;\n$: doubled = double();  // won't re-run when count changes\n```\n\nTopological ordering fails with indirect references. This won't work:\n```svelte\n\u003Cscript>\n\tlet x = 0;\n\tlet y = 0;\n\t$: z = y;\n\t$: setY(x);  // y updates here, but z already ran\n\tfunction setY(value) { y = value; }\n\u003C/script>\n```\n\nMove `$: z = y` after `$: setY(x)` to fix it.\n\n## Browser-Only Code\n\nReactive statements run during server-side rendering. Wrap browser-only code in a conditional:\n```js\n$: if (browser) {\n\tdocument.title = title;\n}\n```","## Reactive $: Statements (Legacy)\n\nPrefix top-level statements with `$:` to make them reactive—they re-run when dependencies change and are topologically ordered.\n\n```svelte\n\u003Cscript>\n\tlet a = 1, b = 2;\n\t$: sum = a + b;\n\t$: console.log(`${a} + ${b} = ${sum}`);\n\u003C/script>\n```\n\n**Key points:**\n- Dependencies determined at compile time by variable references\n- Indirect dependencies won't trigger re-runs\n- Statements run during SSR; wrap browser-only code: `$: if (browser) { ... }`","Legacy Svelte reactive statements using $: prefix run when dependencies change and are topologically ordered by their references."],"uses":{"params":["name","path"]}}]}
