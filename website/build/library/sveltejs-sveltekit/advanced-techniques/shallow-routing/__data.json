{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-sveltekit","advanced-techniques/shallow-routing",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","30-advanced/67-shallow-routing.md",true,{"fulltext":8,"digest":9,"short_digest":10},1335,634,169,{"input":12,"output":13,"details":14},2378,914,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: Shallow routing\n---\n\nAs you navigate around a SvelteKit app, you create _history entries_. Clicking the back and forward buttons traverses through this list of entries, re-running any `load` functions and replacing page components as necessary.\n\nSometimes, it's useful to create history entries _without_ navigating. For example, you might want to show a modal dialog that the user can dismiss by navigating back. This is particularly valuable on mobile devices, where swipe gestures are often more natural than interacting directly with the UI. In these cases, a modal that is _not_ associated with a history entry can be a source of frustration, as a user may swipe backwards in an attempt to dismiss it and find themselves on the wrong page.\n\nSvelteKit makes this possible with the [`pushState`]($app-navigation#pushState) and [`replaceState`]($app-navigation#replaceState) functions, which allow you to associate state with a history entry without navigating. For example, to implement a history-driven modal:\n\n```svelte\n\u003C!--- file: +page.svelte --->\n\u003Cscript>\n\timport { pushState } from '$app/navigation';\n\timport { page } from '$app/state';\n\timport Modal from './Modal.svelte';\n\n\tfunction showModal() {\n\t\tpushState('', {\n\t\t\tshowModal: true\n\t\t});\n\t}\n\u003C/script>\n\n{#if page.state.showModal}\n\t\u003CModal close={() => history.back()} />\n{/if}\n```\n\nThe modal can be dismissed by navigating back (unsetting `page.state.showModal`) or by interacting with it in a way that causes the `close` callback to run, which will navigate back programmatically.\n\n## API\n\nThe first argument to `pushState` is the URL, relative to the current URL. To stay on the current URL, use `''`.\n\nThe second argument is the new page state, which can be accessed via the [page object]($app-state#page) as `page.state`. You can make page state type-safe by declaring an [`App.PageState`](types#PageState) interface (usually in `src/app.d.ts`).\n\nTo set page state without creating a new history entry, use `replaceState` instead of `pushState`.\n\n> [!LEGACY]\n> `page.state` from `$app/state` was added in SvelteKit 2.12. If you're using an earlier version or are using Svelte 4, use `$page.state` from `$app/stores` instead.\n\n## Loading data for a route\n\nWhen shallow routing, you may want to render another `+page.svelte` inside the current page. For example, clicking on a photo thumbnail could pop up the detail view without navigating to the photo page.\n\nFor this to work, you need to load the data that the `+page.svelte` expects. A convenient way to do this is to use [`preloadData`]($app-navigation#preloadData) inside the `click` handler of an `\u003Ca>` element. If the element (or a parent) uses [`data-sveltekit-preload-data`](link-options#data-sveltekit-preload-data), the data will have already been requested, and `preloadData` will reuse that request.\n\n```svelte\n\u003C!--- file: src/routes/photos/+page.svelte --->\n\u003Cscript>\n\timport { preloadData, pushState, goto } from '$app/navigation';\n\timport { page } from '$app/state';\n\timport Modal from './Modal.svelte';\n\timport PhotoPage from './[id]/+page.svelte';\n\n\tlet { data } = $props();\n\u003C/script>\n\n{#each data.thumbnails as thumbnail}\n\t\u003Ca\n\t\thref=\"/photos/{thumbnail.id}\"\n\t\tonclick={async (e) => {\n\t\t\tif (innerWidth \u003C 640        // bail if the screen is too small\n\t\t\t\t|| e.shiftKey             // or the link is opened in a new window\n\t\t\t\t|| e.metaKey || e.ctrlKey // or a new tab (mac: metaKey, win/linux: ctrlKey)\n\t\t\t\t// should also consider clicking with a mouse scroll wheel\n\t\t\t) return;\n\n\t\t\t// prevent navigation\n\t\t\te.preventDefault();\n\n\t\t\tconst { href } = e.currentTarget;\n\n\t\t\t// run `load` functions (or rather, get the result of the `load` functions\n\t\t\t// that are already running because of `data-sveltekit-preload-data`)\n\t\t\tconst result = await preloadData(href);\n\n\t\t\tif (result.type === 'loaded' && result.status === 200) {\n\t\t\t\tpushState(href, { selected: result.data });\n\t\t\t} else {\n\t\t\t\t// something bad happened! try navigating\n\t\t\t\tgoto(href);\n\t\t\t}\n\t\t}}\n\t>\n\t\t\u003Cimg alt={thumbnail.alt} src={thumbnail.src} />\n\t\u003C/a>\n{/each}\n\n{#if page.state.selected}\n\t\u003CModal onclose={() => history.back()}>\n\t\t\u003C!-- pass page data to the +page.svelte component,\n\t\t     just like SvelteKit would on navigation -->\n\t\t\u003CPhotoPage data={page.state.selected} />\n\t\u003C/Modal>\n{/if}\n```\n\n## Caveats\n\nDuring server-side rendering, `page.state` is always an empty object. The same is true for the first page the user lands on â€” if the user reloads the page (or returns from another document), state will _not_ be applied until they navigate.\n\nShallow routing is a feature that requires JavaScript to work. Be mindful when using it and try to think of sensible fallback behavior in case JavaScript isn't available.\n","## Shallow Routing\n\nCreate history entries without navigating using `pushState()` and `replaceState()` from `$app/navigation`. This enables patterns like history-driven modals that can be dismissed by navigating back.\n\n### Basic Usage\n\n```svelte\n\u003Cscript>\n\timport { pushState } from '$app/navigation';\n\timport { page } from '$app/state';\n\n\tfunction showModal() {\n\t\tpushState('', { showModal: true });\n\t}\n\u003C/script>\n\n{#if page.state.showModal}\n\t\u003CModal close={() => history.back()} />\n{/if}\n```\n\nThe first argument to `pushState` is a relative URL (use `''` to stay on current URL). The second argument is the new page state, accessible via `page.state`. Use `replaceState` instead to set state without creating a new history entry.\n\n### Loading Data for Routes\n\nWhen rendering another `+page.svelte` inside the current page via shallow routing, preload its data using `preloadData()`:\n\n```svelte\n\u003Cscript>\n\timport { preloadData, pushState, goto } from '$app/navigation';\n\timport { page } from '$app/state';\n\n\tlet { data } = $props();\n\u003C/script>\n\n{#each data.thumbnails as thumbnail}\n\t\u003Ca\n\t\thref=\"/photos/{thumbnail.id}\"\n\t\tonclick={async (e) => {\n\t\t\tif (innerWidth \u003C 640 || e.shiftKey || e.metaKey || e.ctrlKey) return;\n\t\t\te.preventDefault();\n\n\t\t\tconst result = await preloadData(e.currentTarget.href);\n\t\t\tif (result.type === 'loaded' && result.status === 200) {\n\t\t\t\tpushState(e.currentTarget.href, { selected: result.data });\n\t\t\t} else {\n\t\t\t\tgoto(e.currentTarget.href);\n\t\t\t}\n\t\t}}\n\t>\n\t\t\u003Cimg alt={thumbnail.alt} src={thumbnail.src} />\n\t\u003C/a>\n{/each}\n\n{#if page.state.selected}\n\t\u003CModal onclose={() => history.back()}>\n\t\t\u003CPhotoPage data={page.state.selected} />\n\t\u003C/Modal>\n{/if}\n```\n\nIf the link element uses `data-sveltekit-preload-data`, the data will already be requested and `preloadData` will reuse that request.\n\n### Important Notes\n\n- `page.state` is always empty during server-side rendering and on initial page load\n- Shallow routing requires JavaScript; provide fallback behavior for when it's unavailable\n- Make page state type-safe by declaring an `App.PageState` interface in `src/app.d.ts`","## Shallow Routing\n\nUse `pushState()` and `replaceState()` from `$app/navigation` to create history entries without navigating. Access state via `page.state`.\n\n```svelte\npushState('', { showModal: true });\n```\n\nFor rendering nested pages, preload data with `preloadData()` before calling `pushState()`:\n\n```svelte\nconst result = await preloadData(href);\nif (result.type === 'loaded' && result.status === 200) {\n\tpushState(href, { selected: result.data });\n}\n```\n\n**Caveats:** `page.state` is empty during SSR and on initial page load. Requires JavaScript.","Create history entries without navigating using pushState/replaceState to enable patterns like history-driven modals."],"uses":{"params":["name","path"]}}]}
