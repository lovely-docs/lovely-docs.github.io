{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-sveltekit","core-concepts/routing",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","20-core-concepts/10-routing.md",true,{"fulltext":8,"digest":9,"short_digest":10},5158,839,117,{"input":12,"output":13,"details":14},6201,1067,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: Routing\n---\n\nAt the heart of SvelteKit is a _filesystem-based router_. The routes of your app — i.e. the URL paths that users can access — are defined by the directories in your codebase:\n\n- `src/routes` is the root route\n- `src/routes/about` creates an `/about` route\n- `src/routes/blog/[slug]` creates a route with a _parameter_, `slug`, that can be used to load data dynamically when a user requests a page like `/blog/hello-world`\n\n> [!NOTE] You can change `src/routes` to a different directory by editing the [project config](configuration).\n\nEach route directory contains one or more _route files_, which can be identified by their `+` prefix.\n\nWe'll introduce these files in a moment in more detail, but here are a few simple rules to help you remember how SvelteKit's routing works:\n\n* All files can run on the server\n* All files run on the client except `+server` files\n* `+layout` and `+error` files apply to subdirectories as well as the directory they live in\n\n## +page\n\n### +page.svelte\n\nA `+page.svelte` component defines a page of your app. By default, pages are rendered both on the server ([SSR](glossary#SSR)) for the initial request and in the browser ([CSR](glossary#CSR)) for subsequent navigation.\n\n```svelte\n\u003C!--- file: src/routes/+page.svelte --->\n\u003Ch1>Hello and welcome to my site!\u003C/h1>\n\u003Ca href=\"/about\">About my site\u003C/a>\n```\n\n```svelte\n\u003C!--- file: src/routes/about/+page.svelte --->\n\u003Ch1>About this site\u003C/h1>\n\u003Cp>TODO...\u003C/p>\n\u003Ca href=\"/\">Home\u003C/a>\n```\n\n> [!NOTE] SvelteKit uses `\u003Ca>` elements to navigate between routes, rather than a framework-specific `\u003CLink>` component.\n\nPages can receive data from `load` functions via the `data` prop.\n\n```svelte\n\u003C!--- file: src/routes/blog/[slug]/+page.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\u003C/script>\n\n\u003Ch1>{data.title}\u003C/h1>\n\u003Cdiv>{@html data.content}\u003C/div>\n```\n\n> [!LEGACY]\n> `PageProps` was added in 2.16.0. In earlier versions, you had to type the `data` property manually with `PageData` instead, see [$types](#\\$types).\n>\n> In Svelte 4, you'd use `export let data` instead.\n\n### +page.js\n\nOften, a page will need to load some data before it can be rendered. For this, we add a `+page.js` module that exports a `load` function:\n\n```js\n/// file: src/routes/blog/[slug]/+page.js\nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').PageLoad} */\nexport function load({ params }) {\n\tif (params.slug === 'hello-world') {\n\t\treturn {\n\t\t\ttitle: 'Hello world!',\n\t\t\tcontent: 'Welcome to our blog. Lorem ipsum dolor sit amet...'\n\t\t};\n\t}\n\n\terror(404, 'Not found');\n}\n```\n\nThis function runs alongside `+page.svelte`, which means it runs on the server during server-side rendering and in the browser during client-side navigation. See [`load`](load) for full details of the API.\n\nAs well as `load`, `+page.js` can export values that configure the page's behaviour:\n\n- `export const prerender = true` or `false` or `'auto'`\n- `export const ssr = true` or `false`\n- `export const csr = true` or `false`\n\nYou can find more information about these in [page options](page-options).\n\n### +page.server.js\n\nIf your `load` function can only run on the server — for example, if it needs to fetch data from a database or you need to access private [environment variables]($env-static-private) like API keys — then you can rename `+page.js` to `+page.server.js` and change the `PageLoad` type to `PageServerLoad`.\n\n```js\n/// file: src/routes/blog/[slug]/+page.server.js\n\n// @filename: ambient.d.ts\ndeclare global {\n\tconst getPostFromDatabase: (slug: string) => {\n\t\ttitle: string;\n\t\tcontent: string;\n\t}\n}\n\nexport {};\n\n// @filename: index.js\n// ---cut---\nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\tconst post = await getPostFromDatabase(params.slug);\n\n\tif (post) {\n\t\treturn post;\n\t}\n\n\terror(404, 'Not found');\n}\n```\n\nDuring client-side navigation, SvelteKit will load this data from the server, which means that the returned value must be serializable using [devalue](https://github.com/rich-harris/devalue). See [`load`](load) for full details of the API.\n\nLike `+page.js`, `+page.server.js` can export [page options](page-options) — `prerender`, `ssr` and `csr`.\n\nA `+page.server.js` file can also export _actions_. If `load` lets you read data from the server, `actions` let you write data _to_ the server using the `\u003Cform>` element. To learn how to use them, see the [form actions](form-actions) section.\n\n## +error\n\nIf an error occurs during `load`, SvelteKit will render a default error page. You can customise this error page on a per-route basis by adding an `+error.svelte` file:\n\n```svelte\n\u003C!--- file: src/routes/blog/[slug]/+error.svelte --->\n\u003Cscript>\n\timport { page } from '$app/state';\n\u003C/script>\n\n\u003Ch1>{page.status}: {page.error.message}\u003C/h1>\n```\n\n> [!LEGACY]\n> `$app/state` was added in SvelteKit 2.12. If you're using an earlier version or are using Svelte 4, use `$app/stores` instead.\n\nSvelteKit will 'walk up the tree' looking for the closest error boundary — if the file above didn't exist it would try `src/routes/blog/+error.svelte` and then `src/routes/+error.svelte` before rendering the default error page. If _that_ fails (or if the error was thrown from the `load` function of the root `+layout`, which sits 'above' the root `+error`), SvelteKit will bail out and render a static fallback error page, which you can customise by creating a `src/error.html` file.\n\nIf the error occurs inside a `load` function in `+layout(.server).js`, the closest error boundary in the tree is an `+error.svelte` file _above_ that layout (not next to it).\n\nIf no route can be found (404), `src/routes/+error.svelte` (or the default error page, if that file does not exist) will be used.\n\n> [!NOTE] `+error.svelte` is _not_ used when an error occurs inside [`handle`](hooks#Server-hooks-handle) or a [+server.js](#server) request handler.\n\nYou can read more about error handling [here](errors).\n\n## +layout\n\nSo far, we've treated pages as entirely standalone components — upon navigation, the existing `+page.svelte` component will be destroyed, and a new one will take its place.\n\nBut in many apps, there are elements that should be visible on _every_ page, such as top-level navigation or a footer. Instead of repeating them in every `+page.svelte`, we can put them in _layouts_.\n\n### +layout.svelte\n\nTo create a layout that applies to every page, make a file called `src/routes/+layout.svelte`. The default layout (the one that SvelteKit uses if you don't bring your own) looks like this...\n\n```svelte\n\u003Cscript>\n\tlet { children } = $props();\n\u003C/script>\n\n{@render children()}\n```\n\n...but we can add whatever markup, styles and behaviour we want. The only requirement is that the component includes a `@render` tag for the page content. For example, let's add a nav bar:\n\n```svelte\n\u003C!--- file: src/routes/+layout.svelte --->\n\u003Cscript>\n\tlet { children } = $props();\n\u003C/script>\n\n\u003Cnav>\n\t\u003Ca href=\"/\">Home\u003C/a>\n\t\u003Ca href=\"/about\">About\u003C/a>\n\t\u003Ca href=\"/settings\">Settings\u003C/a>\n\u003C/nav>\n\n{@render children()}\n```\n\nIf we create pages for `/`, `/about` and `/settings`...\n\n```html\n/// file: src/routes/+page.svelte\n\u003Ch1>Home\u003C/h1>\n```\n\n```html\n/// file: src/routes/about/+page.svelte\n\u003Ch1>About\u003C/h1>\n```\n\n```html\n/// file: src/routes/settings/+page.svelte\n\u003Ch1>Settings\u003C/h1>\n```\n\n...the nav will always be visible, and clicking between the three pages will only result in the `\u003Ch1>` being replaced.\n\nLayouts can be _nested_. Suppose we don't just have a single `/settings` page, but instead have nested pages like `/settings/profile` and `/settings/notifications` with a shared submenu (for a real-life example, see [github.com/settings](https://github.com/settings)).\n\nWe can create a layout that only applies to pages below `/settings` (while inheriting the root layout with the top-level nav):\n\n```svelte\n\u003C!--- file: src/routes/settings/+layout.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').LayoutProps} */\n\tlet { data, children } = $props();\n\u003C/script>\n\n\u003Ch1>Settings\u003C/h1>\n\n\u003Cdiv class=\"submenu\">\n\t{#each data.sections as section}\n\t\t\u003Ca href=\"/settings/{section.slug}\">{section.title}\u003C/a>\n\t{/each}\n\u003C/div>\n\n{@render children()}\n```\n\n> [!LEGACY]\n> `LayoutProps` was added in 2.16.0. In earlier versions, you had to [type the properties manually instead](#\\$types).\n\nYou can see how `data` is populated by looking at the `+layout.js` example in the next section just below.\n\nBy default, each layout inherits the layout above it. Sometimes that isn't what you want - in this case, [advanced layouts](advanced-routing#Advanced-layouts) can help you.\n\n### +layout.js\n\nJust like `+page.svelte` loading data from `+page.js`, your `+layout.svelte` component can get data from a [`load`](load) function in `+layout.js`.\n\n```js\n/// file: src/routes/settings/+layout.js\n/** @type {import('./$types').LayoutLoad} */\nexport function load() {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\nIf a `+layout.js` exports [page options](page-options) — `prerender`, `ssr` and `csr` — they will be used as defaults for child pages.\n\nData returned from a layout's `load` function is also available to all its child pages:\n\n```svelte\n\u003C!--- file: src/routes/settings/profile/+page.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\n\tconsole.log(data.sections); // [{ slug: 'profile', title: 'Profile' }, ...]\n\u003C/script>\n```\n\n> [!NOTE] Often, layout data is unchanged when navigating between pages. SvelteKit will intelligently rerun [`load`](load) functions when necessary.\n\n### +layout.server.js\n\nTo run your layout's `load` function on the server, move it to `+layout.server.js`, and change the `LayoutLoad` type to `LayoutServerLoad`.\n\nLike `+layout.js`, `+layout.server.js` can export [page options](page-options) — `prerender`, `ssr` and `csr`.\n\n## +server\n\nAs well as pages, you can define routes with a `+server.js` file (sometimes referred to as an 'API route' or an 'endpoint'), which gives you full control over the response. Your `+server.js` file exports functions corresponding to HTTP verbs like `GET`, `POST`, `PATCH`, `PUT`, `DELETE`, `OPTIONS`, and `HEAD` that take a [`RequestEvent`](@sveltejs-kit#RequestEvent) argument and return a [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) object.\n\nFor example we could create an `/api/random-number` route with a `GET` handler:\n\n```js\n/// file: src/routes/api/random-number/+server.js\nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').RequestHandler} */\nexport function GET({ url }) {\n\tconst min = Number(url.searchParams.get('min') ?? '0');\n\tconst max = Number(url.searchParams.get('max') ?? '1');\n\n\tconst d = max - min;\n\n\tif (isNaN(d) || d \u003C 0) {\n\t\terror(400, 'min and max must be numbers, and min must be less than max');\n\t}\n\n\tconst random = min + Math.random() * d;\n\n\treturn new Response(String(random));\n}\n```\n\nThe first argument to `Response` can be a [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream), making it possible to stream large amounts of data or create server-sent events (unless deploying to platforms that buffer responses, like AWS Lambda).\n\nYou can use the [`error`](@sveltejs-kit#error), [`redirect`](@sveltejs-kit#redirect) and [`json`](@sveltejs-kit#json) methods from `@sveltejs/kit` for convenience (but you don't have to).\n\nIf an error is thrown (either `error(...)` or an unexpected error), the response will be a JSON representation of the error or a fallback error page — which can be customised via `src/error.html` — depending on the `Accept` header. The [`+error.svelte`](#error) component will _not_ be rendered in this case. You can read more about error handling [here](errors).\n\n> [!NOTE] When creating an `OPTIONS` handler, note that Vite will inject `Access-Control-Allow-Origin` and `Access-Control-Allow-Methods` headers — these will not be present in production unless you add them.\n\n> [!NOTE] `+layout` files have no effect on `+server.js` files. If you want to run some logic before each request, add it to the server [`handle`](hooks#Server-hooks-handle) hook.\n\n### Receiving data\n\nBy exporting `POST`/`PUT`/`PATCH`/`DELETE`/`OPTIONS`/`HEAD` handlers, `+server.js` files can be used to create a complete API:\n\n```svelte\n\u003C!--- file: src/routes/add/+page.svelte --->\n\u003Cscript>\n\tlet a = 0;\n\tlet b = 0;\n\tlet total = 0;\n\n\tasync function add() {\n\t\tconst response = await fetch('/api/add', {\n\t\t\tmethod: 'POST',\n\t\t\tbody: JSON.stringify({ a, b }),\n\t\t\theaders: {\n\t\t\t\t'content-type': 'application/json'\n\t\t\t}\n\t\t});\n\n\t\ttotal = await response.json();\n\t}\n\u003C/script>\n\n\u003Cinput type=\"number\" bind:value={a}> +\n\u003Cinput type=\"number\" bind:value={b}> =\n{total}\n\n\u003Cbutton onclick={add}>Calculate\u003C/button>\n```\n\n```js\n/// file: src/routes/api/add/+server.js\nimport { json } from '@sveltejs/kit';\n\n/** @type {import('./$types').RequestHandler} */\nexport async function POST({ request }) {\n\tconst { a, b } = await request.json();\n\treturn json(a + b);\n}\n```\n\n> [!NOTE] In general, [form actions](form-actions) are a better way to submit data from the browser to the server.\n\n> [!NOTE] If a `GET` handler is exported, a `HEAD` request will return the `content-length` of the `GET` handler's response body.\n\n### Fallback method handler\n\nExporting the `fallback` handler will match any unhandled request methods, including methods like `MOVE` which have no dedicated export from `+server.js`.\n\n```js\n/// file: src/routes/api/add/+server.js\nimport { json, text } from '@sveltejs/kit';\n\n/** @type {import('./$types').RequestHandler} */\nexport async function POST({ request }) {\n\tconst { a, b } = await request.json();\n\treturn json(a + b);\n}\n\n// This handler will respond to PUT, PATCH, DELETE, etc.\n/** @type {import('./$types').RequestHandler} */\nexport async function fallback({ request }) {\n\treturn text(`I caught your ${request.method} request!`);\n}\n```\n\n> [!NOTE] For `HEAD` requests, the `GET` handler takes precedence over the `fallback` handler.\n\n### Content negotiation\n\n`+server.js` files can be placed in the same directory as `+page` files, allowing the same route to be either a page or an API endpoint. To determine which, SvelteKit applies the following rules:\n\n- `PUT`/`PATCH`/`DELETE`/`OPTIONS` requests are always handled by `+server.js` since they do not apply to pages\n- `GET`/`POST`/`HEAD` requests are treated as page requests if the `accept` header prioritises `text/html` (in other words, it's a browser page request), else they are handled by `+server.js`.\n- Responses to `GET` requests will include a `Vary: Accept` header, so that proxies and browsers cache HTML and JSON responses separately.\n\n## $types\n\nThroughout the examples above, we've been importing types from a `$types.d.ts` file. This is a file SvelteKit creates for you in a hidden directory if you're using TypeScript (or JavaScript with JSDoc type annotations) to give you type safety when working with your root files.\n\nFor example, annotating `let { data } = $props()` with `PageProps` (or `LayoutProps`, for a `+layout.svelte` file) tells TypeScript that the type of `data` is whatever was returned from `load`:\n\n```svelte\n\u003C!--- file: src/routes/blog/[slug]/+page.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\u003C/script>\n```\n\n> [!NOTE]\n> The `PageProps` and `LayoutProps` types, added in 2.16.0, are a shortcut for typing the `data` prop as `PageData` or `LayoutData`, as well as other props, such as `form` for pages, or `children` for layouts. In earlier versions, you had to type these properties manually. For example, for a page:\n>\n> ```js\n> /// file: +page.svelte\n> /** @type {{ data: import('./$types').PageData, form: import('./$types').ActionData }} */\n> let { data, form } = $props();\n> ```\n>\n> Or, for a layout:\n>\n> ```js\n> /// file: +layout.svelte\n> /** @type {{ data: import('./$types').LayoutData, children: Snippet }} */\n> let { data, children } = $props();\n> ```\n\nIn turn, annotating the `load` function with `PageLoad`, `PageServerLoad`, `LayoutLoad` or `LayoutServerLoad` (for `+page.js`, `+page.server.js`, `+layout.js` and `+layout.server.js` respectively) ensures that `params` and the return value are correctly typed.\n\nIf you're using VS Code or any IDE that supports the language server protocol and TypeScript plugins then you can omit these types _entirely_! Svelte's IDE tooling will insert the correct types for you, so you'll get type checking without writing them yourself. It also works with our command line tool `svelte-check`.\n\nYou can read more about omitting `$types` in our [blog post](/blog/zero-config-type-safety) about it.\n\n## Other files\n\nAny other files inside a route directory are ignored by SvelteKit. This means you can colocate components and utility modules with the routes that need them.\n\nIf components and modules are needed by multiple routes, it's a good idea to put them in [`$lib`]($lib).\n\n## Further reading\n\n- [Tutorial: Routing](/tutorial/kit/pages)\n- [Tutorial: API routes](/tutorial/kit/get-handlers)\n- [Docs: Advanced routing](advanced-routing)\n","## Filesystem-based routing\n\nRoutes are defined by directory structure in `src/routes`:\n- `src/routes` → `/`\n- `src/routes/about` → `/about`\n- `src/routes/blog/[slug]` → `/blog/:slug` (dynamic parameter)\n\n## Route files (identified by `+` prefix)\n\n**Rules:**\n- All files can run on server\n- All files run on client except `+server` files\n- `+layout` and `+error` files apply to subdirectories and their own directory\n\n## +page.svelte / +page.js / +page.server.js\n\n`+page.svelte` defines a page component. Pages render on server (SSR) initially, then in browser (CSR) for navigation.\n\n`+page.js` exports a `load` function that runs on both server and client:\n```js\nexport function load({ params }) {\n\treturn { title: 'Hello', content: 'Welcome...' };\n}\n```\n\n`+page.server.js` is for server-only load functions (database access, private env vars). Data is serialized via devalue for client-side navigation.\n\nBoth can export page options: `prerender`, `ssr`, `csr`.\n\n`+page.server.js` can also export `actions` for form submissions.\n\n## +error.svelte\n\nCustomizes error pages. SvelteKit walks up the tree to find the closest error boundary. If none exists, renders default error page (customizable via `src/error.html`).\n\n## +layout.svelte / +layout.js / +layout.server.js\n\n`+layout.svelte` wraps pages with shared markup (nav, footer). Must include `{@render children()}` for page content.\n\nLayouts can be nested. Child layouts inherit parent layouts.\n\n`+layout.js` exports `load` function providing data to layout and all child pages:\n```js\nexport function load() {\n\treturn { sections: [{ slug: 'profile', title: 'Profile' }] };\n}\n```\n\n`+layout.server.js` for server-only load functions.\n\nLayout `load` functions are intelligently rerun only when necessary.\n\n## +server.js\n\nAPI routes. Export HTTP verb handlers (`GET`, `POST`, `PATCH`, `PUT`, `DELETE`, `OPTIONS`, `HEAD`) that receive `RequestEvent` and return `Response`:\n```js\nexport function GET({ url }) {\n\tconst min = Number(url.searchParams.get('min') ?? '0');\n\treturn new Response(String(min + Math.random()));\n}\n```\n\nCan export `fallback` handler for unhandled methods.\n\nUse `error()`, `redirect()`, `json()` helpers from `@sveltejs/kit`.\n\nErrors return JSON or fallback error page (not `+error.svelte`).\n\n**Content negotiation:** When `+server.js` and `+page` coexist:\n- `PUT`/`PATCH`/`DELETE`/`OPTIONS` → always `+server.js`\n- `GET`/`POST`/`HEAD` → `+server.js` if `accept` header doesn't prioritize `text/html`, else page request\n- `GET` responses include `Vary: Accept` header\n\n## $types\n\nSvelteKit generates `$types.d.ts` for type safety. Use `PageProps`/`LayoutProps` for component props, `PageLoad`/`PageServerLoad`/`LayoutLoad`/`LayoutServerLoad` for load functions. IDE tooling can auto-insert these types.","Routes defined by `src/routes` directory structure with `+` prefixed files. `+page.svelte` for pages, `+page.js`/`+page.server.js` for load functions, `+layout.svelte` for shared markup, `+server.js` for API endpoints, `+error.svelte` for error pages. Load functions run on server/client or server-only. `+server.js` exports HTTP handlers. Use `$types` for type safety.","Filesystem-based routing with special `+` prefixed files for pages, layouts, API endpoints, and error handling."],"uses":{"params":["name","path"]}}]}
