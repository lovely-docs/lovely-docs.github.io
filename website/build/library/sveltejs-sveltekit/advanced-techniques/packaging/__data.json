{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-sveltekit","advanced-techniques/packaging",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","30-advanced/70-packaging.md",true,{"fulltext":8,"digest":9,"short_digest":10},4062,941,383,{"input":12,"output":13,"details":14},5103,1448,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: Packaging\n---\n\nYou can use SvelteKit to build apps as well as component libraries, using the `@sveltejs/package` package (`npx sv create` has an option to set this up for you).\n\nWhen you're creating an app, the contents of `src/routes` is the public-facing stuff; [`src/lib`]($lib) contains your app's internal library.\n\nA component library has the exact same structure as a SvelteKit app, except that `src/lib` is the public-facing bit, and your root `package.json` is used to publish the package. `src/routes` might be a documentation or demo site that accompanies the library, or it might just be a sandbox you use during development.\n\nRunning the `svelte-package` command from `@sveltejs/package` will take the contents of `src/lib` and generate a `dist` directory (which can be [configured](#Options)) containing the following:\n\n- All the files in `src/lib`. Svelte components will be preprocessed, TypeScript files will be transpiled to JavaScript.\n- Type definitions (`d.ts` files) which are generated for Svelte, JavaScript and TypeScript files. You need to install `typescript >= 4.0.0` for this. Type definitions are placed next to their implementation, hand-written `d.ts` files are copied over as is. You can [disable generation](#Options), but we strongly recommend against it — people using your library might use TypeScript, for which they require these type definition files.\n\n> [!NOTE] `@sveltejs/package` version 1 generated a `package.json`. This is no longer the case and it will now use the `package.json` from your project and validate that it is correct instead. If you're still on version 1, see [this PR](https://github.com/sveltejs/kit/pull/8922) for migration instructions.\n\n## Anatomy of a package.json\n\nSince you're now building a library for public use, the contents of your `package.json` will become more important. Through it, you configure the entry points of your package, which files are published to npm, and which dependencies your library has. Let's go through the most important fields one by one.\n\n### name\n\nThis is the name of your package. It will be available for others to install using that name, and visible on `https://npmjs.com/package/\u003Cname>`.\n\n```json\n{\n\t\"name\": \"your-library\"\n}\n```\n\nRead more about it [here](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#name).\n\n### license\n\nEvery package should have a license field so people know how they are allowed to use it. A very popular license which is also very permissive in terms of distribution and reuse without warranty is `MIT`.\n\n```json\n{\n\t\"license\": \"MIT\"\n}\n```\n\nRead more about it [here](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#license). Note that you should also include a `LICENSE` file in your package.\n\n### files\n\nThis tells npm which files it will pack up and upload to npm. It should contain your output folder (`dist` by default). Your `package.json` and `README` and `LICENSE` will always be included, so you don't need to specify them.\n\n```json\n{\n\t\"files\": [\"dist\"]\n}\n```\n\nTo exclude unnecessary files (such as unit tests, or modules that are only imported from `src/routes` etc) you can add them to an `.npmignore` file. This will result in smaller packages that are faster to install.\n\nRead more about it [here](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#files).\n\n### exports\n\nThe `\"exports\"` field contains the package's entry points. If you set up a new library project through `npx sv create`, it's set to a single export, the package root:\n\n```json\n{\n\t\"exports\": {\n\t\t\".\": {\n\t\t\t\"types\": \"./dist/index.d.ts\",\n\t\t\t\"svelte\": \"./dist/index.js\"\n\t\t}\n\t}\n}\n```\n\nThis tells bundlers and tooling that your package only has one entry point, the root, and everything should be imported through that, like this:\n\n```js\n// @errors: 2307\nimport { Something } from 'your-library';\n```\n\nThe `types` and `svelte` keys are [export conditions](https://nodejs.org/api/packages.html#conditional-exports). They tell tooling what file to import when they look up the `your-library` import:\n\n- TypeScript sees the `types` condition and looks up the type definition file. If you don't publish type definitions, omit this condition.\n- Svelte-aware tooling sees the `svelte` condition and knows this is a Svelte component library. If you publish a library that does not export any Svelte components and that could also work in non-Svelte projects (for example a Svelte store library), you can replace this condition with `default`.\n\n> [!NOTE] Previous versions of `@sveltejs/package` also added a `package.json` export. This is no longer part of the template because all tooling can now deal with a `package.json` not being explicitly exported.\n\nYou can adjust `exports` to your liking and provide more entry points. For example, if instead of a `src/lib/index.js` file that re-exported components you wanted to expose a `src/lib/Foo.svelte` component directly, you could create the following export map...\n\n```json\n{\n\t\"exports\": {\n\t\t\"./Foo.svelte\": {\n\t\t\t\"types\": \"./dist/Foo.svelte.d.ts\",\n\t\t\t\"svelte\": \"./dist/Foo.svelte\"\n\t\t}\n\t}\n}\n```\n\n...and a consumer of your library could import the component like so:\n\n```js\n// @filename: ambient.d.ts\ndeclare module 'your-library/Foo.svelte';\n\n// @filename: index.js\n// ---cut---\nimport Foo from 'your-library/Foo.svelte';\n```\n\n> [!NOTE] Beware that doing this will need additional care if you provide type definitions. Read more about the caveat [here](#TypeScript)\n\nIn general, each key of the exports map is the path the user will have to use to import something from your package, and the value is the path to the file that will be imported or a map of export conditions which in turn contains these file paths.\n\nRead more about `exports` [here](https://nodejs.org/docs/latest-v18.x/api/packages.html#package-entry-points).\n\n### svelte\n\nThis is a legacy field that enabled tooling to recognise Svelte component libraries. It's no longer necessary when using the `svelte` [export condition](#Anatomy-of-a-package.json-exports), but for backwards compatibility with outdated tooling that doesn't yet know about export conditions it's good to keep it around. It should point towards your root entry point.\n\n```json\n{\n\t\"svelte\": \"./dist/index.js\"\n}\n```\n\n### sideEffects\n\nThe `sideEffects` field in `package.json` is used by bundlers to determine if a module may contain code that has side effects. A module is considered to have side effects if it makes changes that are observable from other scripts outside the module when it's imported. For example, side effects include modifying global variables or the prototype of built-in JavaScript objects. Because a side effect could potentially affect the behavior of other parts of the application, these files/modules will be included in the final bundle regardless of whether their exports are used in the application. It is a best practice to avoid side effects in your code.\n\nSetting the `sideEffects` field in `package.json` can help the bundler to be more aggressive in eliminating unused exports from the final bundle, a process known as tree-shaking. This results in smaller and more efficient bundles. Different bundlers handle `sideEffects` in various manners. While not necessary for Vite, we recommend that libraries state that all CSS files have side effects so that your library will be [compatible with webpack](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free). This is the configuration that comes with newly created projects:\n\n```json\n/// file: package.json\n{\n\t\"sideEffects\": [\"**/*.css\"]\n}\n```\n\n> [!NOTE] If the scripts in your library have side effects, ensure that you update the `sideEffects` field. All scripts are marked as side effect free by default in newly created projects. If a file with side effects is incorrectly marked as having no side effects, it can result in broken functionality.\n\nIf your package has files with side effects, you can specify them in an array:\n\n```json\n/// file: package.json\n{\n    \"sideEffects\": [\n    \t\"**/*.css\",\n    \t\"./dist/sideEffectfulFile.js\"\n    ]\n}\n```\n\nThis will treat only the specified files as having side effects.\n\n## TypeScript\n\nYou should ship type definitions for your library even if you don't use TypeScript yourself so that people who do get proper intellisense when using your library. `@sveltejs/package` makes the process of generating types mostly opaque to you. By default, when packaging your library, type definitions are auto-generated for JavaScript, TypeScript and Svelte files. All you need to ensure is that the `types` condition in the [exports](#Anatomy-of-a-package.json-exports) map points to the correct files. When initialising a library project through `npx sv create`, this is automatically setup for the root export.\n\nIf you have something else than a root export however — for example providing a `your-library/foo` import — you need to take additional care for providing type definitions. Unfortunately, TypeScript by default will _not_ resolve the `types` condition for an export like `{ \"./foo\": { \"types\": \"./dist/foo.d.ts\", ... }}`. Instead, it will search for a `foo.d.ts` relative to the root of your library (i.e. `your-library/foo.d.ts` instead of `your-library/dist/foo.d.ts`). To fix this, you have two options:\n\nThe first option is to require people using your library to set the `moduleResolution` option in their `tsconfig.json` (or `jsconfig.json`) to `bundler` (available since TypeScript 5, the best and recommended option in the future), `node16` or `nodenext`. This opts TypeScript into actually looking at the exports map and resolving the types correctly.\n\nThe second option is to (ab)use the `typesVersions` feature from TypeScript to wire up the types. This is a field inside `package.json` TypeScript uses to check for different type definitions depending on the TypeScript version, and also contains a path mapping feature for that. We leverage that path mapping feature to get what we want. For the mentioned `foo` export above, the corresponding `typesVersions` looks like this:\n\n```json\n{\n\t\"exports\": {\n\t\t\"./foo\": {\n\t\t\t\"types\": \"./dist/foo.d.ts\",\n\t\t\t\"svelte\": \"./dist/foo.js\"\n\t\t}\n\t},\n\t\"typesVersions\": {\n\t\t\">4.0\": {\n\t\t\t\"foo\": [\"./dist/foo.d.ts\"]\n\t\t}\n\t}\n}\n```\n\n`>4.0` tells TypeScript to check the inner map if the used TypeScript version is greater than 4 (which should in practice always be true). The inner map tells TypeScript that the typings for `your-library/foo` are found within `./dist/foo.d.ts`, which essentially replicates the `exports` condition. You also have `*` as a wildcard at your disposal to make many type definitions at once available without repeating yourself. Note that if you opt into `typesVersions` you have to declare all type imports through it, including the root import (which is defined as `\"index.d.ts\": [..]`).\n\nYou can read more about that feature [here](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#version-selection-with-typesversions).\n\n## Best practices\n\nYou should avoid using SvelteKit-specific modules like `$app/environment` in your packages unless you intend for them to only be consumable by other SvelteKit projects. E.g. rather than using `import { browser } from '$app/environment'` you could use `import { BROWSER } from 'esm-env'` ([see esm-env docs](https://github.com/benmccann/esm-env)). You may also wish to pass in things like the current URL or a navigation action as a prop rather than relying directly on `$app/state`, `$app/navigation`, etc. Writing your app in this more generic fashion will also make it easier to setup tools for testing, UI demos and so on.\n\nEnsure that you add [aliases](configuration#alias) via `svelte.config.js` (not `vite.config.js` or `tsconfig.json`), so that they are processed by `svelte-package`.\n\nYou should think carefully about whether or not the changes you make to your package are a bug fix, a new feature, or a breaking change, and update the package version accordingly. Note that if you remove any paths from `exports` or any `export` conditions inside them from your existing library, that should be regarded as a breaking change.\n\n```json\n{\n\t\"exports\": {\n\t\t\".\": {\n\t\t\t\"types\": \"./dist/index.d.ts\",\n// changing `svelte` to `default` is a breaking change:\n---\t\t\t\"svelte\": \"./dist/index.js\"---\n+++\t\t\t\"default\": \"./dist/index.js\"+++\n\t\t},\n// removing this is a breaking change:\n---\t\t\"./foo\": {\n\t\t\t\"types\": \"./dist/foo.d.ts\",\n\t\t\t\"svelte\": \"./dist/foo.js\",\n\t\t\t\"default\": \"./dist/foo.js\"\n\t\t},---\n// adding this is ok:\n+++\t\t\"./bar\": {\n\t\t\t\"types\": \"./dist/bar.d.ts\",\n\t\t\t\"svelte\": \"./dist/bar.js\",\n\t\t\t\"default\": \"./dist/bar.js\"\n\t\t}+++\n\t}\n}\n```\n\n## Source maps\n\nYou can create so-called declaration maps (`d.ts.map` files) by setting `\"declarationMap\": true` in your `tsconfig.json`. This will allow editors such as VS Code to go to the original `.ts` or `.svelte` file when using features like _Go to Definition_. This means you also need to publish your source files alongside your dist folder in a way that the relative path inside the declaration files leads to a file on disk. Assuming that you have all your library code inside `src/lib` as suggested by Svelte's CLI, this is as simple as adding `src/lib` to `files` in your `package.json`:\n\n```json\n{\n\t\"files\": [\n\t\t\"dist\",\n\t\t\"!dist/**/*.test.*\",\n\t\t\"!dist/**/*.spec.*\",\n\t\t+++\"src/lib\",\n\t\t\"!src/lib/**/*.test.*\",\n\t\t\"!src/lib/**/*.spec.*\"+++\n\t]\n}\n```\n\n## Options\n\n`svelte-package` accepts the following options:\n\n- `-w`/`--watch` — watch files in `src/lib` for changes and rebuild the package\n- `-i`/`--input` — the input directory which contains all the files of the package. Defaults to `src/lib`\n- `-o`/`--output` — the output directory where the processed files are written to. Your `package.json`'s `exports` should point to files inside there, and the `files` array should include that folder. Defaults to `dist`\n- `-p`/`--preserve-output` — prevent deletion of the output directory before packaging. Defaults to `false`, which means that the output directory will be emptied first\n- `-t`/`--types` — whether or not to create type definitions (`d.ts` files). We strongly recommend doing this as it fosters ecosystem library quality. Defaults to `true`\n- `--tsconfig` - the path to a tsconfig or jsconfig. When not provided, searches for the next upper tsconfig/jsconfig in the workspace path.\n\n## Publishing\n\nTo publish the generated package:\n\n```sh\nnpm publish\n```\n\n## Caveats\n\nAll relative file imports need to be fully specified, adhering to Node's ESM algorithm. This means that for a file like `src/lib/something/index.js`, you must include the filename with the extension:\n\n```js\n// @errors: 2307\nimport { something } from './something+++/index.js+++';\n```\n\nIf you are using TypeScript, you need to import `.ts` files the same way, but using a `.js` file ending, _not_ a `.ts` file ending. (This is a TypeScript design decision outside our control.) Setting `\"moduleResolution\": \"NodeNext\"` in your `tsconfig.json` or `jsconfig.json` will help you with this.\n\nAll files except Svelte files (preprocessed) and TypeScript files (transpiled to JavaScript) are copied across as-is.\n","## Building Component Libraries\n\nUse `@sveltejs/package` to build component libraries. Structure: `src/lib` is public-facing, `src/routes` is optional documentation/demo, `package.json` is used for publishing.\n\nRunning `svelte-package` generates a `dist` directory containing:\n- All files from `src/lib` (Svelte components preprocessed, TypeScript transpiled to JavaScript)\n- Auto-generated type definitions (`d.ts` files) for all files\n\n## package.json Configuration\n\n**name** — Package name on npm\n```json\n{ \"name\": \"your-library\" }\n```\n\n**license** — Recommended: `MIT`\n\n**files** — Which files npm publishes (should include `dist`)\n```json\n{ \"files\": [\"dist\"] }\n```\n\n**exports** — Entry points for the package\n```json\n{\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"svelte\": \"./dist/index.js\"\n    }\n  }\n}\n```\n\nThe `types` condition points to type definitions, `svelte` condition indicates Svelte component library. You can define multiple entry points:\n```json\n{\n  \"exports\": {\n    \"./Foo.svelte\": {\n      \"types\": \"./dist/Foo.svelte.d.ts\",\n      \"svelte\": \"./dist/Foo.svelte\"\n    }\n  }\n}\n```\n\n**svelte** — Legacy field for backwards compatibility, points to root entry point\n\n**sideEffects** — Helps bundlers with tree-shaking. Mark CSS files as having side effects for webpack compatibility:\n```json\n{ \"sideEffects\": [\"**/*.css\"] }\n```\n\n## TypeScript\n\nType definitions are auto-generated. For non-root exports, TypeScript won't resolve the `types` condition by default. Solutions:\n1. Require consumers to set `moduleResolution` to `bundler`, `node16`, or `nodenext` in their tsconfig\n2. Use `typesVersions` field to map types:\n```json\n{\n  \"exports\": { \"./foo\": { \"types\": \"./dist/foo.d.ts\", \"svelte\": \"./dist/foo.js\" } },\n  \"typesVersions\": { \">4.0\": { \"foo\": [\"./dist/foo.d.ts\"] } }\n}\n```\n\n## Best Practices\n\n- Avoid SvelteKit-specific modules like `$app/environment`. Use `esm-env` instead or pass values as props\n- Define aliases in `svelte.config.js`, not `vite.config.js` or `tsconfig.json`\n- Treat removal of export paths or conditions as breaking changes\n- Enable declaration maps with `\"declarationMap\": true` in tsconfig and include `src/lib` in `files` array for source navigation\n\n## Source Maps\n\nCreate declaration maps (`d.ts.map` files) for editor \"Go to Definition\" support:\n```json\n{\n  \"files\": [\"dist\", \"!dist/**/*.test.*\", \"src/lib\", \"!src/lib/**/*.test.*\"]\n}\n```\n\n## svelte-package Options\n\n- `-w`/`--watch` — Watch for changes\n- `-i`/`--input` — Input directory (default: `src/lib`)\n- `-o`/`--output` — Output directory (default: `dist`)\n- `-p`/`--preserve-output` — Don't delete output before packaging\n- `-t`/`--types` — Generate type definitions (default: `true`)\n- `--tsconfig` — Path to tsconfig/jsconfig\n\n## Publishing\n\n```sh\nnpm publish\n```\n\n## Caveats\n\n- All relative imports must be fully specified with file extensions per Node's ESM algorithm: `import { x } from './something/index.js'`\n- TypeScript imports must use `.js` extension, not `.ts`\n- Non-Svelte and non-TypeScript files are copied as-is","## Building Component Libraries\n\nUse `@sveltejs/package` to build libraries with `src/lib` as public-facing code. Generates `dist` with preprocessed components and auto-generated type definitions.\n\n## package.json Configuration\n\n**exports** — Define entry points with `types` and `svelte` conditions:\n```json\n{\n  \"exports\": {\n    \".\": { \"types\": \"./dist/index.d.ts\", \"svelte\": \"./dist/index.js\" },\n    \"./Foo.svelte\": { \"types\": \"./dist/Foo.svelte.d.ts\", \"svelte\": \"./dist/Foo.svelte\" }\n  }\n}\n```\n\n**files** — Include `dist` folder\n**license** — Recommended: `MIT`\n**sideEffects** — Mark CSS as having side effects: `[\"**/*.css\"]`\n\n## TypeScript\n\nType definitions auto-generate. For non-root exports, use `typesVersions` to map types:\n```json\n{\n  \"typesVersions\": { \">4.0\": { \"foo\": [\"./dist/foo.d.ts\"] } }\n}\n```\n\n## Best Practices\n\n- Avoid SvelteKit-specific modules; use `esm-env` or pass values as props\n- Define aliases in `svelte.config.js`\n- Removing export paths/conditions is a breaking change\n- Enable declaration maps for source navigation\n\n## Caveats\n\n- All relative imports need full paths with extensions: `import { x } from './something/index.js'`\n- TypeScript imports use `.js` extension, not `.ts`","How to build and publish component libraries with SvelteKit using @sveltejs/package, configuring package.json exports, handling TypeScript definitions, and best practices."],"uses":{"params":["name","path"]}}]}
