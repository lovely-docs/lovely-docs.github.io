{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","Runtime APIs/context",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","06-runtime/02-context.md",true,{"fulltext":8,"digest":9,"short_digest":10},1638,364,126,{"input":12,"output":13,"details":14},2675,600,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: Context\n---\n\nContext allows components to access values owned by parent components without passing them down as props (potentially through many layers of intermediate components, known as 'prop-drilling'). The parent component sets context with `setContext(key, value)`...\n\n```svelte\n\u003C!--- file: Parent.svelte --->\n\u003Cscript>\n\timport { setContext } from 'svelte';\n\n\tsetContext('my-context', 'hello from Parent.svelte');\n\u003C/script>\n```\n\n...and the child retrieves it with `getContext`:\n\n```svelte\n\u003C!--- file: Child.svelte --->\n\u003Cscript>\n\timport { getContext } from 'svelte';\n\n\tconst message = getContext('my-context');\n\u003C/script>\n\n\u003Ch1>{message}, inside Child.svelte\u003C/h1>\n```\n\nThis is particularly useful when `Parent.svelte` is not directly aware of `Child.svelte`, but instead renders it as part of a `children` [snippet](snippet) ([demo](/playground/untitled#H4sIAAAAAAAAE42Q3W6DMAyFX8WyJgESK-oto6hTX2D3YxcM3IIUQpR40yqUd58CrCXsp7tL7HNsf2dAWXaEKR56yfTBGOOxFWQwfR6Qz8q1XAHjL-GjUhvzToJd7bU09FO9ctMkG0wxM5VuFeeFLLjtVK8ZnkpNkuGo-w6CTTJ9Z3PwsBAemlbUF934W8iy5DpaZtOUcU02-ZLcaS51jHEkTFm_kY1_wfOO8QnXrb8hBzDEc6pgZ4gFoyz4KgiD7nxfTe8ghqAhIfrJ46cTzVZBbkPlODVJsLCDO6V7ZcJoncyw1yRr0hd1GNn_ZbEM3I9i1bmVxOlWElUvDUNHxpQngt3C4CXzjS1rtvkw22wMrTRtTbC8Lkuabe7jvthPPe3DofYCAAA=)):\n\n```svelte\n\u003CParent>\n\t\u003CChild />\n\u003C/Parent>\n```\n\nThe key (`'my-context'`, in the example above) and the context itself can be any JavaScript value.\n\nIn addition to [`setContext`](svelte#setContext) and [`getContext`](svelte#getContext), Svelte exposes [`hasContext`](svelte#hasContext) and [`getAllContexts`](svelte#getAllContexts) functions.\n\n## Using context with state\n\nYou can store reactive state in context ([demo](/playground/untitled#H4sIAAAAAAAAE41R0W6DMAz8FSuaBNUQdK8MkKZ-wh7HHihzu6hgosRMm1D-fUpSVNq12x4iEvvOx_kmQU2PIhfP3DCCJGgHYvxkkYid7NCI_GUS_KUcxhVEMjOelErNB3bsatvG4LW6n0ZsRC4K02qpuKqpZtmrQTNMYJA3QRAs7PTQQxS40eMCt3mX3duxnWb-lS5h7nTI0A4jMWoo4c44P_Hku-zrOazdy64chWo-ScfRkRgl8wgHKrLTH1OxHZkHgoHaTraHcopXUFYzPPVfuC_hwQaD1GrskdiNCdQwJljJqlvXfyqVsA5CGg0uRUQifHw56xFtciO75QrP07vo_JXf_tf8yK2ezDKY_ZWt_1y2qqYzv7bI1IW1V_sN19m-07wCAAA=))...\n\n```svelte\n\u003Cscript>\n\timport { setContext } from 'svelte';\n\timport Child from './Child.svelte';\n\n\tlet counter = $state({\n\t\tcount: 0\n\t});\n\n\tsetContext('counter', counter);\n\u003C/script>\n\n\u003Cbutton onclick={() => counter.count += 1}>\n\tincrement\n\u003C/button>\n\n\u003CChild />\n\u003CChild />\n\u003CChild />\n```\n\n...though note that if you _reassign_ `counter` instead of updating it, you will 'break the link' â€” in other words instead of this...\n\n```svelte\n\u003Cbutton onclick={() => counter = { count: 0 }}>\n\treset\n\u003C/button>\n```\n\n...you must do this:\n\n```svelte\n\u003Cbutton onclick={() => +++counter.count = 0+++}>\n\treset\n\u003C/button>\n```\n\nSvelte will warn you if you get it wrong.\n\n## Type-safe context\n\nA useful pattern is to wrap the calls to `setContext` and `getContext` inside helper functions that let you preserve type safety:\n\n```js\n/// file: context.js\n// @filename: ambient.d.ts\ninterface User {}\n\n// @filename: index.js\n// ---cut---\nimport { getContext, setContext } from 'svelte';\n\nconst key = {};\n\n/** @param {User} user */\nexport function setUserContext(user) {\n\tsetContext(key, user);\n}\n\nexport function getUserContext() {\n\treturn /** @type {User} */ (getContext(key));\n}\n```\n\n## Replacing global state\n\nWhen you have state shared by many different components, you might be tempted to put it in its own module and just import it wherever it's needed:\n\n```js\n/// file: state.svelte.js\nexport const myGlobalState = $state({\n\tuser: {\n\t\t// ...\n\t}\n\t// ...\n});\n```\n\nIn many cases this is perfectly fine, but there is a risk: if you mutate the state during server-side rendering (which is discouraged, but entirely possible!)...\n\n```svelte\n\u003C!--- file: App.svelte ---->\n\u003Cscript>\n\timport { myGlobalState } from './state.svelte.js';\n\n\tlet { data } = $props();\n\n\tif (data.user) {\n\t\tmyGlobalState.user = data.user;\n\t}\n\u003C/script>\n```\n\n...then the data may be accessible by the _next_ user. Context solves this problem because it is not shared between requests.\n","## Context API\n\nContext allows components to access values from parent components without prop-drilling through intermediate layers.\n\n**Setting context in parent:**\n```svelte\n\u003Cscript>\n\timport { setContext } from 'svelte';\n\tsetContext('my-context', 'hello from Parent.svelte');\n\u003C/script>\n```\n\n**Retrieving context in child:**\n```svelte\n\u003Cscript>\n\timport { getContext } from 'svelte';\n\tconst message = getContext('my-context');\n\u003C/script>\n\u003Ch1>{message}\u003C/h1>\n```\n\nThe key and value can be any JavaScript value.\n\n**Available functions:** `setContext`, `getContext`, `hasContext`, `getAllContexts`\n\n**Storing reactive state in context:**\n```svelte\n\u003Cscript>\n\timport { setContext } from 'svelte';\n\tlet counter = $state({ count: 0 });\n\tsetContext('counter', counter);\n\u003C/script>\n\u003Cbutton onclick={() => counter.count += 1}>increment\u003C/button>\n```\n\nWhen updating context state, mutate the object rather than reassigning it, or the reactivity link breaks.\n\n**Type-safe context pattern:**\n```js\nconst key = {};\nexport function setUserContext(user) {\n\tsetContext(key, user);\n}\nexport function getUserContext() {\n\treturn getContext(key);\n}\n```\n\n**Context vs global state:** Context is isolated per request (safe for SSR), while global module state is shared across requests and can leak data between users during server-side rendering.","## Context API\n\nAvoid prop-drilling by using `setContext(key, value)` in parent and `getContext(key)` in child components.\n\n```svelte\n// Parent\nsetContext('my-context', 'value');\n\n// Child\nconst value = getContext('my-context');\n```\n\nStore reactive state in context by mutating objects rather than reassigning them. Wrap `setContext`/`getContext` in helper functions for type safety. Context is request-isolated (safe for SSR), unlike global module state.","Context enables parent-to-child value passing without prop-drilling, with support for reactive state and type-safe patterns."],"uses":{"params":["name","path"]}}]}
