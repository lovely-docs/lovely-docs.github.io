{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-sveltekit","advanced-techniques/hooks",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","30-advanced/20-hooks.md",true,{"fulltext":8,"digest":9,"short_digest":10},4502,803,196,{"input":12,"output":13,"details":14},5543,1114,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: Hooks\n---\n\n'Hooks' are app-wide functions you declare that SvelteKit will call in response to specific events, giving you fine-grained control over the framework's behaviour.\n\nThere are three hooks files, all optional:\n\n- `src/hooks.server.js` — your app's server hooks\n- `src/hooks.client.js` — your app's client hooks\n- `src/hooks.js` — your app's hooks that run on both the client and server\n\nCode in these modules will run when the application starts up, making them useful for initializing database clients and so on.\n\n> [!NOTE] You can configure the location of these files with [`config.kit.files.hooks`](configuration#files).\n\n## Server hooks\n\nThe following hooks can be added to `src/hooks.server.js`:\n\n### handle\n\nThis function runs every time the SvelteKit server receives a [request](web-standards#Fetch-APIs-Request) — whether that happens while the app is running, or during [prerendering](page-options#prerender) — and determines the [response](web-standards#Fetch-APIs-Response). It receives an `event` object representing the request and a function called `resolve`, which renders the route and generates a `Response`. This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).\n\n```js\n/// file: src/hooks.server.js\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tif (event.url.pathname.startsWith('/custom')) {\n\t\treturn new Response('custom response');\n\t}\n\n\tconst response = await resolve(event);\n\treturn response;\n}\n```\n\n> [!NOTE] Requests for static assets — which includes pages that were already prerendered — are _not_ handled by SvelteKit.\n\nIf unimplemented, defaults to `({ event, resolve }) => resolve(event)`.\n\nDuring prerendering, SvelteKit crawls your pages for links and renders each route it finds. Rendering the route invokes the `handle` function (and all other route dependencies, like `load`). If you need to exclude some code from running during this phase, check that the app is not [`building`]($app-environment#building) beforehand.\n\n### locals\n\nTo add custom data to the request, which is passed to handlers in `+server.js` and server `load` functions, populate the `event.locals` object, as shown below.\n\n```js\n/// file: src/hooks.server.js\n// @filename: ambient.d.ts\ntype User = {\n\tname: string;\n}\n\ndeclare namespace App {\n\tinterface Locals {\n\t\tuser: User;\n\t}\n}\n\nconst getUserInformation: (cookie: string | void) => Promise\u003CUser>;\n\n// @filename: index.js\n// ---cut---\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tevent.locals.user = await getUserInformation(event.cookies.get('sessionid'));\n\n\tconst response = await resolve(event);\n\n\t// Note that modifying response headers isn't always safe.\n\t// Response objects can have immutable headers\n\t// (e.g. Response.redirect() returned from an endpoint).\n\t// Modifying immutable headers throws a TypeError.\n\t// In that case, clone the response or avoid creating a\n\t// response object with immutable headers.\n\tresponse.headers.set('x-custom-header', 'potato');\n\n\treturn response;\n}\n```\n\nYou can define multiple `handle` functions and execute them with [the `sequence` helper function](@sveltejs-kit-hooks).\n\n`resolve` also supports a second, optional parameter that gives you more control over how the response will be rendered. That parameter is an object that can have the following fields:\n\n- `transformPageChunk(opts: { html: string, done: boolean }): MaybePromise\u003Cstring | undefined>` — applies custom transforms to HTML. If `done` is true, it's the final chunk. Chunks are not guaranteed to be well-formed HTML (they could include an element's opening tag but not its closing tag, for example) but they will always be split at sensible boundaries such as `%sveltekit.head%` or layout/page components.\n- `filterSerializedResponseHeaders(name: string, value: string): boolean` — determines which headers should be included in serialized responses when a `load` function loads a resource with `fetch`. By default, none will be included.\n- `preload(input: { type: 'js' | 'css' | 'font' | 'asset', path: string }): boolean` — determines what files should be added to the `\u003Chead>` tag to preload it. The method is called with each file that was found at build time while constructing the code chunks — so if you for example have `import './styles.css` in your `+page.svelte`, `preload` will be called with the resolved path to that CSS file when visiting that page. Note that in dev mode `preload` is _not_ called, since it depends on analysis that happens at build time. Preloading can improve performance by downloading assets sooner, but it can also hurt if too much is downloaded unnecessarily. By default, `js` and `css` files will be preloaded. `asset` files are not preloaded at all currently, but we may add this later after evaluating feedback.\n\n```js\n/// file: src/hooks.server.js\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tconst response = await resolve(event, {\n\t\ttransformPageChunk: ({ html }) => html.replace('old', 'new'),\n\t\tfilterSerializedResponseHeaders: (name) => name.startsWith('x-'),\n\t\tpreload: ({ type, path }) => type === 'js' || path.includes('/important/')\n\t});\n\n\treturn response;\n}\n```\n\nNote that `resolve(...)` will never throw an error, it will always return a `Promise\u003CResponse>` with the appropriate status code. If an error is thrown elsewhere during `handle`, it is treated as fatal, and SvelteKit will respond with a JSON representation of the error or a fallback error page — which can be customised via `src/error.html` — depending on the `Accept` header. You can read more about error handling [here](errors).\n\n### handleFetch\n\nThis function allows you to modify (or replace) the result of an [`event.fetch`](load#Making-fetch-requests) call that runs on the server (or during prerendering) inside an endpoint, `load`, `action`, `handle`, `handleError` or `reroute`.\n\nFor example, your `load` function might make a request to a public URL like `https://api.yourapp.com` when the user performs a client-side navigation to the respective page, but during SSR it might make sense to hit the API directly (bypassing whatever proxies and load balancers sit between it and the public internet).\n\n```js\n/// file: src/hooks.server.js\n/** @type {import('@sveltejs/kit').HandleFetch} */\nexport async function handleFetch({ request, fetch }) {\n\tif (request.url.startsWith('https://api.yourapp.com/')) {\n\t\t// clone the original request, but change the URL\n\t\trequest = new Request(\n\t\t\trequest.url.replace('https://api.yourapp.com/', 'http://localhost:9999/'),\n\t\t\trequest\n\t\t);\n\t}\n\n\treturn fetch(request);\n}\n```\n\nRequests made with `event.fetch` follow the browser's credentials model — for same-origin requests, `cookie` and `authorization` headers are forwarded unless the `credentials` option is set to `\"omit\"`. For cross-origin requests, `cookie` will be included if the request URL belongs to a subdomain of the app — for example if your app is on `my-domain.com`, and your API is on `api.my-domain.com`, cookies will be included in the request.\n\nThere is one caveat: if your app and your API are on sibling subdomains — `www.my-domain.com` and `api.my-domain.com` for example — then a cookie belonging to a common parent domain like `my-domain.com` will _not_ be included, because SvelteKit has no way to know which domain the cookie belongs to. In these cases you will need to manually include the cookie using `handleFetch`:\n\n```js\n/// file: src/hooks.server.js\n// @errors: 2345\n/** @type {import('@sveltejs/kit').HandleFetch} */\nexport async function handleFetch({ event, request, fetch }) {\n\tif (request.url.startsWith('https://api.my-domain.com/')) {\n\t\trequest.headers.set('cookie', event.request.headers.get('cookie'));\n\t}\n\n\treturn fetch(request);\n}\n```\n\n### handleValidationError\n\nThis hook is called when a remote function is called with an argument that does not match the provided [Standard Schema](https://standardschema.dev/). It must return an object matching the shape of [`App.Error`](types#Error).\n\nSay you have a remote function that expects a string as its argument ...\n\n```js\n/// file: todos.remote.js\nimport * as v from 'valibot';\nimport { query } from '$app/server';\n\nexport const getTodo = query(v.string(), (id) => {\n\t// implementation...\n});\n```\n\n...but it is called with something that doesn't match the schema — such as a number (e.g `await getTodos(1)`) — then validation will fail, the server will respond with a [400 status code](https://http.dog/400), and the function will throw with the message 'Bad Request'.\n\nTo customise this message and add additional properties to the error object, implement `handleValidationError`:\n\n```js\n/// file: src/hooks.server.js\n/** @type {import('@sveltejs/kit').HandleValidationError} */\nexport function handleValidationError({ issues }) {\n\treturn {\n\t\tmessage: 'No thank you'\n\t};\n}\n```\n\nBe thoughtful about what information you expose here, as the most likely reason for validation to fail is that someone is sending malicious requests to your server.\n\n## Shared hooks\n\nThe following can be added to `src/hooks.server.js` _and_ `src/hooks.client.js`:\n\n### handleError\n\nIf an [unexpected error](errors#Unexpected-errors) is thrown during loading, rendering, or from an endpoint, this function will be called with the `error`, `event`, `status` code and `message`. This allows for two things:\n\n- you can log the error\n- you can generate a custom representation of the error that is safe to show to users, omitting sensitive details like messages and stack traces. The returned value, which defaults to `{ message }`, becomes the value of `$page.error`.\n\nFor errors thrown from your code (or library code called by your code) the status will be 500 and the message will be \"Internal Error\". While `error.message` may contain sensitive information that should not be exposed to users, `message` is safe (albeit meaningless to the average user).\n\nTo add more information to the `$page.error` object in a type-safe way, you can customize the expected shape by declaring an `App.Error` interface (which must include `message: string`, to guarantee sensible fallback behavior). This allows you to — for example — append a tracking ID for users to quote in correspondence with your technical support staff:\n\n```ts\n/// file: src/app.d.ts\ndeclare global {\n\tnamespace App {\n\t\tinterface Error {\n\t\t\tmessage: string;\n\t\t\terrorId: string;\n\t\t}\n\t}\n}\n\nexport {};\n```\n\n```js\n/// file: src/hooks.server.js\n// @errors: 2322 2353\n// @filename: ambient.d.ts\ndeclare module '@sentry/sveltekit' {\n\texport const init: (opts: any) => void;\n\texport const captureException: (error: any, opts: any) => void;\n}\n\n// @filename: index.js\n// ---cut---\nimport * as Sentry from '@sentry/sveltekit';\n\nSentry.init({/*...*/})\n\n/** @type {import('@sveltejs/kit').HandleServerError} */\nexport async function handleError({ error, event, status, message }) {\n\tconst errorId = crypto.randomUUID();\n\n\t// example integration with https://sentry.io/\n\tSentry.captureException(error, {\n\t\textra: { event, errorId, status }\n\t});\n\n\treturn {\n\t\tmessage: 'Whoops!',\n\t\terrorId\n\t};\n}\n```\n\n```js\n/// file: src/hooks.client.js\n// @errors: 2322 2353\n// @filename: ambient.d.ts\ndeclare module '@sentry/sveltekit' {\n\texport const init: (opts: any) => void;\n\texport const captureException: (error: any, opts: any) => void;\n}\n\n// @filename: index.js\n// ---cut---\nimport * as Sentry from '@sentry/sveltekit';\n\nSentry.init({/*...*/})\n\n/** @type {import('@sveltejs/kit').HandleClientError} */\nexport async function handleError({ error, event, status, message }) {\n\tconst errorId = crypto.randomUUID();\n\n\t// example integration with https://sentry.io/\n\tSentry.captureException(error, {\n\t\textra: { event, errorId, status }\n\t});\n\n\treturn {\n\t\tmessage: 'Whoops!',\n\t\terrorId\n\t};\n}\n```\n\n> [!NOTE] In `src/hooks.client.js`, the type of `handleError` is `HandleClientError` instead of `HandleServerError`, and `event` is a `NavigationEvent` rather than a `RequestEvent`.\n\nThis function is not called for _expected_ errors (those thrown with the [`error`](@sveltejs-kit#error) function imported from `@sveltejs/kit`).\n\nDuring development, if an error occurs because of a syntax error in your Svelte code, the passed in error has a `frame` property appended highlighting the location of the error.\n\n> [!NOTE] Make sure that `handleError` _never_ throws an error\n\n### init\n\nThis function runs once, when the server is created or the app starts in the browser, and is a useful place to do asynchronous work such as initializing a database connection.\n\n> [!NOTE] If your environment supports top-level await, the `init` function is really no different from writing your initialisation logic at the top level of the module, but some environments — most notably, Safari — don't.\n\n```js\n// @errors: 2307\n/// file: src/hooks.server.js\nimport * as db from '$lib/server/database';\n\n/** @type {import('@sveltejs/kit').ServerInit} */\nexport async function init() {\n\tawait db.connect();\n}\n```\n\n> [!NOTE]\n> In the browser, asynchronous work in `init` will delay hydration, so be mindful of what you put in there.\n\n## Universal hooks\n\nThe following can be added to `src/hooks.js`. Universal hooks run on both server and client (not to be confused with shared hooks, which are environment-specific).\n\n### reroute\n\nThis function runs before `handle` and allows you to change how URLs are translated into routes. The returned pathname (which defaults to `url.pathname`) is used to select the route and its parameters.\n\nFor example, you might have a `src/routes/[[lang]]/about/+page.svelte` page, which should be accessible as `/en/about` or `/de/ueber-uns` or `/fr/a-propos`. You could implement this with `reroute`:\n\n```js\n// @errors: 2345 2304\n/// file: src/hooks.js\n\n/** @type {Record\u003Cstring, string>} */\nconst translated = {\n\t'/en/about': '/en/about',\n\t'/de/ueber-uns': '/de/about',\n\t'/fr/a-propos': '/fr/about',\n};\n\n/** @type {import('@sveltejs/kit').Reroute} */\nexport function reroute({ url }) {\n\tif (url.pathname in translated) {\n\t\treturn translated[url.pathname];\n\t}\n}\n```\n\nThe `lang` parameter will be correctly derived from the returned pathname.\n\nUsing `reroute` will _not_ change the contents of the browser's address bar, or the value of `event.url`.\n\nSince version 2.18, the `reroute` hook can be asynchronous, allowing it to (for example) fetch data from your backend to decide where to reroute to. Use this carefully and make sure it's fast, as it will delay navigation otherwise. If you need to fetch data, use the `fetch` provided as an argument. It has the [same benefits](load#Making-fetch-requests) as the `fetch` provided to `load` functions, with the caveat that `params` and `id` are unavailable to [`handleFetch`](#Server-hooks-handleFetch) because the route is not yet known.\n\n```js\n// @errors: 2345 2304\n/// file: src/hooks.js\n\n/** @type {import('@sveltejs/kit').Reroute} */\nexport async function reroute({ url, fetch }) {\n\t// Ask a special endpoint within your app about the destination\n\tif (url.pathname === '/api/reroute') return;\n\n\tconst api = new URL('/api/reroute', url);\n\tapi.searchParams.set('pathname', url.pathname);\n\n\tconst result = await fetch(api).then(r => r.json());\n\treturn result.pathname;\n}\n```\n\n\n> [!NOTE] `reroute` is considered a pure, idempotent function. As such, it must always return the same output for the same input and not have side effects. Under these assumptions, SvelteKit caches the result of `reroute` on the client so it is only called once per unique URL.\n\n### transport\n\nThis is a collection of _transporters_, which allow you to pass custom types — returned from `load` and form actions — across the server/client boundary. Each transporter contains an `encode` function, which encodes values on the server (or returns a falsy value for anything that isn't an instance of the type) and a corresponding `decode` function:\n\n```js\n// @errors: 2307\n/// file: src/hooks.js\nimport { Vector } from '$lib/math';\n\n/** @type {import('@sveltejs/kit').Transport} */\nexport const transport = {\n\tVector: {\n\t\tencode: (value) => value instanceof Vector && [value.x, value.y],\n\t\tdecode: ([x, y]) => new Vector(x, y)\n\t}\n};\n```\n\n\n## Further reading\n\n- [Tutorial: Hooks](/tutorial/kit/handle)\n","## Server Hooks\n\n**handle** — Runs on every request (including prerendering). Receives `event` and `resolve` function. Allows modifying response headers/bodies or bypassing SvelteKit entirely.\n\n```js\nexport async function handle({ event, resolve }) {\n\tif (event.url.pathname.startsWith('/custom')) {\n\t\treturn new Response('custom response');\n\t}\n\tconst response = await resolve(event);\n\tresponse.headers.set('x-custom-header', 'value');\n\treturn response;\n}\n```\n\n`resolve` accepts optional second parameter with:\n- `transformPageChunk(opts)` — Transform HTML chunks\n- `filterSerializedResponseHeaders(name, value)` — Control which headers serialize in `load` fetch responses\n- `preload(input)` — Determine which files preload in `\u003Chead>`\n\n**handleFetch** — Modifies/replaces `event.fetch` calls on server or during prerendering. Useful for redirecting API calls to localhost during SSR or manually forwarding cookies for sibling subdomains.\n\n```js\nexport async function handleFetch({ request, fetch }) {\n\tif (request.url.startsWith('https://api.yourapp.com/')) {\n\t\trequest = new Request(\n\t\t\trequest.url.replace('https://api.yourapp.com/', 'http://localhost:9999/'),\n\t\t\trequest\n\t\t);\n\t}\n\treturn fetch(request);\n}\n```\n\n**handleValidationError** — Called when remote function receives invalid argument against Standard Schema. Must return object matching `App.Error` shape.\n\n## Shared Hooks (server and client)\n\n**handleError** — Called for unexpected errors during loading, rendering, or endpoints. Receives `error`, `event`, `status`, `message`. Allows logging and returning safe error representation for `$page.error`. Customize error shape via `App.Error` interface.\n\n```js\nexport async function handleError({ error, event, status, message }) {\n\tconst errorId = crypto.randomUUID();\n\tSentry.captureException(error, { extra: { event, errorId, status } });\n\treturn { message: 'Whoops!', errorId };\n}\n```\n\n**init** — Runs once when server starts or app loads in browser. Useful for async initialization like database connections. Note: async work delays browser hydration.\n\n## Universal Hooks (src/hooks.js)\n\n**reroute** — Runs before `handle`. Changes URL-to-route translation by returning modified pathname. Can be async (since v2.18) to fetch data for routing decisions.\n\n```js\nconst translated = {\n\t'/de/ueber-uns': '/de/about',\n\t'/fr/a-propos': '/fr/about',\n};\nexport function reroute({ url }) {\n\treturn translated[url.pathname];\n}\n```\n\n**transport** — Collection of transporters for passing custom types across server/client boundary. Each has `encode` (server) and `decode` (client) functions.\n\n```js\nexport const transport = {\n\tVector: {\n\t\tencode: (value) => value instanceof Vector && [value.x, value.y],\n\t\tdecode: ([x, y]) => new Vector(x, y)\n\t}\n};\n```\n\nFiles: `src/hooks.server.js`, `src/hooks.client.js`, `src/hooks.js` (all optional).","## Server Hooks\n\n**handle** — Intercepts every request. Modify response or bypass SvelteKit. Supports `transformPageChunk`, `filterSerializedResponseHeaders`, `preload` options.\n\n**handleFetch** — Intercepts `event.fetch` calls. Redirect API URLs or forward cookies.\n\n**handleValidationError** — Customize validation error responses.\n\n## Shared Hooks\n\n**handleError** — Log errors and return safe representation for `$page.error`.\n\n**init** — Async initialization on startup.\n\n## Universal Hooks\n\n**reroute** — Translate URLs to routes (can be async).\n\n**transport** — Encode/decode custom types across server/client boundary.\n\nFiles: `src/hooks.server.js`, `src/hooks.client.js`, `src/hooks.js`","App-wide functions that hook into SvelteKit lifecycle events for request handling, error management, routing, and type serialization."],"uses":{"params":["name","path"]}}]}
