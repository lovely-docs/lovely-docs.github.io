{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-sveltekit","advanced-techniques/service-workers",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","30-advanced/40-service-workers.md",true,{"fulltext":8,"digest":9,"short_digest":10},1543,587,101,{"input":12,"output":13,"details":14},2586,793,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: Service workers\n---\n\nService workers act as proxy servers that handle network requests inside your app. This makes it possible to make your app work offline, but even if you don't need offline support (or can't realistically implement it because of the type of app you're building), it's often worth using service workers to speed up navigation by precaching your built JS and CSS.\n\nIn SvelteKit, if you have a `src/service-worker.js` file (or `src/service-worker/index.js`) it will be bundled and automatically registered. You can change the [location of your service worker](configuration#files) if you need to.\n\nYou can [disable automatic registration](configuration#serviceWorker) if you need to register the service worker with your own logic or use another solution. The default registration looks something like this:\n\n```js\nif ('serviceWorker' in navigator) {\n\taddEventListener('load', function () {\n\t\tnavigator.serviceWorker.register('./path/to/service-worker.js');\n\t});\n}\n```\n\n## Inside the service worker\n\nInside the service worker you have access to the [`$service-worker` module]($service-worker), which provides you with the paths to all static assets, build files and prerendered pages. You're also provided with an app version string, which you can use for creating a unique cache name, and the deployment's `base` path. If your Vite config specifies `define` (used for global variable replacements), this will be applied to service workers as well as your server/client builds.\n\nThe following example caches the built app and any files in `static` eagerly, and caches all other requests as they happen. This would make each page work offline once visited.\n\n```js\n/// file: src/service-worker.js\n// Disables access to DOM typings like `HTMLElement` which are not available\n// inside a service worker and instantiates the correct globals\n/// \u003Creference no-default-lib=\"true\"/>\n/// \u003Creference lib=\"esnext\" />\n/// \u003Creference lib=\"webworker\" />\n\n// Ensures that the `$service-worker` import has proper type definitions\n/// \u003Creference types=\"@sveltejs/kit\" />\n\n// Only necessary if you have an import from `$env/static/public`\n/// \u003Creference types=\"../.svelte-kit/ambient.d.ts\" />\n\nimport { build, files, version } from '$service-worker';\n\n// This gives `self` the correct types\nconst self = /** @type {ServiceWorkerGlobalScope} */ (/** @type {unknown} */ (globalThis.self));\n\n// Create a unique cache name for this deployment\nconst CACHE = `cache-${version}`;\n\nconst ASSETS = [\n\t...build, // the app itself\n\t...files  // everything in `static`\n];\n\nself.addEventListener('install', (event) => {\n\t// Create a new cache and add all files to it\n\tasync function addFilesToCache() {\n\t\tconst cache = await caches.open(CACHE);\n\t\tawait cache.addAll(ASSETS);\n\t}\n\n\tevent.waitUntil(addFilesToCache());\n});\n\nself.addEventListener('activate', (event) => {\n\t// Remove previous cached data from disk\n\tasync function deleteOldCaches() {\n\t\tfor (const key of await caches.keys()) {\n\t\t\tif (key !== CACHE) await caches.delete(key);\n\t\t}\n\t}\n\n\tevent.waitUntil(deleteOldCaches());\n});\n\nself.addEventListener('fetch', (event) => {\n\t// ignore POST requests etc\n\tif (event.request.method !== 'GET') return;\n\n\tasync function respond() {\n\t\tconst url = new URL(event.request.url);\n\t\tconst cache = await caches.open(CACHE);\n\n\t\t// `build`/`files` can always be served from the cache\n\t\tif (ASSETS.includes(url.pathname)) {\n\t\t\tconst response = await cache.match(url.pathname);\n\n\t\t\tif (response) {\n\t\t\t\treturn response;\n\t\t\t}\n\t\t}\n\n\t\t// for everything else, try the network first, but\n\t\t// fall back to the cache if we're offline\n\t\ttry {\n\t\t\tconst response = await fetch(event.request);\n\n\t\t\t// if we're offline, fetch can return a value that is not a Response\n\t\t\t// instead of throwing - and we can't pass this non-Response to respondWith\n\t\t\tif (!(response instanceof Response)) {\n\t\t\t\tthrow new Error('invalid response from fetch');\n\t\t\t}\n\n\t\t\tif (response.status === 200) {\n\t\t\t\tcache.put(event.request, response.clone());\n\t\t\t}\n\n\t\t\treturn response;\n\t\t} catch (err) {\n\t\t\tconst response = await cache.match(event.request);\n\n\t\t\tif (response) {\n\t\t\t\treturn response;\n\t\t\t}\n\n\t\t\t// if there's no cache, then just error out\n\t\t\t// as there is nothing we can do to respond to this request\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tevent.respondWith(respond());\n});\n```\n\n> [!NOTE] Be careful when caching! In some cases, stale data might be worse than data that's unavailable while offline. Since browsers will empty caches if they get too full, you should also be careful about caching large assets like video files.\n\n## During development\n\nThe service worker is bundled for production, but not during development. For that reason, only browsers that support [modules in service workers](https://web.dev/es-modules-in-sw) will be able to use them at dev time. If you are manually registering your service worker, you will need to pass the `{ type: 'module' }` option in development:\n\n```js\nimport { dev } from '$app/environment';\n\nnavigator.serviceWorker.register('/service-worker.js', {\n\ttype: dev ? 'module' : 'classic'\n});\n```\n\n> [!NOTE] `build` and `prerendered` are empty arrays during development\n\n## Other solutions\n\nSvelteKit's service worker implementation is designed to be easy to work with and is probably a good solution for most users. However, outside of SvelteKit, many PWA applications leverage the [Workbox](https://web.dev/learn/pwa/workbox) library. If you're used to using Workbox you may prefer [Vite PWA plugin](https://vite-pwa-org.netlify.app/frameworks/sveltekit.html).\n\n## References\n\nFor more general information on service workers, we recommend [the MDN web docs](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers).\n","Service workers act as proxy servers for network requests, enabling offline support and performance optimization through precaching. SvelteKit automatically bundles and registers a service worker if `src/service-worker.js` (or `src/service-worker/index.js`) exists.\n\nInside the service worker, access the `$service-worker` module to get paths to static assets, build files, prerendered pages, app version, and base path. Use the version string to create unique cache names.\n\nExample service worker implementation:\n```js\n/// \u003Creference no-default-lib=\"true\"/>\n/// \u003Creference lib=\"esnext\" />\n/// \u003Creference lib=\"webworker\" />\n/// \u003Creference types=\"@sveltejs/kit\" />\n\nimport { build, files, version } from '$service-worker';\nconst self = /** @type {ServiceWorkerGlobalScope} */ (globalThis.self);\nconst CACHE = `cache-${version}`;\nconst ASSETS = [...build, ...files];\n\nself.addEventListener('install', (event) => {\n\tevent.waitUntil((async () => {\n\t\tconst cache = await caches.open(CACHE);\n\t\tawait cache.addAll(ASSETS);\n\t})());\n});\n\nself.addEventListener('activate', (event) => {\n\tevent.waitUntil((async () => {\n\t\tfor (const key of await caches.keys()) {\n\t\t\tif (key !== CACHE) await caches.delete(key);\n\t\t}\n\t})());\n});\n\nself.addEventListener('fetch', (event) => {\n\tif (event.request.method !== 'GET') return;\n\tevent.respondWith((async () => {\n\t\tconst url = new URL(event.request.url);\n\t\tconst cache = await caches.open(CACHE);\n\t\tif (ASSETS.includes(url.pathname)) {\n\t\t\treturn await cache.match(url.pathname);\n\t\t}\n\t\ttry {\n\t\t\tconst response = await fetch(event.request);\n\t\t\tif (response instanceof Response && response.status === 200) {\n\t\t\t\tcache.put(event.request, response.clone());\n\t\t\t}\n\t\t\treturn response;\n\t\t} catch {\n\t\t\treturn await cache.match(event.request);\n\t\t}\n\t})());\n});\n```\n\nDisable automatic registration via configuration if you need custom logic. During development, only browsers supporting ES modules in service workers work; manually register with `{ type: dev ? 'module' : 'classic' }`. Vite PWA plugin and Workbox are alternative solutions.","SvelteKit automatically registers `src/service-worker.js` for offline support and performance. Access `$service-worker` module for build files, static assets, version, and base path. Implement install/activate/fetch handlers to cache assets and handle offline requests. Use version string for unique cache names. Disable auto-registration via config if needed. In dev, use `{ type: 'module' }` for manual registration.","How to implement and configure service workers in SvelteKit for offline support and performance optimization."],"uses":{"params":["name","path"]}}]}
