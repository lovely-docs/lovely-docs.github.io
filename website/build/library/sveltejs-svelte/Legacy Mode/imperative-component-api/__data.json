{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","Legacy Mode/imperative-component-api",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","99-legacy/40-legacy-component-api.md",true,{"fulltext":8,"digest":9,"short_digest":10},1716,461,190,{"input":12,"output":13,"details":14},2757,770,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: Imperative component API\n---\n\nIn Svelte 3 and 4, the API for interacting with a component is different than in Svelte 5. Note that this page does _not_ apply to legacy mode components in a Svelte 5 application.\n\n## Creating a component\n\n```ts\n// @noErrors\nconst component = new Component(options);\n```\n\nA client-side component — that is, a component compiled with `generate: 'dom'` (or the `generate` option left unspecified) is a JavaScript class.\n\n```ts\n// @noErrors\nimport App from './App.svelte';\n\nconst app = new App({\n\ttarget: document.body,\n\tprops: {\n\t\t// assuming App.svelte contains something like\n\t\t// `export let answer`:\n\t\tanswer: 42\n\t}\n});\n```\n\nThe following initialisation options can be provided:\n\n| option    | default     | description                                                                                          |\n| --------- | ----------- | ---------------------------------------------------------------------------------------------------- |\n| `target`  | **none**    | An `HTMLElement` or `ShadowRoot` to render to. This option is required                               |\n| `anchor`  | `null`      | A child of `target` to render the component immediately before                                       |\n| `props`   | `{}`        | An object of properties to supply to the component                                                   |\n| `context` | `new Map()` | A `Map` of root-level context key-value pairs to supply to the component                             |\n| `hydrate` | `false`     | See below                                                                                            |\n| `intro`   | `false`     | If `true`, will play transitions on initial render, rather than waiting for subsequent state changes |\n\nExisting children of `target` are left where they are.\n\nThe `hydrate` option instructs Svelte to upgrade existing DOM (usually from server-side rendering) rather than creating new elements. It will only work if the component was compiled with the [`hydratable: true` option](/docs/svelte-compiler#compile). Hydration of `\u003Chead>` elements only works properly if the server-side rendering code was also compiled with `hydratable: true`, which adds a marker to each element in the `\u003Chead>` so that the component knows which elements it's responsible for removing during hydration.\n\nWhereas children of `target` are normally left alone, `hydrate: true` will cause any children to be removed. For that reason, the `anchor` option cannot be used alongside `hydrate: true`.\n\nThe existing DOM doesn't need to match the component — Svelte will 'repair' the DOM as it goes.\n\n```ts\n/// file: index.js\n// @noErrors\nimport App from './App.svelte';\n\nconst app = new App({\n\ttarget: document.querySelector('#server-rendered-html'),\n\thydrate: true\n});\n```\n\n> [!NOTE]\n> In Svelte 5+, use [`mount`](svelte#mount) instead\n\n## `$set`\n\n```ts\n// @noErrors\ncomponent.$set(props);\n```\n\nProgrammatically sets props on an instance. `component.$set({ x: 1 })` is equivalent to `x = 1` inside the component's `\u003Cscript>` block.\n\nCalling this method schedules an update for the next microtask — the DOM is _not_ updated synchronously.\n\n```ts\n// @noErrors\ncomponent.$set({ answer: 42 });\n```\n\n> [!NOTE]\n> In Svelte 5+, use `$state` instead to create a component props and update that\n>\n> ```js\n> // @noErrors\n> let props = $state({ answer: 42 });\n> const component = mount(Component, { props });\n> // ...\n> props.answer = 24;\n> ```\n\n## `$on`\n\n```ts\n// @noErrors\ncomponent.$on(ev, callback);\n```\n\nCauses the `callback` function to be called whenever the component dispatches an `event`.\n\nA function is returned that will remove the event listener when called.\n\n```ts\n// @noErrors\nconst off = component.$on('selected', (event) => {\n\tconsole.log(event.detail.selection);\n});\n\noff();\n```\n\n> [!NOTE]\n> In Svelte 5+, pass callback props instead\n\n## `$destroy`\n\n```js\n// @noErrors\ncomponent.$destroy();\n```\n\nRemoves a component from the DOM and triggers any `onDestroy` handlers.\n\n> [!NOTE]\n> In Svelte 5+, use [`unmount`](svelte#unmount) instead\n\n## Component props\n\n```js\n// @noErrors\ncomponent.prop;\n```\n\n```js\n// @noErrors\ncomponent.prop = value;\n```\n\nIf a component is compiled with `accessors: true`, each instance will have getters and setters corresponding to each of the component's props. Setting a value will cause a _synchronous_ update, rather than the default async update caused by `component.$set(...)`.\n\nBy default, `accessors` is `false`, unless you're compiling as a custom element.\n\n```js\n// @noErrors\nconsole.log(component.count);\ncomponent.count += 1;\n```\n\n> [!NOTE]\n> In Svelte 5+, this concept is obsolete. If you want to make properties accessible from the outside, `export` them\n\n## Server-side component API\n\n```js\n// @noErrors\nconst result = Component.render(...)\n```\n\nUnlike client-side components, server-side components don't have a lifespan after you render them — their whole job is to create some HTML and CSS. For that reason, the API is somewhat different.\n\nA server-side component exposes a `render` method that can be called with optional props. It returns an object with `head`, `html`, and `css` properties, where `head` contains the contents of any `\u003Csvelte:head>` elements encountered.\n\nYou can import a Svelte component directly into Node using `svelte/register`.\n\n```js\n// @noErrors\nrequire('svelte/register');\n\nconst App = require('./App.svelte').default;\n\nconst { head, html, css } = App.render({\n\tanswer: 42\n});\n```\n\nThe `.render()` method accepts the following parameters:\n\n| parameter | default | description                                        |\n| --------- | ------- | -------------------------------------------------- |\n| `props`   | `{}`    | An object of properties to supply to the component |\n| `options` | `{}`    | An object of options                               |\n\nThe `options` object takes in the following options:\n\n| option    | default     | description                                                              |\n| --------- | ----------- | ------------------------------------------------------------------------ |\n| `context` | `new Map()` | A `Map` of root-level context key-value pairs to supply to the component |\n\n```js\n// @noErrors\nconst { head, html, css } = App.render(\n\t// props\n\t{ answer: 42 },\n\t// options\n\t{\n\t\tcontext: new Map([['context-key', 'context-value']])\n\t}\n);\n```\n\n> [!NOTE]\n> In Svelte 5+, use [`render`](svelte-server#render) instead\n","## Creating a Component\n\nClient-side components are JavaScript classes instantiated with options:\n\n```ts\nimport App from './App.svelte';\nconst app = new App({\n\ttarget: document.body,\n\tprops: { answer: 42 },\n\tcontext: new Map(),\n\thydrate: false,\n\tintro: false,\n\tanchor: null\n});\n```\n\n- `target`: HTMLElement or ShadowRoot (required)\n- `anchor`: child of target to render before\n- `props`: object of properties\n- `context`: Map of root-level context pairs\n- `hydrate`: upgrade existing DOM from server-side rendering (requires `hydratable: true` compiler option)\n- `intro`: play transitions on initial render\n\n## Instance Methods\n\n**`$set(props)`** - Programmatically update props (schedules async update):\n```ts\ncomponent.$set({ answer: 42 });\n```\n\n**`$on(event, callback)`** - Listen to component events, returns unsubscribe function:\n```ts\nconst off = component.$on('selected', (event) => {\n\tconsole.log(event.detail.selection);\n});\noff();\n```\n\n**`$destroy()`** - Remove component from DOM and trigger onDestroy handlers\n\n## Component Props\n\nIf compiled with `accessors: true`, props have getters/setters for synchronous updates:\n```ts\nconsole.log(component.count);\ncomponent.count += 1;\n```\n\n## Server-side Components\n\nServer-side components expose a `render()` method returning `{ head, html, css }`:\n```ts\nconst { head, html, css } = App.render(\n\t{ answer: 42 },\n\t{ context: new Map([['key', 'value']]) }\n);\n```\n\n**Note:** This is the Svelte 3/4 API. Svelte 5+ uses `mount()`, `unmount()`, `$state`, and callback props instead.","## Creating Components\n\n```ts\nconst app = new App({\n\ttarget: document.body,\n\tprops: { answer: 42 },\n\thydrate: false,\n\tintro: false\n});\n```\n\n## Instance Methods\n\n- `$set(props)` - update props (async)\n- `$on(event, callback)` - listen to events\n- `$destroy()` - cleanup\n\n## Props with Accessors\n\nWith `accessors: true`, props are synchronously settable:\n```ts\ncomponent.count += 1;\n```\n\n## Server-side Rendering\n\n```ts\nconst { head, html, css } = App.render({ answer: 42 });\n```\n\n**Note:** Svelte 5+ uses different APIs (`mount`, `unmount`, `$state`).","Svelte 3/4 imperative API for instantiating components, updating props, listening to events, and server-side rendering."],"uses":{"params":["name","path"]}}]}
