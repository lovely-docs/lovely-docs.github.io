{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","Runes",{"type":4,"path":5,"relevant":6,"token_counts":-1,"usage":7,"markdown":11},"directory","02-runes",true,{"input":8,"output":9,"details":10},2531,996,null,{"digest":12,"short_digest":13,"essence":14},"## What are Runes\n\n`$`-prefixed compiler keywords in Svelte that control the compiler. Unlike functions, they cannot be imported, assigned, or passed as arguments, and are only valid in specific positions.\n\n## $state\n\nCreate reactive state with `$state(value)`. Arrays and plain objects become deeply reactive proxies:\n```js\nlet count = $state(0);\nlet todos = $state([{ done: false, text: 'add more todos' }]);\ntodos[0].done = !todos[0].done; // triggers update\n```\n\nUse `$state.raw` for non-reactive state. Use `$state.snapshot` to get a plain object from a proxy. Avoid destructuring as it breaks reactivity. Export state via object mutations or functions instead of direct export.\n\n## $derived\n\nDerived state automatically updates when dependencies change:\n```svelte\nlet count = $state(0);\nlet doubled = $derived(count * 2);\n```\n\nUse `$derived.by(() => { ... })` for complex logic. Expressions must be side-effect free. Uses push-pull reactivity: dependents notified immediately, but derived values only re-evaluate when read.\n\n## $effect\n\nEffects run for side effects when state updates. They automatically track reactive values ($state, $derived, $props) read synchronously and re-run when dependencies change:\n```svelte\n$effect(() => {\n\tconst interval = setInterval(() => count += 1, ms);\n\treturn () => clearInterval(interval);\n});\n```\n\nOnly reruns when objects change, not properties inside. Asynchronously read values aren't tracked. Use `$effect.pre` for pre-DOM effects, `$effect.root()` for manual control.\n\n## $props\n\nReceive component props with destructuring, defaults, renaming, and rest syntax:\n```svelte\nlet { adjective = 'happy', super: trouper, a, b, ...others } = $props();\n```\n\n## $bindable\n\nEnables two-way data binding. Mark props with `$bindable()` to allow children to mutate state:\n```svelte\n// Child\nlet { value = $bindable() } = $props();\n// Parent\n\u003CChild bind:value={message} />\n```\n\n## $inspect\n\nDevelopment-only reactive logging:\n```svelte\n$inspect(count, message);\n$inspect(count).with((type, value) => { /* custom handler */ });\n$inspect.trace(); // traces which reactive state caused re-run\n```\n\n## $host\n\nAccess the host element in custom element components:\n```svelte\n$host().dispatchEvent(new CustomEvent(type));\n```","## Core Runes\n\n`$state(value)` - Reactive state, arrays/objects are deeply reactive proxies\n```js\nlet count = $state(0);\n```\n\n`$derived(expr)` / `$derived.by(() => {})` - Computed values that auto-update\n```svelte\nlet doubled = $derived(count * 2);\n```\n\n`$effect(() => {})` - Side effects that auto-track and re-run on dependency change, supports teardown\n```svelte\n$effect(() => {\n\tconst id = setInterval(() => count++, ms);\n\treturn () => clearInterval(id);\n});\n```\n\n`$props()` - Receive component inputs with destructuring\n```svelte\nlet { adjective = 'happy', ...rest } = $props();\n```\n\n`$bindable()` - Enable two-way binding on props for child mutations\n```svelte\nlet { value = $bindable() } = $props();\n```\n\n`$inspect(value)` - Development-only reactive logging with `.with()` handlers\n`$host()` - Access host element in custom elements","Svelte runes are $-prefixed compiler keywords for managing reactive state, derived values, side effects, and component communication."],"uses":{"params":["name","path"]}}]}
