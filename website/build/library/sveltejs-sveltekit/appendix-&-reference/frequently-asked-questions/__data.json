{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-sveltekit","appendix-&-reference/frequently-asked-questions",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","60-appendix/10-faq.md",true,{"fulltext":8,"digest":9,"short_digest":10},2741,880,349,{"input":12,"output":13,"details":14},3784,1350,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: Frequently asked questions\n---\n\n## Other resources\n\nPlease see [the Svelte FAQ](../svelte/faq) and [`vite-plugin-svelte` FAQ](https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/faq.md) as well for the answers to questions deriving from those libraries.\n\n## What can I make with SvelteKit?\n\nSee [the documentation regarding project types](project-types) for more details.\n\n## How do I include details from package.json in my application?\n\nIf you'd like to include your application's version number or other information from `package.json` in your application, you can load JSON like so:\n\n```ts\n// @errors: 2732\n/// file: svelte.config.js\nimport pkg from './package.json' with { type: 'json' };\n```\n\n## How do I fix the error I'm getting trying to include a package?\n\nMost issues related to including a library are due to incorrect packaging. You can check if a library's packaging is compatible with Node.js by entering it into [the publint website](https://publint.dev/).\n\nHere are a few things to keep in mind when checking if a library is packaged correctly:\n\n- `exports` takes precedence over the other entry point fields such as `main` and `module`. Adding an `exports` field may not be backwards-compatible as it prevents deep imports.\n- ESM files should end with `.mjs` unless `\"type\": \"module\"` is set in which any case CommonJS files should end with `.cjs`.\n- `main` should be defined if `exports` is not. It should be either a CommonJS or ESM file and adhere to the previous bullet. If a `module` field is defined, it should refer to an ESM file.\n- Svelte components should be distributed as uncompiled `.svelte` files with any JS in the package written as ESM only. Custom script and style languages, like TypeScript and SCSS, should be preprocessed as vanilla JS and CSS respectively. We recommend using [`svelte-package`](./packaging) for packaging Svelte libraries, which will do this for you.\n\nLibraries work best in the browser with Vite when they distribute an ESM version, especially if they are dependencies of a Svelte component library. You may wish to suggest to library authors that they provide an ESM version. However, CommonJS (CJS) dependencies should work as well since, by default, [`vite-plugin-svelte` will ask Vite to pre-bundle them](https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/faq.md#what-is-going-on-with-vite-and-pre-bundling-dependencies) using `esbuild` to convert them to ESM.\n\nIf you are still encountering issues we recommend searching both [the Vite issue tracker](https://github.com/vitejs/vite/issues) and the issue tracker of the library in question. Sometimes issues can be worked around by fiddling with the [`optimizeDeps`](https://vitejs.dev/config/#dep-optimization-options) or [`ssr`](https://vitejs.dev/config/#ssr-options) config values though we recommend this as only a short-term workaround in favor of fixing the library in question.\n\n## How do I use the view transitions API?\n\nWhile SvelteKit does not have any specific integration with [view transitions](https://developer.chrome.com/docs/web-platform/view-transitions/), you can call `document.startViewTransition` in [`onNavigate`]($app-navigation#onNavigate) to trigger a view transition on every client-side navigation.\n\n```js\n// @errors: 2339 2810\nimport { onNavigate } from '$app/navigation';\n\nonNavigate((navigation) => {\n\tif (!document.startViewTransition) return;\n\n\treturn new Promise((resolve) => {\n\t\tdocument.startViewTransition(async () => {\n\t\t\tresolve();\n\t\t\tawait navigation.complete;\n\t\t});\n\t});\n});\n```\n\nFor more, see [\"Unlocking view transitions\"](/blog/view-transitions) on the Svelte blog.\n\n## How do I set up a database?\n\nPut the code to query your database in a [server route](./routing#server) - don't query the database in .svelte files. You can create a `db.js` or similar that sets up a connection immediately and makes the client accessible throughout the app as a singleton. You can execute any one-time setup code in `hooks.server.js` and import your database helpers into any endpoint that needs them.\n\nYou can use [the Svelte CLI](/docs/cli/overview) to automatically set up database integrations.\n\n## How do I use a client-side library accessing `document` or `window`?\n\nIf you need access to the `document` or `window` variables or otherwise need code to run only on the client-side you can wrap it in a `browser` check:\n\n```js\n/// \u003Creference types=\"@sveltejs/kit\" />\n// ---cut---\nimport { browser } from '$app/environment';\n\nif (browser) {\n\t// client-only code here\n}\n```\n\nYou can also run code in `onMount` if you'd like to run it after the component has been first rendered to the DOM:\n\n```js\n// @filename: ambient.d.ts\n// @lib: ES2015\ndeclare module 'some-browser-only-library';\n\n// @filename: index.js\n// ---cut---\nimport { onMount } from 'svelte';\n\nonMount(async () => {\n\tconst { method } = await import('some-browser-only-library');\n\tmethod('hello world');\n});\n```\n\nIf the library you'd like to use is side-effect free you can also statically import it and it will be tree-shaken out in the server-side build where `onMount` will be automatically replaced with a no-op:\n\n```js\n// @filename: ambient.d.ts\n// @lib: ES2015\ndeclare module 'some-browser-only-library';\n\n// @filename: index.js\n// ---cut---\nimport { onMount } from 'svelte';\nimport { method } from 'some-browser-only-library';\n\nonMount(() => {\n\tmethod('hello world');\n});\n```\n\nFinally, you may also consider using an `{#await}` block:\n```svelte\n\u003C!--- file: index.svelte --->\n\u003Cscript>\n\timport { browser } from '$app/environment';\n\n\tconst ComponentConstructor = browser ?\n\t\timport('some-browser-only-library').then((module) => module.Component) :\n\t\tnew Promise(() => {});\n\u003C/script>\n\n{#await ComponentConstructor}\n\t\u003Cp>Loading...\u003C/p>\n{:then component}\n\t\u003Csvelte:component this={component} />\n{:catch error}\n\t\u003Cp>Something went wrong: {error.message}\u003C/p>\n{/await}\n```\n\n## How do I use a different backend API server?\n\nYou can use [`event.fetch`](./load#Making-fetch-requests) to request data from an external API server, but be aware that you would need to deal with [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS), which will result in complications such as generally requiring requests to be preflighted resulting in higher latency. Requests to a separate subdomain may also increase latency due to an additional DNS lookup, TLS setup, etc. If you wish to use this method, you may find [`handleFetch`](./hooks#Server-hooks-handleFetch) helpful.\n\nAnother approach is to set up a proxy to bypass CORS headaches. In production, you would rewrite a path like `/api` to the API server; for local development, use Vite's [`server.proxy`](https://vitejs.dev/config/server-options.html#server-proxy) option.\n\nHow to setup rewrites in production will depend on your deployment platform. If rewrites aren't an option, you could alternatively add an [API route](./routing#server):\n\n```js\n/// file: src/routes/api/[...path]/+server.js\n/** @type {import('./$types').RequestHandler} */\nexport function GET({ params, url }) {\n\treturn fetch(`https://example.com/${params.path + url.search}`);\n}\n```\n\n(Note that you may also need to proxy `POST`/`PATCH` etc requests, and forward `request.headers`, depending on your needs.)\n\n## How do I use middleware?\n\n`adapter-node` builds a middleware that you can use with your own server for production mode. In dev, you can add middleware to Vite by using a Vite plugin. For example:\n\n```js\n// @errors: 2322\n// @filename: ambient.d.ts\ndeclare module '@sveltejs/kit/vite'; // TODO this feels unnecessary, why can't it 'see' the declarations?\n\n// @filename: index.js\n// ---cut---\nimport { sveltekit } from '@sveltejs/kit/vite';\n\n/** @type {import('vite').Plugin} */\nconst myPlugin = {\n\tname: 'log-request-middleware',\n\tconfigureServer(server) {\n\t\tserver.middlewares.use((req, res, next) => {\n\t\t\tconsole.log(`Got request ${req.url}`);\n\t\t\tnext();\n\t\t});\n\t}\n};\n\n/** @type {import('vite').UserConfig} */\nconst config = {\n\tplugins: [myPlugin, sveltekit()]\n};\n\nexport default config;\n```\n\nSee [Vite's `configureServer` docs](https://vitejs.dev/guide/api-plugin.html#configureserver) for more details including how to control ordering.\n\n## How do I use Yarn?\n\n### Does it work with Yarn 2?\n\nSort of. The Plug'n'Play feature, aka 'pnp', is broken (it deviates from the Node module resolution algorithm, and [doesn't yet work with native JavaScript modules](https://github.com/yarnpkg/berry/issues/638) which SvelteKit — along with an [increasing number of packages](https://blog.sindresorhus.com/get-ready-for-esm-aa53530b3f77) — uses). You can use `nodeLinker: 'node-modules'` in your [`.yarnrc.yml`](https://yarnpkg.com/configuration/yarnrc#nodeLinker) file to disable pnp, but it's probably easier to just use npm or [pnpm](https://pnpm.io/), which is similarly fast and efficient but without the compatibility headaches.\n\n### How do I use with Yarn 3?\n\nCurrently ESM Support within the latest Yarn (version 3) is considered [experimental](https://github.com/yarnpkg/berry/pull/2161).\n\nThe below seems to work although your results may vary. First create a new application:\n\n```sh\nyarn create svelte myapp\ncd myapp\n```\n\nAnd enable Yarn Berry:\n\n```sh\nyarn set version berry\nyarn install\n```\n\nOne of the more interesting features of Yarn Berry is the ability to have a single global cache for packages, instead of having multiple copies for each project on the disk. However, setting `enableGlobalCache` to true causes building to fail, so it is recommended to add the following to the `.yarnrc.yml` file:\n\n```yaml\nnodeLinker: node-modules\n```\n\nThis will cause packages to be downloaded into a local node_modules directory but avoids the above problem and is your best bet for using version 3 of Yarn at this point in time.\n","## Package.json in Application\nImport JSON with: `import pkg from './package.json' with { type: 'json' };`\n\n## Library Packaging Issues\nCheck library compatibility at publint.dev. Key points:\n- `exports` field takes precedence over `main` and `module`\n- ESM files should end with `.mjs` (or any extension if `\"type\": \"module\"` is set); CommonJS files should end with `.cjs`\n- `main` should be defined if `exports` is not\n- Svelte components should be distributed as uncompiled `.svelte` files with ESM-only JS\n- Use `svelte-package` for packaging Svelte libraries\n- Libraries work best with ESM versions; CommonJS dependencies are pre-bundled by vite-plugin-svelte using esbuild\n- Troubleshoot with `optimizeDeps` or `ssr` config values if needed\n\n## View Transitions API\nCall `document.startViewTransition` in `onNavigate` to trigger transitions on client-side navigation:\n```js\nimport { onNavigate } from '$app/navigation';\nonNavigate((navigation) => {\n\tif (!document.startViewTransition) return;\n\treturn new Promise((resolve) => {\n\t\tdocument.startViewTransition(async () => {\n\t\t\tresolve();\n\t\t\tawait navigation.complete;\n\t\t});\n\t});\n});\n```\n\n## Database Setup\nPut database queries in server routes, not .svelte files. Create a `db.js` singleton for connection management. Use `hooks.server.js` for one-time setup code. Use Svelte CLI to automatically set up database integrations.\n\n## Client-side Libraries Accessing document/window\nWrap in browser check: `import { browser } from '$app/environment'; if (browser) { /* code */ }`\n\nOr use `onMount` for code that runs after first DOM render:\n```js\nimport { onMount } from 'svelte';\nonMount(async () => {\n\tconst { method } = await import('some-browser-only-library');\n\tmethod('hello world');\n});\n```\n\nFor side-effect-free libraries, static import works (tree-shaken in server build):\n```js\nimport { method } from 'some-browser-only-library';\nonMount(() => { method('hello world'); });\n```\n\nOr use `{#await}` block for dynamic imports.\n\n## Different Backend API Server\nUse `event.fetch` to request from external API, but handle CORS complications. Better approach: set up a proxy. In production, rewrite paths like `/api` to the API server; in dev, use Vite's `server.proxy` option. Alternatively, create an API route:\n```js\nexport function GET({ params, url }) {\n\treturn fetch(`https://example.com/${params.path + url.search}`);\n}\n```\n\n## Middleware\nFor production with adapter-node, build a middleware for your own server. For dev, add middleware via Vite plugin using `configureServer`:\n```js\nconst myPlugin = {\n\tname: 'log-request-middleware',\n\tconfigureServer(server) {\n\t\tserver.middlewares.use((req, res, next) => {\n\t\t\tconsole.log(`Got request ${req.url}`);\n\t\t\tnext();\n\t\t});\n\t}\n};\n```\n\n## Yarn Support\nYarn 2: Plug'n'Play (pnp) is broken with ESM. Use `nodeLinker: 'node-modules'` in `.yarnrc.yml` or switch to npm/pnpm.\n\nYarn 3: ESM support is experimental. Add `nodeLinker: node-modules` to `.yarnrc.yml` to use local node_modules instead of global cache.","## Package.json\n`import pkg from './package.json' with { type: 'json' };`\n\n## Library Packaging\nCheck publint.dev. Ensure `exports` field, correct file extensions (`.mjs`/`.cjs`), and Svelte components as uncompiled `.svelte` files. Use `svelte-package` for Svelte libraries.\n\n## View Transitions\n```js\nimport { onNavigate } from '$app/navigation';\nonNavigate((navigation) => {\n\tif (!document.startViewTransition) return;\n\treturn new Promise((resolve) => {\n\t\tdocument.startViewTransition(async () => {\n\t\t\tresolve();\n\t\t\tawait navigation.complete;\n\t\t});\n\t});\n});\n```\n\n## Database\nPut queries in server routes. Create `db.js` singleton. Use `hooks.server.js` for setup.\n\n## Client-side Libraries\nUse `import { browser } from '$app/environment'` check, `onMount`, or `{#await}` blocks.\n\n## Backend API Proxy\nUse `event.fetch` or set up proxy with `server.proxy` in dev. In production, rewrite paths or create API route.\n\n## Middleware\nUse Vite plugin with `configureServer` in dev; adapter-node in production.\n\n## Yarn\nYarn 2: Use `nodeLinker: 'node-modules'` in `.yarnrc.yml`. Yarn 3: Same setting recommended for ESM support.","Common questions about SvelteKit development covering package management, library integration, APIs, databases, client-side code, proxying, middleware, and package managers."],"uses":{"params":["name","path"]}}]}
