{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","Runes/$state",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","02-runes/02-$state.md",true,{"fulltext":8,"digest":9,"short_digest":10},2599,770,178,{"input":12,"output":13,"details":14},3638,1065,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: $state\n---\n\nThe `$state` rune allows you to create _reactive state_, which means that your UI _reacts_ when it changes.\n\n```svelte\n\u003Cscript>\n\tlet count = $state(0);\n\u003C/script>\n\n\u003Cbutton onclick={() => count++}>\n\tclicks: {count}\n\u003C/button>\n```\n\nUnlike other frameworks you may have encountered, there is no API for interacting with state — `count` is just a number, rather than an object or a function, and you can update it like you would update any other variable.\n\n### Deep state\n\nIf `$state` is used with an array or a simple object, the result is a deeply reactive _state proxy_. [Proxies](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) allow Svelte to run code when you read or write properties, including via methods like `array.push(...)`, triggering granular updates.\n\nState is proxified recursively until Svelte finds something other than an array or simple object (like a class or an object created with `Object.create`). In a case like this...\n\n```js\nlet todos = $state([\n\t{\n\t\tdone: false,\n\t\ttext: 'add more todos'\n\t}\n]);\n```\n\n...modifying an individual todo's property will trigger updates to anything in your UI that depends on that specific property:\n\n```js\nlet todos = [{ done: false, text: 'add more todos' }];\n// ---cut---\ntodos[0].done = !todos[0].done;\n```\n\nIf you push a new object to the array, it will also be proxified:\n\n```js\nlet todos = [{ done: false, text: 'add more todos' }];\n// ---cut---\ntodos.push({\n\tdone: false,\n\ttext: 'eat lunch'\n});\n```\n\n> [!NOTE] When you update properties of proxies, the original object is _not_ mutated.\n\nNote that if you destructure a reactive value, the references are not reactive — as in normal JavaScript, they are evaluated at the point of destructuring:\n\n```js\nlet todos = [{ done: false, text: 'add more todos' }];\n// ---cut---\nlet { done, text } = todos[0];\n\n// this will not affect the value of `done`\ntodos[0].done = !todos[0].done;\n```\n\n### Classes\n\nClass instances are not proxied. Instead, you can use `$state` in class fields (whether public or private), or as the first assignment to a property immediately inside the `constructor`:\n\n```js\n// @errors: 7006 2554\nclass Todo {\n\tdone = $state(false);\n\n\tconstructor(text) {\n\t\tthis.text = $state(text);\n\t}\n\n\treset() {\n\t\tthis.text = '';\n\t\tthis.done = false;\n\t}\n}\n```\n\n> [!NOTE] The compiler transforms `done` and `text` into `get`/`set` methods on the class prototype referencing private fields. This means the properties are not enumerable.\n\nWhen calling methods in JavaScript, the value of [`this`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this) matters. This won't work, because `this` inside the `reset` method will be the `\u003Cbutton>` rather than the `Todo`:\n\n```svelte\n\u003Cbutton onclick={todo.reset}>\n\treset\n\u003C/button>\n```\n\nYou can either use an inline function...\n\n```svelte\n\u003Cbutton onclick=+++{() => todo.reset()}>+++\n\treset\n\u003C/button>\n```\n\n...or use an arrow function in the class definition:\n\n```js\n// @errors: 7006 2554\nclass Todo {\n\tdone = $state(false);\n\n\tconstructor(text) {\n\t\tthis.text = $state(text);\n\t}\n\n\t+++reset = () => {+++\n\t\tthis.text = '';\n\t\tthis.done = false;\n\t}\n}\n```\n\n> Svelte provides reactive implementations of built-in classes like `Set` and `Map` that can be imported from [`svelte/reactivity`](svelte-reactivity).\n\n## `$state.raw`\n\nIn cases where you don't want objects and arrays to be deeply reactive you can use `$state.raw`.\n\nState declared with `$state.raw` cannot be mutated; it can only be _reassigned_. In other words, rather than assigning to a property of an object, or using an array method like `push`, replace the object or array altogether if you'd like to update it:\n\n```js\nlet person = $state.raw({\n\tname: 'Heraclitus',\n\tage: 49\n});\n\n// this will have no effect\nperson.age += 1;\n\n// this will work, because we're creating a new person\nperson = {\n\tname: 'Heraclitus',\n\tage: 50\n};\n```\n\nThis can improve performance with large arrays and objects that you weren't planning to mutate anyway, since it avoids the cost of making them reactive. Note that raw state can _contain_ reactive state (for example, a raw array of reactive objects).\n\nAs with `$state`, you can declare class fields using `$state.raw`.\n\n## `$state.snapshot`\n\nTo take a static snapshot of a deeply reactive `$state` proxy, use `$state.snapshot`:\n\n```svelte\n\u003Cscript>\n\tlet counter = $state({ count: 0 });\n\n\tfunction onclick() {\n\t\t// Will log `{ count: ... }` rather than `Proxy { ... }`\n\t\tconsole.log($state.snapshot(counter));\n\t}\n\u003C/script>\n```\n\nThis is handy when you want to pass some state to an external library or API that doesn't expect a proxy, such as `structuredClone`.\n\n## Passing state into functions\n\nJavaScript is a _pass-by-value_ language — when you call a function, the arguments are the _values_ rather than the _variables_. In other words:\n\n```js\n/// file: index.js\n// @filename: index.js\n// ---cut---\n/**\n * @param {number} a\n * @param {number} b\n */\nfunction add(a, b) {\n\treturn a + b;\n}\n\nlet a = 1;\nlet b = 2;\nlet total = add(a, b);\nconsole.log(total); // 3\n\na = 3;\nb = 4;\nconsole.log(total); // still 3!\n```\n\nIf `add` wanted to have access to the _current_ values of `a` and `b`, and to return the current `total` value, you would need to use functions instead:\n\n```js\n/// file: index.js\n// @filename: index.js\n// ---cut---\n/**\n * @param {() => number} getA\n * @param {() => number} getB\n */\nfunction add(+++getA, getB+++) {\n\treturn +++() => getA() + getB()+++;\n}\n\nlet a = 1;\nlet b = 2;\nlet total = add+++(() => a, () => b)+++;\nconsole.log(+++total()+++); // 3\n\na = 3;\nb = 4;\nconsole.log(+++total()+++); // 7\n```\n\nState in Svelte is no different — when you reference something declared with the `$state` rune...\n\n```js\nlet a = +++$state(1)+++;\nlet b = +++$state(2)+++;\n```\n\n...you're accessing its _current value_.\n\nNote that 'functions' is broad — it encompasses properties of proxies and [`get`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get)/[`set`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set) properties...\n\n```js\n/// file: index.js\n// @filename: index.js\n// ---cut---\n/**\n * @param {{ a: number, b: number }} input\n */\nfunction add(input) {\n\treturn {\n\t\tget value() {\n\t\t\treturn input.a + input.b;\n\t\t}\n\t};\n}\n\nlet input = $state({ a: 1, b: 2 });\nlet total = add(input);\nconsole.log(total.value); // 3\n\ninput.a = 3;\ninput.b = 4;\nconsole.log(total.value); // 7\n```\n\n...though if you find yourself writing code like that, consider using [classes](#Classes) instead.\n\n## Passing state across modules\n\nYou can declare state in `.svelte.js` and `.svelte.ts` files, but you can only _export_ that state if it's not directly reassigned. In other words you can't do this:\n\n```js\n/// file: state.svelte.js\nexport let count = $state(0);\n\nexport function increment() {\n\tcount += 1;\n}\n```\n\nThat's because every reference to `count` is transformed by the Svelte compiler — the code above is roughly equivalent to this:\n\n```js\n/// file: state.svelte.js (compiler output)\n// @filename: index.ts\ninterface Signal\u003CT> {\n\tvalue: T;\n}\n\ninterface Svelte {\n\tstate\u003CT>(value?: T): Signal\u003CT>;\n\tget\u003CT>(source: Signal\u003CT>): T;\n\tset\u003CT>(source: Signal\u003CT>, value: T): void;\n}\ndeclare const $: Svelte;\n// ---cut---\nexport let count = $.state(0);\n\nexport function increment() {\n\t$.set(count, $.get(count) + 1);\n}\n```\n\n> [!NOTE] You can see the code Svelte generates by clicking the 'JS Output' tab in the [playground](/playground).\n\nSince the compiler only operates on one file at a time, if another file imports `count` Svelte doesn't know that it needs to wrap each reference in `$.get` and `$.set`:\n\n```js\n// @filename: state.svelte.js\nexport let count = 0;\n\n// @filename: index.js\n// ---cut---\nimport { count } from './state.svelte.js';\n\nconsole.log(typeof count); // 'object', not 'number'\n```\n\nThis leaves you with two options for sharing state between modules — either don't reassign it...\n\n```js\n// This is allowed — since we're updating\n// `counter.count` rather than `counter`,\n// Svelte doesn't wrap it in `$.state`\nexport const counter = $state({\n\tcount: 0\n});\n\nexport function increment() {\n\tcounter.count += 1;\n}\n```\n\n...or don't directly export it:\n\n```js\nlet count = $state(0);\n\nexport function getCount() {\n\treturn count;\n}\n\nexport function increment() {\n\tcount += 1;\n}\n```\n","## Creating Reactive State\n\nUse `$state(value)` to create reactive state. The value is just a normal variable, updated like any other:\n\n```svelte\n\u003Cscript>\n\tlet count = $state(0);\n\u003C/script>\n\n\u003Cbutton onclick={() => count++}>\n\tclicks: {count}\n\u003C/button>\n```\n\n## Deep Reactivity with Proxies\n\nArrays and plain objects become deeply reactive proxies. Modifying nested properties triggers granular updates:\n\n```js\nlet todos = $state([{ done: false, text: 'add more todos' }]);\ntodos[0].done = !todos[0].done; // triggers update\ntodos.push({ done: false, text: 'eat lunch' }); // new object is also proxified\n```\n\nDestructuring breaks reactivity — destructured values are evaluated once and don't update:\n\n```js\nlet { done, text } = todos[0];\ntodos[0].done = !todos[0].done; // doesn't affect the destructured `done`\n```\n\n## Class Fields\n\nClass instances aren't proxied. Use `$state` on class fields instead:\n\n```js\nclass Todo {\n\tdone = $state(false);\n\tconstructor(text) {\n\t\tthis.text = $state(text);\n\t}\n\treset = () => { // use arrow function to preserve `this`\n\t\tthis.text = '';\n\t\tthis.done = false;\n\t}\n}\n```\n\nThe compiler transforms these into get/set methods on private fields.\n\n## `$state.raw`\n\nFor non-reactive state that can only be reassigned (not mutated), use `$state.raw`. Improves performance with large objects/arrays you won't mutate:\n\n```js\nlet person = $state.raw({ name: 'Heraclitus', age: 49 });\nperson.age += 1; // no effect\nperson = { name: 'Heraclitus', age: 50 }; // works\n```\n\n## `$state.snapshot`\n\nTake a static snapshot of a reactive proxy for passing to external libraries:\n\n```js\nlet counter = $state({ count: 0 });\nconsole.log($state.snapshot(counter)); // plain object, not Proxy\n```\n\n## Passing State to Functions\n\nState is pass-by-value. When passed to functions, they receive the current value. To access reactive updates, use functions/getters or pass proxy objects:\n\n```js\nlet input = $state({ a: 1, b: 2 });\nlet total = add(input); // proxy passed, getter accesses current values\nconsole.log(total.value); // 3\ninput.a = 3;\nconsole.log(total.value); // 7\n```\n\n## Exporting State Across Modules\n\nCan't directly export and reassign state because the compiler transforms each reference. Two options:\n\n1. Export an object and mutate its properties (not the object itself):\n```js\nexport const counter = $state({ count: 0 });\nexport function increment() { counter.count += 1; }\n```\n\n2. Don't export the state directly, export functions that access it:\n```js\nlet count = $state(0);\nexport function getCount() { return count; }\nexport function increment() { count += 1; }\n```","## $state Rune\n\nCreate reactive state with `$state(value)`. Arrays and plain objects become deeply reactive proxies:\n\n```js\nlet count = $state(0);\nlet todos = $state([{ done: false, text: 'add more todos' }]);\ntodos[0].done = !todos[0].done; // triggers update\n```\n\nUse `$state.raw` for non-reactive state that can only be reassigned. Use `$state.snapshot` to get a plain object from a proxy.\n\nFor class fields, use `$state` on individual fields. Destructuring breaks reactivity.\n\nWhen exporting state across modules, either export an object and mutate its properties, or export functions that access the state instead of exporting the state directly.","The $state rune creates reactive variables; arrays and objects become deeply reactive proxies, with variants for raw non-reactive state and snapshots."],"uses":{"params":["name","path"]}}]}
