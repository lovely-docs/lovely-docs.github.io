{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-sveltekit","advanced-techniques/advanced-routing",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","30-advanced/10-advanced-routing.md",true,{"fulltext":8,"digest":9,"short_digest":10},3636,609,282,{"input":12,"output":13,"details":14},4679,1002,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: Advanced routing\n---\n\n## Rest parameters\n\nIf the number of route segments is unknown, you can use rest syntax â€” for example you might implement GitHub's file viewer like so...\n\n```sh\n/[org]/[repo]/tree/[branch]/[...file]\n```\n\n...in which case a request for `/sveltejs/kit/tree/main/documentation/docs/04-advanced-routing.md` would result in the following parameters being available to the page:\n\n```js\n// @noErrors\n{\n\torg: 'sveltejs',\n\trepo: 'kit',\n\tbranch: 'main',\n\tfile: 'documentation/docs/04-advanced-routing.md'\n}\n```\n\n> [!NOTE] `src/routes/a/[...rest]/z/+page.svelte` will match `/a/z` (i.e. there's no parameter at all) as well as `/a/b/z` and `/a/b/c/z` and so on. Make sure you check that the value of the rest parameter is valid, for example using a [matcher](#Matching).\n\n### 404 pages\n\nRest parameters also allow you to render custom 404s. Given these routes...\n\n```tree\nsrc/routes/\nâ”œ marx-brothers/\nâ”‚ â”œ chico/\nâ”‚ â”œ harpo/\nâ”‚ â”œ groucho/\nâ”‚ â”” +error.svelte\nâ”” +error.svelte\n```\n\n...the `marx-brothers/+error.svelte` file will _not_ be rendered if you visit `/marx-brothers/karl`, because no route was matched. If you want to render the nested error page, you should create a route that matches any `/marx-brothers/*` request, and return a 404 from it:\n\n```tree\nsrc/routes/\nâ”œ marx-brothers/\n+++| â”œ [...path]/+++\nâ”‚ â”œ chico/\nâ”‚ â”œ harpo/\nâ”‚ â”œ groucho/\nâ”‚ â”” +error.svelte\nâ”” +error.svelte\n```\n\n```js\n/// file: src/routes/marx-brothers/[...path]/+page.js\nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').PageLoad} */\nexport function load(event) {\n\terror(404, 'Not Found');\n}\n```\n\n> [!NOTE] If you don't handle 404 cases, they will appear in [`handleError`](hooks#Shared-hooks-handleError)\n\n## Optional parameters\n\nA route like `[lang]/home` contains a parameter named `lang` which is required. Sometimes it's beneficial to make these parameters optional, so that in this example both `home` and `en/home` point to the same page. You can do that by wrapping the parameter in another bracket pair: `[[lang]]/home`\n\nNote that an optional route parameter cannot follow a rest parameter (`[...rest]/[[optional]]`), since parameters are matched 'greedily' and the optional parameter would always be unused.\n\n## Matching\n\nA route like `src/routes/fruits/[page]` would match `/fruits/apple`, but it would also match `/fruits/rocketship`. We don't want that. You can ensure that route parameters are well-formed by adding a _matcher_ â€” which takes the parameter string (`\"apple\"` or `\"rocketship\"`) and returns `true` if it is valid â€” to your [`params`](configuration#files) directory...\n\n```js\n/// file: src/params/fruit.js\n/**\n * @param {string} param\n * @return {param is ('apple' | 'orange')}\n * @satisfies {import('@sveltejs/kit').ParamMatcher}\n */\nexport function match(param) {\n\treturn param === 'apple' || param === 'orange';\n}\n```\n\n...and augmenting your routes:\n\n```\nsrc/routes/fruits/[page+++=fruit+++]\n```\n\nIf the pathname doesn't match, SvelteKit will try to match other routes (using the sort order specified below), before eventually returning a 404.\n\nEach module in the `params` directory corresponds to a matcher, with the exception of `*.test.js` and `*.spec.js` files which may be used to unit test your matchers.\n\n> [!NOTE] Matchers run both on the server and in the browser.\n\n## Sorting\n\nIt's possible for multiple routes to match a given path. For example each of these routes would match `/foo-abc`:\n\n```sh\nsrc/routes/[...catchall]/+page.svelte\nsrc/routes/[[a=x]]/+page.svelte\nsrc/routes/[b]/+page.svelte\nsrc/routes/foo-[c]/+page.svelte\nsrc/routes/foo-abc/+page.svelte\n```\n\nSvelteKit needs to know which route is being requested. To do so, it sorts them according to the following rules...\n\n- More specific routes are higher priority (e.g. a route with no parameters is more specific than a route with one dynamic parameter, and so on)\n- Parameters with [matchers](#Matching) (`[name=type]`) are higher priority than those without (`[name]`)\n- `[[optional]]` and `[...rest]` parameters are ignored unless they are the final part of the route, in which case they are treated with lowest priority. In other words `x/[[y]]/z` is treated equivalently to `x/z` for the purposes of sorting\n- Ties are resolved alphabetically\n\n...resulting in this ordering, meaning that `/foo-abc` will invoke `src/routes/foo-abc/+page.svelte`, and `/foo-def` will invoke `src/routes/foo-[c]/+page.svelte` rather than less specific routes:\n\n```sh\nsrc/routes/foo-abc/+page.svelte\nsrc/routes/foo-[c]/+page.svelte\nsrc/routes/[[a=x]]/+page.svelte\nsrc/routes/[b]/+page.svelte\nsrc/routes/[...catchall]/+page.svelte\n```\n\n## Encoding\n\nSome characters can't be used on the filesystem â€” `/` on Linux and Mac, `\\ / : * ? \" \u003C > |` on Windows. The `#` and `%` characters have special meaning in URLs, and the `[ ] ( )` characters have special meaning to SvelteKit, so these also can't be used directly as part of your route.\n\nTo use these characters in your routes, you can use hexadecimal escape sequences, which have the format `[x+nn]` where `nn` is a hexadecimal character code:\n\n- `\\` â€” `[x+5c]`\n- `/` â€” `[x+2f]`\n- `:` â€” `[x+3a]`\n- `*` â€” `[x+2a]`\n- `?` â€” `[x+3f]`\n- `\"` â€” `[x+22]`\n- `\u003C` â€” `[x+3c]`\n- `>` â€” `[x+3e]`\n- `|` â€” `[x+7c]`\n- `#` â€” `[x+23]`\n- `%` â€” `[x+25]`\n- `[` â€” `[x+5b]`\n- `]` â€” `[x+5d]`\n- `(` â€” `[x+28]`\n- `)` â€” `[x+29]`\n\nFor example, to create a `/smileys/:-)` route, you would create a `src/routes/smileys/[x+3a]-[x+29]/+page.svelte` file.\n\nYou can determine the hexadecimal code for a character with JavaScript:\n\n```js\n':'.charCodeAt(0).toString(16); // '3a', hence '[x+3a]'\n```\n\nYou can also use Unicode escape sequences. Generally you won't need to as you can use the unencoded character directly, but if â€” for some reason â€” you can't have a filename with an emoji in it, for example, then you can use the escaped characters. In other words, these are equivalent:\n\n```\nsrc/routes/[u+d83e][u+dd2a]/+page.svelte\nsrc/routes/ðŸ¤ª/+page.svelte\n```\n\nThe format for a Unicode escape sequence is `[u+nnnn]` where `nnnn` is a valid value between `0000` and `10ffff`. (Unlike JavaScript string escaping, there's no need to use surrogate pairs to represent code points above `ffff`.) To learn more about Unicode encodings, consult [Programming with Unicode](https://unicodebook.readthedocs.io/unicode_encodings.html).\n\n> [!NOTE] Since TypeScript [struggles](https://github.com/microsoft/TypeScript/issues/13399) with directories with a leading `.` character, you may find it useful to encode these characters when creating e.g. [`.well-known`](https://en.wikipedia.org/wiki/Well-known_URI) routes: `src/routes/[x+2e]well-known/...`\n\n## Advanced layouts\n\nBy default, the _layout hierarchy_ mirrors the _route hierarchy_. In some cases, that might not be what you want.\n\n### (group)\n\nPerhaps you have some routes that are 'app' routes that should have one layout (e.g. `/dashboard` or `/item`), and others that are 'marketing' routes that should have a different layout (`/about` or `/testimonials`). We can group these routes with a directory whose name is wrapped in parentheses â€” unlike normal directories, `(app)` and `(marketing)` do not affect the URL pathname of the routes inside them:\n\n```tree\nsrc/routes/\n+++â”‚ (app)/+++\nâ”‚ â”œ dashboard/\nâ”‚ â”œ item/\nâ”‚ â”” +layout.svelte\n+++â”‚ (marketing)/+++\nâ”‚ â”œ about/\nâ”‚ â”œ testimonials/\nâ”‚ â”” +layout.svelte\nâ”œ admin/\nâ”” +layout.svelte\n```\n\nYou can also put a `+page` directly inside a `(group)`, for example if `/` should be an `(app)` or a `(marketing)` page.\n\n### Breaking out of layouts\n\nThe root layout applies to every page of your app â€” if omitted, it defaults to `{@render children()}`. If you want some pages to have a different layout hierarchy than the rest, then you can put your entire app inside one or more groups _except_ the routes that should not inherit the common layouts.\n\nIn the example above, the `/admin` route does not inherit either the `(app)` or `(marketing)` layouts.\n\n### +page@\n\nPages can break out of the current layout hierarchy on a route-by-route basis. Suppose we have an `/item/[id]/embed` route inside the `(app)` group from the previous example:\n\n```tree\nsrc/routes/\nâ”œ (app)/\nâ”‚ â”œ item/\nâ”‚ â”‚ â”œ [id]/\nâ”‚ â”‚ â”‚ â”œ embed/\n+++â”‚ â”‚ â”‚ â”‚ â”” +page.svelte+++\nâ”‚ â”‚ â”‚ â”” +layout.svelte\nâ”‚ â”‚ â”” +layout.svelte\nâ”‚ â”” +layout.svelte\nâ”” +layout.svelte\n```\n\nOrdinarily, this would inherit the root layout, the `(app)` layout, the `item` layout and the `[id]` layout. We can reset to one of those layouts by appending `@` followed by the segment name â€” or, for the root layout, the empty string. In this example, we can choose from the following options:\n\n- `+page@[id].svelte` - inherits from `src/routes/(app)/item/[id]/+layout.svelte`\n- `+page@item.svelte` - inherits from `src/routes/(app)/item/+layout.svelte`\n- `+page@(app).svelte` - inherits from `src/routes/(app)/+layout.svelte`\n- `+page@.svelte` - inherits from `src/routes/+layout.svelte`\n\n```tree\nsrc/routes/\nâ”œ (app)/\nâ”‚ â”œ item/\nâ”‚ â”‚ â”œ [id]/\nâ”‚ â”‚ â”‚ â”œ embed/\n+++â”‚ â”‚ â”‚ â”‚ â”” +page@(app).svelte+++\nâ”‚ â”‚ â”‚ â”” +layout.svelte\nâ”‚ â”‚ â”” +layout.svelte\nâ”‚ â”” +layout.svelte\nâ”” +layout.svelte\n```\n\n### +layout@\n\nLike pages, layouts can _themselves_ break out of their parent layout hierarchy, using the same technique. For example, a `+layout@.svelte` component would reset the hierarchy for all its child routes.\n\n```\nsrc/routes/\nâ”œ (app)/\nâ”‚ â”œ item/\nâ”‚ â”‚ â”œ [id]/\nâ”‚ â”‚ â”‚ â”œ embed/\nâ”‚ â”‚ â”‚ â”‚ â”” +page.svelte  // uses (app)/item/[id]/+layout.svelte\nâ”‚ â”‚ â”‚ â”œ +layout.svelte  // inherits from (app)/item/+layout@.svelte\nâ”‚ â”‚ â”‚ â”” +page.svelte    // uses (app)/item/+layout@.svelte\nâ”‚ â”‚ â”” +layout@.svelte   // inherits from root layout, skipping (app)/+layout.svelte\nâ”‚ â”” +layout.svelte\nâ”” +layout.svelte\n```\n\n### When to use layout groups\n\nNot all use cases are suited for layout grouping, nor should you feel compelled to use them. It might be that your use case would result in complex `(group)` nesting, or that you don't want to introduce a `(group)` for a single outlier. It's perfectly fine to use other means such as composition (reusable `load` functions or Svelte components) or if-statements to achieve what you want. The following example shows a layout that rewinds to the root layout and reuses components and functions that other layouts can also use:\n\n```svelte\n\u003C!--- file: src/routes/nested/route/+layout@.svelte --->\n\u003Cscript>\n\timport ReusableLayout from '$lib/ReusableLayout.svelte';\n\tlet { data, children } = $props();\n\u003C/script>\n\n\u003CReusableLayout {data}>\n\t{@render children()}\n\u003C/ReusableLayout>\n```\n\n```js\n/// file: src/routes/nested/route/+layout.js\n// @filename: ambient.d.ts\ndeclare module \"$lib/reusable-load-function\" {\n\texport function reusableLoad(event: import('@sveltejs/kit').LoadEvent): Promise\u003CRecord\u003Cstring, any>>;\n}\n// @filename: index.js\n// ---cut---\nimport { reusableLoad } from '$lib/reusable-load-function';\n\n/** @type {import('./$types').PageLoad} */\nexport function load(event) {\n\t// Add additional logic here, if needed\n\treturn reusableLoad(event);\n}\n```\n\n## Further reading\n\n- [Tutorial: Advanced Routing](/tutorial/kit/optional-params)\n","## Rest Parameters\nUse `[...file]` syntax to match variable number of segments. Example: `/[org]/[repo]/tree/[branch]/[...file]` matches `/sveltejs/kit/tree/main/documentation/docs/04-advanced-routing.md` with `file: 'documentation/docs/04-advanced-routing.md'`. Rest parameters match zero or more segments, so `[...rest]` matches both `/a/z` and `/a/b/c/z`.\n\n## 404 Pages\nCreate a catch-all route with rest parameters to render custom 404s. Create `src/routes/marx-brothers/[...path]/+page.js` that calls `error(404, 'Not Found')` to handle unmatched paths within a directory.\n\n## Optional Parameters\nWrap parameters in double brackets to make them optional: `[[lang]]/home` matches both `home` and `en/home`. Optional parameters cannot follow rest parameters.\n\n## Matching\nUse matchers to validate route parameters. Create `src/params/fruit.js` with a `match(param)` function returning boolean, then use `[page=fruit]` in routes. Matchers run on both server and browser.\n\n## Sorting\nWhen multiple routes match a path, SvelteKit prioritizes by: (1) specificity (no parameters > dynamic parameters), (2) matchers (`[name=type]` > `[name]`), (3) optional/rest parameters lowest priority unless final, (4) alphabetical ties. Example: `/foo-abc` matches `foo-abc/+page.svelte` before `foo-[c]/+page.svelte`.\n\n## Encoding\nUse hexadecimal escape sequences `[x+nn]` for special characters: `[x+3a]` for `:`, `[x+2f]` for `/`, `[x+23]` for `#`, etc. Use Unicode sequences `[u+nnnn]` for emoji: `[u+d83e][u+dd2a]` or just `ðŸ¤ª`. Example: `/smileys/:-)` becomes `src/routes/smileys/[x+3a]-[x+29]/+page.svelte`.\n\n## Layout Groups\nUse `(group)` directories to organize routes without affecting URLs. Routes in `(app)` and `(marketing)` groups have separate layouts. Break out of layout hierarchy with `+page@segment` or `+layout@segment` syntax. `+page@.svelte` inherits only root layout, `+page@(app).svelte` inherits from `(app)` layout.","## Rest Parameters\n`[...file]` matches variable segments: `/[org]/[repo]/tree/[branch]/[...file]` with `/sveltejs/kit/tree/main/docs/file.md` gives `file: 'docs/file.md'`.\n\n## Optional Parameters\n`[[lang]]/home` matches both `home` and `en/home`.\n\n## Matching\nCreate `src/params/fruit.js` with `match(param)` function, use `[page=fruit]` in routes.\n\n## Sorting\nSpecificity > matchers > optional/rest > alphabetical. `/foo-abc` matches `foo-abc/+page.svelte` before `foo-[c]/+page.svelte`.\n\n## Encoding\n`[x+3a]` for `:`, `[x+2f]` for `/`. `/smileys/:-)` becomes `src/routes/smileys/[x+3a]-[x+29]/+page.svelte`.\n\n## Layout Groups\n`(app)` and `(marketing)` organize routes without URL changes. Use `+page@(app).svelte` to inherit from `(app)` layout only.","Advanced routing techniques including rest parameters, optional parameters, matchers, route sorting, character encoding, and layout grouping."],"uses":{"params":["name","path"]}}]}
