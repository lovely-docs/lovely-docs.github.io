{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"library":1},{"library":2,"source":3,"source_type":7,"date":8,"model":9,"commit":10,"tree":11},"sveltejs-sveltekit",{"name":2,"doc_dir":4,"repo":5,"commit":6},"documentation/docs","https://github.com/sveltejs/kit","dc33ef7773d45d66b58b6e88f0673a847c47aa6b","git","2025-11-05T03:21:39.293772+00:00","claude-haiku-4.5","c01e462adb99693054c2a4eaeacc0353bbaba786-dirty",{"name":12,"path":12,"children":13},"",["Map",14,15,142,143,282,283,511,512,724,725,861,862,1015,1016,1399,1400],"getting-started",{"name":14,"path":14,"children":16,"data":128},["Map",17,18,38,39,57,58,75,76,93,94,14,111],"introduction",{"name":17,"path":19,"children":20,"data":21},"getting-started/introduction",["Map"],{"type":22,"path":23,"relevant":24,"token_counts":25,"usage":29,"markdown":33},"page","10-getting-started/10-introduction.md",false,{"fulltext":26,"digest":27,"short_digest":28},686,223,81,{"input":30,"output":31,"details":32},1729,420,null,{"fulltext":34,"digest":35,"short_digest":36,"essence":37},"---\ntitle: Introduction\n---\n\n## Before we begin\n\n> [!NOTE] If you're new to Svelte or SvelteKit we recommend checking out the [interactive tutorial](/tutorial/kit).\n>\n> If you get stuck, reach out for help in the [Discord chatroom](/chat).\n\n## What is SvelteKit?\n\nSvelteKit is a framework for rapidly developing robust, performant web applications using [Svelte](../svelte). If you're coming from React, SvelteKit is similar to Next. If you're coming from Vue, SvelteKit is similar to Nuxt.\n\nTo learn more about the kinds of applications you can build with SvelteKit, see the [documentation regarding project types](project-types).\n\n## What is Svelte?\n\nIn short, Svelte is a way of writing user interface components — like a navigation bar, comment section, or contact form — that users see and interact with in their browsers. The Svelte compiler converts your components to JavaScript that can be run to render the HTML for the page and to CSS that styles the page. You don't need to know Svelte to understand the rest of this guide, but it will help. If you'd like to learn more, check out [the Svelte tutorial](/tutorial).\n\n## SvelteKit vs Svelte\n\nSvelte renders UI components. You can compose these components and render an entire page with just Svelte, but you need more than just Svelte to write an entire app.\n\nSvelteKit helps you build web apps while following modern best practices and providing solutions to common development challenges. It offers everything from basic functionalities — like a [router](glossary#Routing) that updates your UI when a link is clicked — to more advanced capabilities. Its extensive list of features includes [build optimizations](https://vitejs.dev/guide/features.html#build-optimizations) to load only the minimal required code; [offline support](service-workers); [preloading](link-options#data-sveltekit-preload-data) pages before user navigation; [configurable rendering](page-options) to handle different parts of your app on the server via [SSR](glossary#SSR), in the browser through [client-side rendering](glossary#CSR), or at build-time with [prerendering](glossary#Prerendering); [image optimization](images); and much more. Building an app with all the modern best practices is fiendishly complicated, but SvelteKit does all the boring stuff for you so that you can get on with the creative part.\n\nIt reflects changes to your code in the browser instantly to provide a lightning-fast and feature-rich development experience by leveraging [Vite](https://vitejs.dev/) with a [Svelte plugin](https://github.com/sveltejs/vite-plugin-svelte) to do [Hot Module Replacement (HMR)](https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/config.md#hot).\n","SvelteKit is a framework for building web applications with Svelte. It's comparable to Next.js (for React developers) or Nuxt (for Vue developers).\n\n**Svelte vs SvelteKit:**\n- Svelte is a compiler that converts UI components into JavaScript and CSS\n- SvelteKit adds the infrastructure needed for full applications: routing, build optimizations, offline support, preloading, configurable rendering (SSR, CSR, prerendering), image optimization, and hot module replacement via Vite\n\n**Key capabilities:**\n- Router that updates UI on navigation\n- Build optimizations to load minimal code\n- Offline support via service workers\n- Page preloading before user navigation\n- Configurable rendering modes (server-side, client-side, or build-time prerendering)\n- Image optimization\n- Fast development experience with HMR through Vite\n\nSvelteKit handles modern best practices and common development challenges so you can focus on building.","SvelteKit is a framework for building web apps with Svelte (comparable to Next.js or Nuxt). It provides routing, build optimizations, offline support, configurable rendering (SSR/CSR/prerendering), image optimization, and HMR via Vite. Svelte itself is just a UI component compiler.","SvelteKit is a web application framework built on Svelte that provides routing, build optimizations, offline support, and configurable rendering modes.","creating-a-project",{"name":38,"path":40,"children":41,"data":42},"getting-started/creating-a-project",["Map"],{"type":22,"path":43,"relevant":44,"token_counts":45,"usage":49,"markdown":52},"10-getting-started/20-creating-a-project.md",true,{"fulltext":46,"digest":47,"short_digest":48},354,137,63,{"input":50,"output":51,"details":32},1401,303,{"fulltext":53,"digest":54,"short_digest":55,"essence":56},"---\ntitle: Creating a project\n---\n\nThe easiest way to start building a SvelteKit app is to run `npx sv create`:\n\n```sh\nnpx sv create my-app\ncd my-app\nnpm run dev\n```\n\nThe first command will scaffold a new project in the `my-app` directory asking if you'd like to set up some basic tooling such as TypeScript. See [the CLI docs](/docs/cli/overview) for information about these options and [the integrations page](./integrations) for pointers on setting up additional tooling. `npm run dev` will then start the development server on [localhost:5173](http://localhost:5173) - make sure you install dependencies before running this if you didn't do so during project creation.\n\nThere are two basic concepts:\n\n- Each page of your app is a [Svelte](../svelte) component\n- You create pages by adding files to the `src/routes` directory of your project. These will be server-rendered so that a user's first visit to your app is as fast as possible, then a client-side app takes over\n\nTry editing the files to get a feel for how everything works.\n\n## Editor setup\n\nWe recommend using [Visual Studio Code (aka VS Code)](https://code.visualstudio.com/download) with [the Svelte extension](https://marketplace.visualstudio.com/items?itemName=svelte.svelte-vscode), but [support also exists for numerous other editors](https://sveltesociety.dev/resources#editor-support).\n","## Quick Start\n\nRun `npx sv create my-app` to scaffold a new SvelteKit project. This command prompts you to set up basic tooling like TypeScript. Then run `npm run dev` to start the development server on localhost:5173.\n\n## Core Concepts\n\n- Each page is a Svelte component\n- Create pages by adding files to `src/routes` directory\n- Pages are server-rendered on first visit for performance, then a client-side app takes over\n\n## Editor Setup\n\nVisual Studio Code with the Svelte extension is recommended, though other editors are supported.","Run `npx sv create my-app` to scaffold a project, then `npm run dev` to start the dev server on localhost:5173. Pages are Svelte components in `src/routes` that are server-rendered initially, then client-side.","How to create a new SvelteKit project and understand its basic structure.","project-types",{"name":57,"path":59,"children":60,"data":61},"getting-started/project-types",["Map"],{"type":22,"path":62,"relevant":44,"token_counts":63,"usage":67,"markdown":70},"10-getting-started/25-project-types.md",{"fulltext":64,"digest":65,"short_digest":66},1702,419,110,{"input":68,"output":69,"details":32},2747,633,{"fulltext":71,"digest":72,"short_digest":73,"essence":74},"---\ntitle: Project types\n---\n\nSvelteKit offers configurable rendering, which allows you to build and deploy your project in several different ways. You can build all of the below types of applications and more with SvelteKit. Rendering settings are not mutually exclusive and you may choose the optimal manner with which to render different parts of your application.\n\nIf you don't have a particular way you'd like to build your application in mind, don't worry! The way your application is built, deployed, and rendered is controlled by which adapter you've chosen and a small amount of configuration and these can always be changed later. The [project structure](project-structure) and [routing](glossary#Routing) will be the same regardless of the project type that you choose.\n\n## Default rendering\n\nBy default, when a user visits a site, SvelteKit will render the first page with [server-side rendering (SSR)](glossary#SSR) and subsequent pages with [client-side rendering (CSR)](glossary#CSR). Using SSR for the initial render improves SEO and perceived performance of the initial page load. Client-side rendering then takes over and updates the page without having to rerender common components, which is typically faster and eliminates a flash when navigating between pages. Apps built with this hybrid rendering approach have also been called [transitional apps](https://www.youtube.com/watch?v=860d8usGC0o).\n\n## Static site generation\n\nYou can use SvelteKit as a [static site generator (SSG)](glossary#SSG) that fully [prerenders](glossary#Prerendering) your site with static rendering using [`adapter-static`](adapter-static). You may also use [the prerender option](page-options#prerender) to prerender only some pages and then choose a different adapter with which to dynamically server-render other pages.\n\nTools built solely to do static site generation may scale the prerendering process more efficiently during build when rendering a very large number of pages. When working with very large statically generated sites, you can avoid long build times with [Incremental Static Regeneration (ISR) if using `adapter-vercel`](adapter-vercel#Incremental-Static-Regeneration). And in contrast to purpose-built SSGs, SvelteKit allows for nicely mixing and matching different rendering types on different pages.\n\n## Single-page app\n\n[Single-page apps (SPAs)](glossary#SPA) exclusively use [client-side rendering (CSR)](glossary#CSR). You can [build single-page apps (SPAs)](single-page-apps) with SvelteKit. As with all types of SvelteKit applications, you can write your backend in SvelteKit or [another language or framework](#Separate-backend). If you are building an application with no backend or a [separate backend](#Separate-backend), you can simply skip over and ignore the parts of the docs talking about `server` files.\n\n## Multi-page app\n\nSvelteKit isn't typically used to build [traditional multi-page apps](glossary#MPA). However, in SvelteKit you can remove all JavaScript on a page with [`csr = false`](page-options#csr), which will render subsequent links on the server, or you can use [`data-sveltekit-reload`](link-options#data-sveltekit-reload) to render specific links on the server.\n\n## Separate backend\n\nIf your backend is written in another language such as Go, Java, PHP, Ruby, Rust, or C#, there are a couple of ways that you can deploy your application. The most recommended way would be to deploy your SvelteKit frontend separately from your backend utilizing `adapter-node` or a serverless adapter. Some users prefer not to have a separate process to manage and decide to deploy their application as a [single-page app (SPA)](single-page-apps) served by their backend server, but note that single-page apps have worse SEO and performance characteristics.\n\nIf you are using an external backend, you can simply skip over and ignore the parts of the docs talking about `server` files. You may also want to reference [the FAQ about how to make calls to a separate backend](faq#How-do-I-use-a-different-backend-API-server).\n\n## Serverless app\n\nSvelteKit apps are simple to run on serverless platforms. [The default zero config adapter](adapter-auto) will automatically run your app on a number of supported platforms or you can use [`adapter-vercel`](adapter-vercel), [`adapter-netlify`](adapter-netlify), or [`adapter-cloudflare`](adapter-cloudflare) to provide platform-specific configuration. And [community adapters](/packages#sveltekit-adapters) allow you to deploy your application to almost any serverless environment. Some of these adapters such as [`adapter-vercel`](adapter-vercel) and [`adapter-netlify`](adapter-netlify) offer an `edge` option, to support [edge rendering](glossary#Edge) for improved latency.\n\n## Your own server\n\nYou can deploy to your own server or VPS using [`adapter-node`](adapter-node).\n\n## Container\n\nYou can use [`adapter-node`](adapter-node) to run a SvelteKit app within a container such as Docker or LXC.\n\n## Library\n\nYou can create a library to be used by other Svelte apps with the [`@sveltejs/package`](packaging) add-on to SvelteKit by choosing the library option when running [`sv create`](/docs/cli/sv-create).\n\n## Offline app\n\nSvelteKit has full support for [service workers](service-workers) allowing you to build many types of applications such as offline apps and [progressive web apps](glossary#PWA).\n\n## Mobile app\n\nYou can turn a [SvelteKit SPA](single-page-apps) into a mobile app with [Tauri](https://v2.tauri.app/start/frontend/sveltekit/) or [Capacitor](https://capacitorjs.com/solution/svelte). Mobile features like the camera, geolocation, and push notifications are available via plugins for both platforms.\n\nThese mobile development platforms work by starting a local web server and then serving your application like a static host on your phone. You may find [`bundleStrategy: 'single'`](configuration#output) to be a helpful option to limit the number of requests made. E.g. at the time of writing, the Capacitor local server uses HTTP/1, which limits the number of concurrent connections.\n\n## Desktop app\n\nYou can turn a [SvelteKit SPA](single-page-apps) into a desktop app with [Tauri](https://v2.tauri.app/start/frontend/sveltekit/), [Wails](https://wails.io/docs/guides/sveltekit/), or [Electron](https://www.electronjs.org/).\n\n## Browser extension\n\nYou can build browser extensions using either [`adapter-static`](adapter-static) or [community adapters](/packages#sveltekit-adapters) specifically tailored towards browser extensions.\n\n## Embedded device\n\nBecause of its efficient rendering, Svelte can be run on low power devices. Embedded devices like microcontrollers and TVs may limit the number of concurrent connections. In order to reduce the number of concurrent requests, you may find [`bundleStrategy: 'single'`](configuration#output) to be a helpful option in this deployment configuration.\n","SvelteKit supports multiple rendering and deployment approaches:\n\n**Default rendering**: Server-side rendering (SSR) for initial page load (better SEO and perceived performance), then client-side rendering (CSR) for subsequent navigation (faster, no flash).\n\n**Static site generation**: Use adapter-static to prerender entire site, or use the prerender option for selective pages. Vercel adapter supports Incremental Static Regeneration (ISR) for large sites.\n\n**Single-page app (SPA)**: Client-side rendering only. Can use SvelteKit backend or separate backend in another language.\n\n**Multi-page app**: Remove JavaScript with `csr = false` for server-rendered links, or use `data-sveltekit-reload` for specific links.\n\n**Separate backend**: Deploy SvelteKit frontend separately using adapter-node or serverless adapters. Skip server files in docs if using external backend.\n\n**Serverless**: Use adapter-auto (zero config), adapter-vercel, adapter-netlify, adapter-cloudflare, or community adapters. Some support edge rendering.\n\n**Own server/VPS**: Use adapter-node.\n\n**Container**: Use adapter-node with Docker or LXC.\n\n**Library**: Use @sveltejs/package add-on with `sv create` library option.\n\n**Offline/PWA**: Full service worker support.\n\n**Mobile app**: Convert SPA to mobile with Tauri or Capacitor. Use `bundleStrategy: 'single'` to limit concurrent requests (useful for HTTP/1 limitations).\n\n**Desktop app**: Convert SPA to desktop with Tauri, Wails, or Electron.\n\n**Browser extension**: Use adapter-static or community adapters.\n\n**Embedded device**: Use `bundleStrategy: 'single'` to reduce concurrent requests on low-power devices.","SvelteKit supports multiple rendering modes: default (SSR + CSR), static site generation, SPAs, multi-page apps, and various deployment targets (serverless, own server, containers, mobile, desktop, browser extensions). Use adapter-node for own servers/containers, adapter-static for static generation, adapter-vercel/netlify/cloudflare for serverless. For mobile/embedded with HTTP/1 limits, use `bundleStrategy: 'single'`.","SvelteKit supports multiple rendering strategies and deployment targets through configurable adapters.","project-structure",{"name":75,"path":77,"children":78,"data":79},"getting-started/project-structure",["Map"],{"type":22,"path":80,"relevant":44,"token_counts":81,"usage":85,"markdown":88},"10-getting-started/30-project-structure.md",{"fulltext":82,"digest":83,"short_digest":84},1542,581,291,{"input":86,"output":87,"details":32},2587,973,{"fulltext":89,"digest":90,"short_digest":91,"essence":92},"---\ntitle: Project structure\n---\n\nA typical SvelteKit project looks like this:\n\n```tree\nmy-project/\n├ src/\n│ ├ lib/\n│ │ ├ server/\n│ │ │ └ [your server-only lib files]\n│ │ └ [your lib files]\n│ ├ params/\n│ │ └ [your param matchers]\n│ ├ routes/\n│ │ └ [your routes]\n│ ├ app.html\n│ ├ error.html\n│ ├ hooks.client.js\n│ ├ hooks.server.js\n│ ├ service-worker.js\n│ └ tracing.server.js\n├ static/\n│ └ [your static assets]\n├ tests/\n│ └ [your tests]\n├ package.json\n├ svelte.config.js\n├ tsconfig.json\n└ vite.config.js\n```\n\nYou'll also find common files like `.gitignore` and `.npmrc` (and `.prettierrc` and `eslint.config.js` and so on, if you chose those options when running `npx sv create`).\n\n## Project files\n\n### src\n\nThe `src` directory contains the meat of your project. Everything except `src/routes` and `src/app.html` is optional.\n\n- `lib` contains your library code (utilities and components), which can be imported via the [`$lib`]($lib) alias, or packaged up for distribution using [`svelte-package`](packaging)\n  - `server` contains your server-only library code. It can be imported by using the [`$lib/server`](server-only-modules) alias. SvelteKit will prevent you from importing these in client code.\n- `params` contains any [param matchers](advanced-routing#Matching) your app needs\n- `routes` contains the [routes](routing) of your application. You can also colocate other components that are only used within a single route here\n- `app.html` is your page template — an HTML document containing the following placeholders:\n  - `%sveltekit.head%` — `\u003Clink>` and `\u003Cscript>` elements needed by the app, plus any `\u003Csvelte:head>` content\n  - `%sveltekit.body%` — the markup for a rendered page. This should live inside a `\u003Cdiv>` or other element, rather than directly inside `\u003Cbody>`, to prevent bugs caused by browser extensions injecting elements that are then destroyed by the hydration process. SvelteKit will warn you in development if this is not the case\n  - `%sveltekit.assets%` — either [`paths.assets`](configuration#paths), if specified, or a relative path to [`paths.base`](configuration#paths)\n  - `%sveltekit.nonce%` — a [CSP](configuration#csp) nonce for manually included links and scripts, if used\n  - `%sveltekit.env.[NAME]%` - this will be replaced at render time with the `[NAME]` environment variable, which must begin with the [`publicPrefix`](configuration#env) (usually `PUBLIC_`). It will fallback to `''` if not matched.\n  - `%sveltekit.version%` — the app version, which can be specified with the [`version`](configuration#version) configuration\n- `error.html` is the page that is rendered when everything else fails. It can contain the following placeholders:\n  - `%sveltekit.status%` — the HTTP status\n  - `%sveltekit.error.message%` — the error message\n- `hooks.client.js` contains your client [hooks](hooks)\n- `hooks.server.js` contains your server [hooks](hooks)\n- `service-worker.js` contains your [service worker](service-workers)\n- `instrumentation.server.js` contains your [observability](observability) setup and instrumentation code\n  - Requires adapter support. If your adapter supports it, it is guarnteed to run prior to loading and running your application code.\n\n(Whether the project contains `.js` or `.ts` files depends on whether you opt to use TypeScript when you create your project.)\n\nIf you added [Vitest](https://vitest.dev) when you set up your project, your unit tests will live in the `src` directory with a `.test.js` extension.\n\n### static\n\nAny static assets that should be served as-is, like `robots.txt` or `favicon.png`, go in here.\n\n### tests\n\nIf you added [Playwright](https://playwright.dev/) for browser testing when you set up your project, the tests will live in this directory.\n\n### package.json\n\nYour `package.json` file must include `@sveltejs/kit`, `svelte` and `vite` as `devDependencies`.\n\nWhen you create a project with `npx sv create`, you'll also notice that `package.json` includes `\"type\": \"module\"`. This means that `.js` files are interpreted as native JavaScript modules with `import` and `export` keywords. Legacy CommonJS files need a `.cjs` file extension.\n\n### svelte.config.js\n\nThis file contains your Svelte and SvelteKit [configuration](configuration).\n\n### tsconfig.json\n\nThis file (or `jsconfig.json`, if you prefer type-checked `.js` files over `.ts` files) configures TypeScript, if you added typechecking during `npx sv create`. Since SvelteKit relies on certain configuration being set a specific way, it generates its own `.svelte-kit/tsconfig.json` file which your own config `extends`. To make changes to top-level options such as `include` and `exclude`, we recommend extending the generated config; see the [`typescript.config` setting](configuration#typescript) for more details.\n\n### vite.config.js\n\nA SvelteKit project is really just a [Vite](https://vitejs.dev) project that uses the [`@sveltejs/kit/vite`](@sveltejs-kit-vite) plugin, along with any other [Vite configuration](https://vitejs.dev/config/).\n\n## Other files\n\n### .svelte-kit\n\nAs you develop and build your project, SvelteKit will generate files in a `.svelte-kit` directory (configurable as [`outDir`](configuration#outDir)). You can ignore its contents, and delete them at any time (they will be regenerated when you next `dev` or `build`).\n","## Directory structure\n\nA SvelteKit project has the following layout:\n\n```\nmy-project/\n├ src/\n│ ├ lib/              # Library code, utilities, components (imported via $lib)\n│ │ └ server/         # Server-only code (imported via $lib/server)\n│ ├ params/           # Param matchers\n│ ├ routes/           # Application routes\n│ ├ app.html          # Page template\n│ ├ error.html        # Error page\n│ ├ hooks.client.js   # Client hooks\n│ ├ hooks.server.js   # Server hooks\n│ ├ service-worker.js # Service worker\n│ └ tracing.server.js # Observability setup\n├ static/             # Static assets (robots.txt, favicon.png, etc.)\n├ tests/              # Playwright browser tests\n├ package.json\n├ svelte.config.js\n├ tsconfig.json\n└ vite.config.js\n```\n\n## Key files\n\n**src/app.html** - Page template with placeholders:\n- `%sveltekit.head%` - Links and scripts\n- `%sveltekit.body%` - Rendered page markup (wrap in div, not directly in body)\n- `%sveltekit.assets%` - Asset path\n- `%sveltekit.nonce%` - CSP nonce\n- `%sveltekit.env.[NAME]%` - Environment variables (must start with PUBLIC_)\n- `%sveltekit.version%` - App version\n\n**src/error.html** - Error page with placeholders:\n- `%sveltekit.status%` - HTTP status\n- `%sveltekit.error.message%` - Error message\n\n**package.json** - Must include `@sveltejs/kit`, `svelte`, and `vite` as devDependencies. Uses `\"type\": \"module\"` for ES modules.\n\n**svelte.config.js** - Svelte and SvelteKit configuration\n\n**tsconfig.json** - TypeScript configuration (extends generated `.svelte-kit/tsconfig.json`)\n\n**vite.config.js** - Vite configuration using `@sveltejs/kit/vite` plugin\n\n## Generated files\n\n**.svelte-kit** - Auto-generated directory (can be deleted, regenerated on dev/build)","## Directory structure\n\n```\nsrc/\n├ lib/              # Library code ($lib alias)\n│ └ server/         # Server-only code ($lib/server alias)\n├ params/           # Param matchers\n├ routes/           # Routes\n├ app.html          # Page template\n├ error.html        # Error page\n├ hooks.client.js   # Client hooks\n├ hooks.server.js   # Server hooks\n├ service-worker.js # Service worker\n└ tracing.server.js # Observability\nstatic/             # Static assets\ntests/              # Playwright tests\n```\n\n**app.html** placeholders: `%sveltekit.head%`, `%sveltekit.body%`, `%sveltekit.assets%`, `%sveltekit.nonce%`, `%sveltekit.env.[NAME]%`, `%sveltekit.version%`\n\n**error.html** placeholders: `%sveltekit.status%`, `%sveltekit.error.message%`\n\n**package.json** requires `@sveltejs/kit`, `svelte`, `vite` as devDependencies with `\"type\": \"module\"`","Standard directory layout and configuration files for a SvelteKit project.","web-standards",{"name":93,"path":95,"children":96,"data":97},"getting-started/web-standards",["Map"],{"type":22,"path":98,"relevant":44,"token_counts":99,"usage":103,"markdown":106},"10-getting-started/40-web-standards.md",{"fulltext":100,"digest":101,"short_digest":102},1524,472,302,{"input":104,"output":105,"details":32},2569,900,{"fulltext":107,"digest":108,"short_digest":109,"essence":110},"---\ntitle: Web standards\n---\n\nThroughout this documentation, you'll see references to the standard [Web APIs](https://developer.mozilla.org/en-US/docs/Web/API) that SvelteKit builds on top of. Rather than reinventing the wheel, we _use the platform_, which means your existing web development skills are applicable to SvelteKit. Conversely, time spent learning SvelteKit will help you be a better web developer elsewhere.\n\nThese APIs are available in all modern browsers and in many non-browser environments like Cloudflare Workers, Deno, and Vercel Functions. During development, and in [adapters](adapters) for Node-based environments (including AWS Lambda), they're made available via polyfills where necessary (for now, that is — Node is rapidly adding support for more web standards).\n\nIn particular, you'll get comfortable with the following:\n\n## Fetch APIs\n\nSvelteKit uses [`fetch`](https://developer.mozilla.org/en-US/docs/Web/API/fetch) for getting data from the network. It's available in [hooks](hooks) and [server routes](routing#server) as well as in the browser.\n\n> [!NOTE] A special version of `fetch` is available in [`load`](load) functions, [server hooks](hooks#Server-hooks) and [API routes](routing#server) for invoking endpoints directly during server-side rendering, without making an HTTP call, while preserving credentials. (To make credentialled fetches in server-side code outside `load`, you must explicitly pass `cookie` and/or `authorization` headers.) It also allows you to make relative requests, whereas server-side `fetch` normally requires a fully qualified URL.\n\nBesides `fetch` itself, the [Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) includes the following interfaces:\n\n### Request\n\nAn instance of [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) is accessible in [hooks](hooks) and [server routes](routing#server) as `event.request`. It contains useful methods like `request.json()` and `request.formData()` for getting data that was posted to an endpoint.\n\n### Response\n\nAn instance of [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) is returned from `await fetch(...)` and handlers in `+server.js` files. Fundamentally, a SvelteKit app is a machine for turning a `Request` into a `Response`.\n\n### Headers\n\nThe [`Headers`](https://developer.mozilla.org/en-US/docs/Web/API/Headers) interface allows you to read incoming `request.headers` and set outgoing `response.headers`. For example, you can get the `request.headers` as shown below, and use the [`json` convenience function](@sveltejs-kit#json) to send modified `response.headers`:\n\n```js\n// @errors: 2461\n/// file: src/routes/what-is-my-user-agent/+server.js\nimport { json } from '@sveltejs/kit';\n\n/** @type {import('./$types').RequestHandler} */\nexport function GET({ request }) {\n\t// log all headers\n\tconsole.log(...request.headers);\n\n\t// create a JSON Response using a header we received\n\treturn json({\n\t\t// retrieve a specific header\n\t\tuserAgent: request.headers.get('user-agent')\n\t}, {\n\t\t// set a header on the response\n\t\theaders: { 'x-custom-header': 'potato' }\n\t});\n}\n```\n\n## FormData\n\nWhen dealing with HTML native form submissions you'll be working with [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) objects.\n\n```js\n// @errors: 2461\n/// file: src/routes/hello/+server.js\nimport { json } from '@sveltejs/kit';\n\n/** @type {import('./$types').RequestHandler} */\nexport async function POST(event) {\n\tconst body = await event.request.formData();\n\n\t// log all fields\n\tconsole.log([...body]);\n\n\treturn json({\n\t\t// get a specific field's value\n\t\tname: body.get('name') ?? 'world'\n\t});\n}\n```\n\n## Stream APIs\n\nMost of the time, your endpoints will return complete data, as in the `userAgent` example above. Sometimes, you may need to return a response that's too large to fit in memory in one go, or is delivered in chunks, and for this the platform provides [streams](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API) — [ReadableStream](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream), [WritableStream](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream) and [TransformStream](https://developer.mozilla.org/en-US/docs/Web/API/TransformStream).\n\n## URL APIs\n\nURLs are represented by the [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL) interface, which includes useful properties like `origin` and `pathname` (and, in the browser, `hash`). This interface shows up in various places — `event.url` in [hooks](hooks) and [server routes](routing#server), [`page.url`]($app-state) in [pages](routing#page), `from` and `to` in [`beforeNavigate` and `afterNavigate`]($app-navigation) and so on.\n\n### URLSearchParams\n\nWherever you encounter a URL, you can access query parameters via `url.searchParams`, which is an instance of [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams):\n\n```js\n// @filename: ambient.d.ts\ndeclare global {\n\tconst url: URL;\n}\n\nexport {};\n\n// @filename: index.js\n// ---cut---\nconst foo = url.searchParams.get('foo');\n```\n\n## Web Crypto\n\nThe [Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API) is made available via the `crypto` global. It's used internally for [Content Security Policy](configuration#csp) headers, but you can also use it for things like generating UUIDs:\n\n```js\nconst uuid = crypto.randomUUID();\n```\n","SvelteKit builds on standard Web APIs available in modern browsers and non-browser environments like Cloudflare Workers, Deno, and Vercel Functions. Polyfills are provided during development and in Node-based adapters.\n\n**Fetch APIs**: The `fetch` function is available in hooks, server routes, and the browser. A special version in `load` functions, server hooks, and API routes allows invoking endpoints directly during server-side rendering without HTTP calls while preserving credentials. Server-side `fetch` outside `load` requires explicit `cookie` and/or `authorization` headers. Relative requests are supported in these special contexts.\n\n**Request**: Accessible as `event.request` in hooks and server routes. Provides methods like `request.json()` and `request.formData()` for extracting posted data.\n\n**Response**: Returned from `await fetch(...)` and handlers in `+server.js` files. A SvelteKit app fundamentally transforms a `Request` into a `Response`.\n\n**Headers**: Read incoming `request.headers` and set outgoing `response.headers`:\n```js\nexport function GET({ request }) {\n\tconsole.log(...request.headers);\n\treturn json({ userAgent: request.headers.get('user-agent') }, \n\t\t{ headers: { 'x-custom-header': 'potato' } });\n}\n```\n\n**FormData**: Handle HTML form submissions with `FormData` objects:\n```js\nexport async function POST(event) {\n\tconst body = await event.request.formData();\n\treturn json({ name: body.get('name') ?? 'world' });\n}\n```\n\n**Stream APIs**: Use ReadableStream, WritableStream, and TransformStream for large or chunked responses.\n\n**URL APIs**: URLs use the `URL` interface with properties like `origin` and `pathname`. Access query parameters via `url.searchParams` (URLSearchParams instance).\n\n**Web Crypto**: Available via the `crypto` global for operations like generating UUIDs: `crypto.randomUUID()`.","SvelteKit uses standard Web APIs available in modern browsers and environments like Cloudflare Workers and Deno.\n\n**Fetch**: Available in hooks, server routes, and browser. Special version in `load` functions and server hooks allows direct endpoint invocation during SSR without HTTP calls.\n\n**Request/Response**: `event.request` in hooks/routes provides `json()` and `formData()` methods. Responses returned from `+server.js` handlers.\n\n**Headers**: Read `request.headers` and set `response.headers`:\n```js\nexport function GET({ request }) {\n\treturn json({ userAgent: request.headers.get('user-agent') }, \n\t\t{ headers: { 'x-custom-header': 'potato' } });\n}\n```\n\n**FormData**: Handle form submissions:\n```js\nexport async function POST(event) {\n\tconst body = await event.request.formData();\n\treturn json({ name: body.get('name') ?? 'world' });\n}\n```\n\n**Streams**: ReadableStream, WritableStream, TransformStream for large/chunked responses.\n\n**URL/URLSearchParams**: Access query parameters via `url.searchParams.get('foo')`.\n\n**Web Crypto**: `crypto.randomUUID()` and other operations.","SvelteKit builds on standard Web APIs (Fetch, Request, Response, Headers, FormData, Streams, URL, Web Crypto) available across modern browsers and server environments.",{"name":14,"path":112,"children":113,"data":114},"getting-started/getting-started",["Map"],{"type":22,"path":115,"relevant":24,"token_counts":116,"usage":120,"markdown":123},"10-getting-started/index.md",{"fulltext":117,"digest":118,"short_digest":119},15,46,19,{"input":121,"output":122,"details":32},1056,159,{"fulltext":124,"digest":125,"short_digest":126,"essence":127},"---\ntitle: Getting started\n---\n","This page serves as the entry point for the documentation. It provides an overview and introduction to getting started with the framework, likely covering initial setup, installation, and basic concepts needed to begin development.","Entry point documentation for initial setup and introduction to the framework.","Introduction and starting point for framework documentation.",{"type":129,"path":130,"relevant":44,"token_counts":131,"usage":134,"markdown":137},"directory","10-getting-started",{"fulltext":132,"digest":26,"short_digest":133},865,259,{"input":135,"output":136,"details":32},1955,1053,{"fulltext":138,"digest":139,"short_digest":140,"essence":141},"\n\n## Pages\n\n### creating-a-project\nHow to create a new SvelteKit project and understand its basic structure.\n\nRun `npx sv create my-app` to scaffold a project, then `npm run dev` to start the dev server on localhost:5173. Pages are Svelte components in `src/routes` that are server-rendered initially, then client-side.\n\n### project-types\nSvelteKit supports multiple rendering strategies and deployment targets through configurable adapters.\n\nSvelteKit supports multiple rendering modes: default (SSR + CSR), static site generation, SPAs, multi-page apps, and various deployment targets (serverless, own server, containers, mobile, desktop, browser extensions). Use adapter-node for own servers/containers, adapter-static for static generation, adapter-vercel/netlify/cloudflare for serverless. For mobile/embedded with HTTP/1 limits, use `bundleStrategy: 'single'`.\n\n### project-structure\nStandard directory layout and configuration files for a SvelteKit project.\n\n## Directory structure\n\n```\nsrc/\n├ lib/              # Library code ($lib alias)\n│ └ server/         # Server-only code ($lib/server alias)\n├ params/           # Param matchers\n├ routes/           # Routes\n├ app.html          # Page template\n├ error.html        # Error page\n├ hooks.client.js   # Client hooks\n├ hooks.server.js   # Server hooks\n├ service-worker.js # Service worker\n└ tracing.server.js # Observability\nstatic/             # Static assets\ntests/              # Playwright tests\n```\n\n**app.html** placeholders: `%sveltekit.head%`, `%sveltekit.body%`, `%sveltekit.assets%`, `%sveltekit.nonce%`, `%sveltekit.env.[NAME]%`, `%sveltekit.version%`\n\n**error.html** placeholders: `%sveltekit.status%`, `%sveltekit.error.message%`\n\n**package.json** requires `@sveltejs/kit`, `svelte`, `vite` as devDependencies with `\"type\": \"module\"`\n\n### web-standards\nSvelteKit builds on standard Web APIs (Fetch, Request, Response, Headers, FormData, Streams, URL, Web Crypto) available across modern browsers and server environments.\n\nSvelteKit uses standard Web APIs available in modern browsers and environments like Cloudflare Workers and Deno.\n\n**Fetch**: Available in hooks, server routes, and browser. Special version in `load` functions and server hooks allows direct endpoint invocation during SSR without HTTP calls.\n\n**Request/Response**: `event.request` in hooks/routes provides `json()` and `formData()` methods. Responses returned from `+server.js` handlers.\n\n**Headers**: Read `request.headers` and set `response.headers`:\n```js\nexport function GET({ request }) {\n\treturn json({ userAgent: request.headers.get('user-agent') }, \n\t\t{ headers: { 'x-custom-header': 'potato' } });\n}\n```\n\n**FormData**: Handle form submissions:\n```js\nexport async function POST(event) {\n\tconst body = await event.request.formData();\n\treturn json({ name: body.get('name') ?? 'world' });\n}\n```\n\n**Streams**: ReadableStream, WritableStream, TransformStream for large/chunked responses.\n\n**URL/URLSearchParams**: Access query parameters via `url.searchParams.get('foo')`.\n\n**Web Crypto**: `crypto.randomUUID()` and other operations.\n\n","## Creating a Project\n\nRun `npx sv create my-app` to scaffold a project, then `npm run dev` to start the dev server on localhost:5173.\n\n## Project Structure\n\n```\nsrc/\n├ lib/              # Library code ($lib alias)\n│ └ server/         # Server-only code ($lib/server alias)\n├ params/           # Param matchers\n├ routes/           # Routes (Svelte components, server-rendered then client-side)\n├ app.html          # Page template with placeholders: %sveltekit.head%, %sveltekit.body%, %sveltekit.assets%, %sveltekit.nonce%, %sveltekit.env.[NAME]%, %sveltekit.version%\n├ error.html        # Error page with placeholders: %sveltekit.status%, %sveltekit.error.message%\n├ hooks.client.js   # Client hooks\n├ hooks.server.js   # Server hooks\n├ service-worker.js # Service worker\n└ tracing.server.js # Observability\nstatic/             # Static assets\ntests/              # Playwright tests\n```\n\n**package.json** requires `@sveltejs/kit`, `svelte`, `vite` as devDependencies with `\"type\": \"module\"`.\n\n## Rendering Modes & Deployment\n\nSvelteKit supports: SSR + CSR (default), static site generation, SPAs, and multi-page apps. Adapters configure deployment targets:\n- `adapter-node` for own servers/containers\n- `adapter-static` for static generation\n- `adapter-vercel`, `adapter-netlify`, `adapter-cloudflare` for serverless\n- For HTTP/1 limits (mobile/embedded), use `bundleStrategy: 'single'`\n\n## Web Standards\n\nSvelteKit uses standard Web APIs: Fetch, Request/Response, Headers, FormData, Streams, URL, Web Crypto.\n\n**Fetch**: Available in hooks, server routes, and browser. Special version in `load` functions and server hooks allows direct endpoint invocation during SSR without HTTP calls.\n\n**Request/Response/Headers**:\n```js\nexport function GET({ request }) {\n\treturn json({ userAgent: request.headers.get('user-agent') }, \n\t\t{ headers: { 'x-custom-header': 'potato' } });\n}\n```\n\n**FormData**:\n```js\nexport async function POST(event) {\n\tconst body = await event.request.formData();\n\treturn json({ name: body.get('name') ?? 'world' });\n}\n```\n\n**Streams**: ReadableStream, WritableStream, TransformStream for large/chunked responses.\n\n**URL/URLSearchParams**: Access query parameters via `url.searchParams.get('foo')`.\n\n**Web Crypto**: `crypto.randomUUID()` and other operations.","## Quick Start\n\nRun `npx sv create my-app` then `npm run dev` (localhost:5173).\n\n## Project Structure\n\n```\nsrc/\n├ lib/              # Library code ($lib alias)\n├ routes/           # Pages (Svelte components)\n├ app.html          # Page template\n├ error.html        # Error page\n├ hooks.client.js   # Client hooks\n├ hooks.server.js   # Server hooks\nstatic/             # Static assets\n```\n\n## Deployment\n\nAdapters configure rendering and deployment: `adapter-node` (own servers), `adapter-static` (static), `adapter-vercel/netlify/cloudflare` (serverless).\n\n## Web APIs\n\nSvelteKit uses standard Web APIs: Fetch, Request/Response, Headers, FormData, Streams, URL, Web Crypto.\n\n```js\nexport function GET({ request }) {\n\treturn json({ userAgent: request.headers.get('user-agent') }, \n\t\t{ headers: { 'x-custom-header': 'potato' } });\n}\n```","Setup, project structure, deployment adapters, and standard Web APIs for building SvelteKit applications.","core-concepts",{"name":142,"path":142,"children":144,"data":268},["Map",145,146,163,164,181,182,199,200,217,218,235,236,142,253],"routing",{"name":145,"path":147,"children":148,"data":149},"core-concepts/routing",["Map"],{"type":22,"path":150,"relevant":44,"token_counts":151,"usage":155,"markdown":158},"20-core-concepts/10-routing.md",{"fulltext":152,"digest":153,"short_digest":154},5158,839,117,{"input":156,"output":157,"details":32},6201,1067,{"fulltext":159,"digest":160,"short_digest":161,"essence":162},"---\ntitle: Routing\n---\n\nAt the heart of SvelteKit is a _filesystem-based router_. The routes of your app — i.e. the URL paths that users can access — are defined by the directories in your codebase:\n\n- `src/routes` is the root route\n- `src/routes/about` creates an `/about` route\n- `src/routes/blog/[slug]` creates a route with a _parameter_, `slug`, that can be used to load data dynamically when a user requests a page like `/blog/hello-world`\n\n> [!NOTE] You can change `src/routes` to a different directory by editing the [project config](configuration).\n\nEach route directory contains one or more _route files_, which can be identified by their `+` prefix.\n\nWe'll introduce these files in a moment in more detail, but here are a few simple rules to help you remember how SvelteKit's routing works:\n\n* All files can run on the server\n* All files run on the client except `+server` files\n* `+layout` and `+error` files apply to subdirectories as well as the directory they live in\n\n## +page\n\n### +page.svelte\n\nA `+page.svelte` component defines a page of your app. By default, pages are rendered both on the server ([SSR](glossary#SSR)) for the initial request and in the browser ([CSR](glossary#CSR)) for subsequent navigation.\n\n```svelte\n\u003C!--- file: src/routes/+page.svelte --->\n\u003Ch1>Hello and welcome to my site!\u003C/h1>\n\u003Ca href=\"/about\">About my site\u003C/a>\n```\n\n```svelte\n\u003C!--- file: src/routes/about/+page.svelte --->\n\u003Ch1>About this site\u003C/h1>\n\u003Cp>TODO...\u003C/p>\n\u003Ca href=\"/\">Home\u003C/a>\n```\n\n> [!NOTE] SvelteKit uses `\u003Ca>` elements to navigate between routes, rather than a framework-specific `\u003CLink>` component.\n\nPages can receive data from `load` functions via the `data` prop.\n\n```svelte\n\u003C!--- file: src/routes/blog/[slug]/+page.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\u003C/script>\n\n\u003Ch1>{data.title}\u003C/h1>\n\u003Cdiv>{@html data.content}\u003C/div>\n```\n\n> [!LEGACY]\n> `PageProps` was added in 2.16.0. In earlier versions, you had to type the `data` property manually with `PageData` instead, see [$types](#\\$types).\n>\n> In Svelte 4, you'd use `export let data` instead.\n\n### +page.js\n\nOften, a page will need to load some data before it can be rendered. For this, we add a `+page.js` module that exports a `load` function:\n\n```js\n/// file: src/routes/blog/[slug]/+page.js\nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').PageLoad} */\nexport function load({ params }) {\n\tif (params.slug === 'hello-world') {\n\t\treturn {\n\t\t\ttitle: 'Hello world!',\n\t\t\tcontent: 'Welcome to our blog. Lorem ipsum dolor sit amet...'\n\t\t};\n\t}\n\n\terror(404, 'Not found');\n}\n```\n\nThis function runs alongside `+page.svelte`, which means it runs on the server during server-side rendering and in the browser during client-side navigation. See [`load`](load) for full details of the API.\n\nAs well as `load`, `+page.js` can export values that configure the page's behaviour:\n\n- `export const prerender = true` or `false` or `'auto'`\n- `export const ssr = true` or `false`\n- `export const csr = true` or `false`\n\nYou can find more information about these in [page options](page-options).\n\n### +page.server.js\n\nIf your `load` function can only run on the server — for example, if it needs to fetch data from a database or you need to access private [environment variables]($env-static-private) like API keys — then you can rename `+page.js` to `+page.server.js` and change the `PageLoad` type to `PageServerLoad`.\n\n```js\n/// file: src/routes/blog/[slug]/+page.server.js\n\n// @filename: ambient.d.ts\ndeclare global {\n\tconst getPostFromDatabase: (slug: string) => {\n\t\ttitle: string;\n\t\tcontent: string;\n\t}\n}\n\nexport {};\n\n// @filename: index.js\n// ---cut---\nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\tconst post = await getPostFromDatabase(params.slug);\n\n\tif (post) {\n\t\treturn post;\n\t}\n\n\terror(404, 'Not found');\n}\n```\n\nDuring client-side navigation, SvelteKit will load this data from the server, which means that the returned value must be serializable using [devalue](https://github.com/rich-harris/devalue). See [`load`](load) for full details of the API.\n\nLike `+page.js`, `+page.server.js` can export [page options](page-options) — `prerender`, `ssr` and `csr`.\n\nA `+page.server.js` file can also export _actions_. If `load` lets you read data from the server, `actions` let you write data _to_ the server using the `\u003Cform>` element. To learn how to use them, see the [form actions](form-actions) section.\n\n## +error\n\nIf an error occurs during `load`, SvelteKit will render a default error page. You can customise this error page on a per-route basis by adding an `+error.svelte` file:\n\n```svelte\n\u003C!--- file: src/routes/blog/[slug]/+error.svelte --->\n\u003Cscript>\n\timport { page } from '$app/state';\n\u003C/script>\n\n\u003Ch1>{page.status}: {page.error.message}\u003C/h1>\n```\n\n> [!LEGACY]\n> `$app/state` was added in SvelteKit 2.12. If you're using an earlier version or are using Svelte 4, use `$app/stores` instead.\n\nSvelteKit will 'walk up the tree' looking for the closest error boundary — if the file above didn't exist it would try `src/routes/blog/+error.svelte` and then `src/routes/+error.svelte` before rendering the default error page. If _that_ fails (or if the error was thrown from the `load` function of the root `+layout`, which sits 'above' the root `+error`), SvelteKit will bail out and render a static fallback error page, which you can customise by creating a `src/error.html` file.\n\nIf the error occurs inside a `load` function in `+layout(.server).js`, the closest error boundary in the tree is an `+error.svelte` file _above_ that layout (not next to it).\n\nIf no route can be found (404), `src/routes/+error.svelte` (or the default error page, if that file does not exist) will be used.\n\n> [!NOTE] `+error.svelte` is _not_ used when an error occurs inside [`handle`](hooks#Server-hooks-handle) or a [+server.js](#server) request handler.\n\nYou can read more about error handling [here](errors).\n\n## +layout\n\nSo far, we've treated pages as entirely standalone components — upon navigation, the existing `+page.svelte` component will be destroyed, and a new one will take its place.\n\nBut in many apps, there are elements that should be visible on _every_ page, such as top-level navigation or a footer. Instead of repeating them in every `+page.svelte`, we can put them in _layouts_.\n\n### +layout.svelte\n\nTo create a layout that applies to every page, make a file called `src/routes/+layout.svelte`. The default layout (the one that SvelteKit uses if you don't bring your own) looks like this...\n\n```svelte\n\u003Cscript>\n\tlet { children } = $props();\n\u003C/script>\n\n{@render children()}\n```\n\n...but we can add whatever markup, styles and behaviour we want. The only requirement is that the component includes a `@render` tag for the page content. For example, let's add a nav bar:\n\n```svelte\n\u003C!--- file: src/routes/+layout.svelte --->\n\u003Cscript>\n\tlet { children } = $props();\n\u003C/script>\n\n\u003Cnav>\n\t\u003Ca href=\"/\">Home\u003C/a>\n\t\u003Ca href=\"/about\">About\u003C/a>\n\t\u003Ca href=\"/settings\">Settings\u003C/a>\n\u003C/nav>\n\n{@render children()}\n```\n\nIf we create pages for `/`, `/about` and `/settings`...\n\n```html\n/// file: src/routes/+page.svelte\n\u003Ch1>Home\u003C/h1>\n```\n\n```html\n/// file: src/routes/about/+page.svelte\n\u003Ch1>About\u003C/h1>\n```\n\n```html\n/// file: src/routes/settings/+page.svelte\n\u003Ch1>Settings\u003C/h1>\n```\n\n...the nav will always be visible, and clicking between the three pages will only result in the `\u003Ch1>` being replaced.\n\nLayouts can be _nested_. Suppose we don't just have a single `/settings` page, but instead have nested pages like `/settings/profile` and `/settings/notifications` with a shared submenu (for a real-life example, see [github.com/settings](https://github.com/settings)).\n\nWe can create a layout that only applies to pages below `/settings` (while inheriting the root layout with the top-level nav):\n\n```svelte\n\u003C!--- file: src/routes/settings/+layout.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').LayoutProps} */\n\tlet { data, children } = $props();\n\u003C/script>\n\n\u003Ch1>Settings\u003C/h1>\n\n\u003Cdiv class=\"submenu\">\n\t{#each data.sections as section}\n\t\t\u003Ca href=\"/settings/{section.slug}\">{section.title}\u003C/a>\n\t{/each}\n\u003C/div>\n\n{@render children()}\n```\n\n> [!LEGACY]\n> `LayoutProps` was added in 2.16.0. In earlier versions, you had to [type the properties manually instead](#\\$types).\n\nYou can see how `data` is populated by looking at the `+layout.js` example in the next section just below.\n\nBy default, each layout inherits the layout above it. Sometimes that isn't what you want - in this case, [advanced layouts](advanced-routing#Advanced-layouts) can help you.\n\n### +layout.js\n\nJust like `+page.svelte` loading data from `+page.js`, your `+layout.svelte` component can get data from a [`load`](load) function in `+layout.js`.\n\n```js\n/// file: src/routes/settings/+layout.js\n/** @type {import('./$types').LayoutLoad} */\nexport function load() {\n\treturn {\n\t\tsections: [\n\t\t\t{ slug: 'profile', title: 'Profile' },\n\t\t\t{ slug: 'notifications', title: 'Notifications' }\n\t\t]\n\t};\n}\n```\n\nIf a `+layout.js` exports [page options](page-options) — `prerender`, `ssr` and `csr` — they will be used as defaults for child pages.\n\nData returned from a layout's `load` function is also available to all its child pages:\n\n```svelte\n\u003C!--- file: src/routes/settings/profile/+page.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\n\tconsole.log(data.sections); // [{ slug: 'profile', title: 'Profile' }, ...]\n\u003C/script>\n```\n\n> [!NOTE] Often, layout data is unchanged when navigating between pages. SvelteKit will intelligently rerun [`load`](load) functions when necessary.\n\n### +layout.server.js\n\nTo run your layout's `load` function on the server, move it to `+layout.server.js`, and change the `LayoutLoad` type to `LayoutServerLoad`.\n\nLike `+layout.js`, `+layout.server.js` can export [page options](page-options) — `prerender`, `ssr` and `csr`.\n\n## +server\n\nAs well as pages, you can define routes with a `+server.js` file (sometimes referred to as an 'API route' or an 'endpoint'), which gives you full control over the response. Your `+server.js` file exports functions corresponding to HTTP verbs like `GET`, `POST`, `PATCH`, `PUT`, `DELETE`, `OPTIONS`, and `HEAD` that take a [`RequestEvent`](@sveltejs-kit#RequestEvent) argument and return a [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) object.\n\nFor example we could create an `/api/random-number` route with a `GET` handler:\n\n```js\n/// file: src/routes/api/random-number/+server.js\nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').RequestHandler} */\nexport function GET({ url }) {\n\tconst min = Number(url.searchParams.get('min') ?? '0');\n\tconst max = Number(url.searchParams.get('max') ?? '1');\n\n\tconst d = max - min;\n\n\tif (isNaN(d) || d \u003C 0) {\n\t\terror(400, 'min and max must be numbers, and min must be less than max');\n\t}\n\n\tconst random = min + Math.random() * d;\n\n\treturn new Response(String(random));\n}\n```\n\nThe first argument to `Response` can be a [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream), making it possible to stream large amounts of data or create server-sent events (unless deploying to platforms that buffer responses, like AWS Lambda).\n\nYou can use the [`error`](@sveltejs-kit#error), [`redirect`](@sveltejs-kit#redirect) and [`json`](@sveltejs-kit#json) methods from `@sveltejs/kit` for convenience (but you don't have to).\n\nIf an error is thrown (either `error(...)` or an unexpected error), the response will be a JSON representation of the error or a fallback error page — which can be customised via `src/error.html` — depending on the `Accept` header. The [`+error.svelte`](#error) component will _not_ be rendered in this case. You can read more about error handling [here](errors).\n\n> [!NOTE] When creating an `OPTIONS` handler, note that Vite will inject `Access-Control-Allow-Origin` and `Access-Control-Allow-Methods` headers — these will not be present in production unless you add them.\n\n> [!NOTE] `+layout` files have no effect on `+server.js` files. If you want to run some logic before each request, add it to the server [`handle`](hooks#Server-hooks-handle) hook.\n\n### Receiving data\n\nBy exporting `POST`/`PUT`/`PATCH`/`DELETE`/`OPTIONS`/`HEAD` handlers, `+server.js` files can be used to create a complete API:\n\n```svelte\n\u003C!--- file: src/routes/add/+page.svelte --->\n\u003Cscript>\n\tlet a = 0;\n\tlet b = 0;\n\tlet total = 0;\n\n\tasync function add() {\n\t\tconst response = await fetch('/api/add', {\n\t\t\tmethod: 'POST',\n\t\t\tbody: JSON.stringify({ a, b }),\n\t\t\theaders: {\n\t\t\t\t'content-type': 'application/json'\n\t\t\t}\n\t\t});\n\n\t\ttotal = await response.json();\n\t}\n\u003C/script>\n\n\u003Cinput type=\"number\" bind:value={a}> +\n\u003Cinput type=\"number\" bind:value={b}> =\n{total}\n\n\u003Cbutton onclick={add}>Calculate\u003C/button>\n```\n\n```js\n/// file: src/routes/api/add/+server.js\nimport { json } from '@sveltejs/kit';\n\n/** @type {import('./$types').RequestHandler} */\nexport async function POST({ request }) {\n\tconst { a, b } = await request.json();\n\treturn json(a + b);\n}\n```\n\n> [!NOTE] In general, [form actions](form-actions) are a better way to submit data from the browser to the server.\n\n> [!NOTE] If a `GET` handler is exported, a `HEAD` request will return the `content-length` of the `GET` handler's response body.\n\n### Fallback method handler\n\nExporting the `fallback` handler will match any unhandled request methods, including methods like `MOVE` which have no dedicated export from `+server.js`.\n\n```js\n/// file: src/routes/api/add/+server.js\nimport { json, text } from '@sveltejs/kit';\n\n/** @type {import('./$types').RequestHandler} */\nexport async function POST({ request }) {\n\tconst { a, b } = await request.json();\n\treturn json(a + b);\n}\n\n// This handler will respond to PUT, PATCH, DELETE, etc.\n/** @type {import('./$types').RequestHandler} */\nexport async function fallback({ request }) {\n\treturn text(`I caught your ${request.method} request!`);\n}\n```\n\n> [!NOTE] For `HEAD` requests, the `GET` handler takes precedence over the `fallback` handler.\n\n### Content negotiation\n\n`+server.js` files can be placed in the same directory as `+page` files, allowing the same route to be either a page or an API endpoint. To determine which, SvelteKit applies the following rules:\n\n- `PUT`/`PATCH`/`DELETE`/`OPTIONS` requests are always handled by `+server.js` since they do not apply to pages\n- `GET`/`POST`/`HEAD` requests are treated as page requests if the `accept` header prioritises `text/html` (in other words, it's a browser page request), else they are handled by `+server.js`.\n- Responses to `GET` requests will include a `Vary: Accept` header, so that proxies and browsers cache HTML and JSON responses separately.\n\n## $types\n\nThroughout the examples above, we've been importing types from a `$types.d.ts` file. This is a file SvelteKit creates for you in a hidden directory if you're using TypeScript (or JavaScript with JSDoc type annotations) to give you type safety when working with your root files.\n\nFor example, annotating `let { data } = $props()` with `PageProps` (or `LayoutProps`, for a `+layout.svelte` file) tells TypeScript that the type of `data` is whatever was returned from `load`:\n\n```svelte\n\u003C!--- file: src/routes/blog/[slug]/+page.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\u003C/script>\n```\n\n> [!NOTE]\n> The `PageProps` and `LayoutProps` types, added in 2.16.0, are a shortcut for typing the `data` prop as `PageData` or `LayoutData`, as well as other props, such as `form` for pages, or `children` for layouts. In earlier versions, you had to type these properties manually. For example, for a page:\n>\n> ```js\n> /// file: +page.svelte\n> /** @type {{ data: import('./$types').PageData, form: import('./$types').ActionData }} */\n> let { data, form } = $props();\n> ```\n>\n> Or, for a layout:\n>\n> ```js\n> /// file: +layout.svelte\n> /** @type {{ data: import('./$types').LayoutData, children: Snippet }} */\n> let { data, children } = $props();\n> ```\n\nIn turn, annotating the `load` function with `PageLoad`, `PageServerLoad`, `LayoutLoad` or `LayoutServerLoad` (for `+page.js`, `+page.server.js`, `+layout.js` and `+layout.server.js` respectively) ensures that `params` and the return value are correctly typed.\n\nIf you're using VS Code or any IDE that supports the language server protocol and TypeScript plugins then you can omit these types _entirely_! Svelte's IDE tooling will insert the correct types for you, so you'll get type checking without writing them yourself. It also works with our command line tool `svelte-check`.\n\nYou can read more about omitting `$types` in our [blog post](/blog/zero-config-type-safety) about it.\n\n## Other files\n\nAny other files inside a route directory are ignored by SvelteKit. This means you can colocate components and utility modules with the routes that need them.\n\nIf components and modules are needed by multiple routes, it's a good idea to put them in [`$lib`]($lib).\n\n## Further reading\n\n- [Tutorial: Routing](/tutorial/kit/pages)\n- [Tutorial: API routes](/tutorial/kit/get-handlers)\n- [Docs: Advanced routing](advanced-routing)\n","## Filesystem-based routing\n\nRoutes are defined by directory structure in `src/routes`:\n- `src/routes` → `/`\n- `src/routes/about` → `/about`\n- `src/routes/blog/[slug]` → `/blog/:slug` (dynamic parameter)\n\n## Route files (identified by `+` prefix)\n\n**Rules:**\n- All files can run on server\n- All files run on client except `+server` files\n- `+layout` and `+error` files apply to subdirectories and their own directory\n\n## +page.svelte / +page.js / +page.server.js\n\n`+page.svelte` defines a page component. Pages render on server (SSR) initially, then in browser (CSR) for navigation.\n\n`+page.js` exports a `load` function that runs on both server and client:\n```js\nexport function load({ params }) {\n\treturn { title: 'Hello', content: 'Welcome...' };\n}\n```\n\n`+page.server.js` is for server-only load functions (database access, private env vars). Data is serialized via devalue for client-side navigation.\n\nBoth can export page options: `prerender`, `ssr`, `csr`.\n\n`+page.server.js` can also export `actions` for form submissions.\n\n## +error.svelte\n\nCustomizes error pages. SvelteKit walks up the tree to find the closest error boundary. If none exists, renders default error page (customizable via `src/error.html`).\n\n## +layout.svelte / +layout.js / +layout.server.js\n\n`+layout.svelte` wraps pages with shared markup (nav, footer). Must include `{@render children()}` for page content.\n\nLayouts can be nested. Child layouts inherit parent layouts.\n\n`+layout.js` exports `load` function providing data to layout and all child pages:\n```js\nexport function load() {\n\treturn { sections: [{ slug: 'profile', title: 'Profile' }] };\n}\n```\n\n`+layout.server.js` for server-only load functions.\n\nLayout `load` functions are intelligently rerun only when necessary.\n\n## +server.js\n\nAPI routes. Export HTTP verb handlers (`GET`, `POST`, `PATCH`, `PUT`, `DELETE`, `OPTIONS`, `HEAD`) that receive `RequestEvent` and return `Response`:\n```js\nexport function GET({ url }) {\n\tconst min = Number(url.searchParams.get('min') ?? '0');\n\treturn new Response(String(min + Math.random()));\n}\n```\n\nCan export `fallback` handler for unhandled methods.\n\nUse `error()`, `redirect()`, `json()` helpers from `@sveltejs/kit`.\n\nErrors return JSON or fallback error page (not `+error.svelte`).\n\n**Content negotiation:** When `+server.js` and `+page` coexist:\n- `PUT`/`PATCH`/`DELETE`/`OPTIONS` → always `+server.js`\n- `GET`/`POST`/`HEAD` → `+server.js` if `accept` header doesn't prioritize `text/html`, else page request\n- `GET` responses include `Vary: Accept` header\n\n## $types\n\nSvelteKit generates `$types.d.ts` for type safety. Use `PageProps`/`LayoutProps` for component props, `PageLoad`/`PageServerLoad`/`LayoutLoad`/`LayoutServerLoad` for load functions. IDE tooling can auto-insert these types.","Routes defined by `src/routes` directory structure with `+` prefixed files. `+page.svelte` for pages, `+page.js`/`+page.server.js` for load functions, `+layout.svelte` for shared markup, `+server.js` for API endpoints, `+error.svelte` for error pages. Load functions run on server/client or server-only. `+server.js` exports HTTP handlers. Use `$types` for type safety.","Filesystem-based routing with special `+` prefixed files for pages, layouts, API endpoints, and error handling.","loading-data",{"name":163,"path":165,"children":166,"data":167},"core-concepts/loading-data",["Map"],{"type":22,"path":168,"relevant":44,"token_counts":169,"usage":173,"markdown":176},"20-core-concepts/20-load.md",{"fulltext":170,"digest":171,"short_digest":172},9097,1844,331,{"input":174,"output":175,"details":32},10140,2292,{"fulltext":177,"digest":178,"short_digest":179,"essence":180},"---\ntitle: Loading data\n---\n\nBefore a [`+page.svelte`](routing#page-page.svelte) component (and its containing [`+layout.svelte`](routing#layout-layout.svelte) components) can be rendered, we often need to get some data. This is done by defining `load` functions.\n\n## Page data\n\nA `+page.svelte` file can have a sibling `+page.js` that exports a `load` function, the return value of which is available to the page via the `data` prop:\n\n```js\n/// file: src/routes/blog/[slug]/+page.js\n/** @type {import('./$types').PageLoad} */\nexport function load({ params }) {\n\treturn {\n\t\tpost: {\n\t\t\ttitle: `Title for ${params.slug} goes here`,\n\t\t\tcontent: `Content for ${params.slug} goes here`\n\t\t}\n\t};\n}\n```\n\n```svelte\n\u003C!--- file: src/routes/blog/[slug]/+page.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\u003C/script>\n\n\u003Ch1>{data.post.title}\u003C/h1>\n\u003Cdiv>{@html data.post.content}\u003C/div>\n```\n\n> [!LEGACY]\n> Before version 2.16.0, the props of a page and layout had to be typed individually:\n> ```js\n> /// file: +page.svelte\n> /** @type {{ data: import('./$types').PageData }} */\n> let { data } = $props();\n> ```\n>\n> In Svelte 4, you'd use `export let data` instead.\n\nThanks to the generated `$types` module, we get full type safety.\n\nA `load` function in a `+page.js` file runs both on the server and in the browser (unless combined with `export const ssr = false`, in which case it will [only run in the browser](page-options#ssr)). If your `load` function should _always_ run on the server (because it uses private environment variables, for example, or accesses a database) then it would go in a `+page.server.js` instead.\n\nA more realistic version of your blog post's `load` function, that only runs on the server and pulls data from a database, might look like this:\n\n```js\n/// file: src/routes/blog/[slug]/+page.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function getPost(slug: string): Promise\u003C{ title: string, content: string }>\n}\n\n// @filename: index.js\n// ---cut---\nimport * as db from '$lib/server/database';\n\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\treturn {\n\t\tpost: await db.getPost(params.slug)\n\t};\n}\n```\n\nNotice that the type changed from `PageLoad` to `PageServerLoad`, because server `load` functions can access additional arguments. To understand when to use `+page.js` and when to use `+page.server.js`, see [Universal vs server](load#Universal-vs-server).\n\n## Layout data\n\nYour `+layout.svelte` files can also load data, via `+layout.js` or `+layout.server.js`.\n\n```js\n/// file: src/routes/blog/[slug]/+layout.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function getPostSummaries(): Promise\u003CArray\u003C{ title: string, slug: string }>>\n}\n\n// @filename: index.js\n// ---cut---\nimport * as db from '$lib/server/database';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport async function load() {\n\treturn {\n\t\tposts: await db.getPostSummaries()\n\t};\n}\n```\n\n```svelte\n\u003C!--- file: src/routes/blog/[slug]/+layout.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').LayoutProps} */\n\tlet { data, children } = $props();\n\u003C/script>\n\n\u003Cmain>\n\t\u003C!-- +page.svelte is `@render`ed here -->\n\t{@render children()}\n\u003C/main>\n\n\u003Caside>\n\t\u003Ch2>More posts\u003C/h2>\n\t\u003Cul>\n\t\t{#each data.posts as post}\n\t\t\t\u003Cli>\n\t\t\t\t\u003Ca href=\"/blog/{post.slug}\">\n\t\t\t\t\t{post.title}\n\t\t\t\t\u003C/a>\n\t\t\t\u003C/li>\n\t\t{/each}\n\t\u003C/ul>\n\u003C/aside>\n```\n\n> [!LEGACY]\n> `LayoutProps` was added in 2.16.0. In earlier versions, properties had to be typed individually:\n> ```js\n> /// file: +layout.svelte\n> /** @type {{ data: import('./$types').LayoutData, children: Snippet }} */\n> let { data, children } = $props();\n> ```\n\nData returned from layout `load` functions is available to child `+layout.svelte` components and the `+page.svelte` component as well as the layout that it 'belongs' to.\n\n```svelte\n/// file: src/routes/blog/[slug]/+page.svelte\n\u003Cscript>\n\t+++import { page } from '$app/state';+++\n\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\n+++\t// we can access `data.posts` because it's returned from\n\t// the parent layout `load` function\n\tlet index = $derived(data.posts.findIndex(post => post.slug === page.params.slug));\n\tlet next = $derived(data.posts[index + 1]);+++\n\u003C/script>\n\n\u003Ch1>{data.post.title}\u003C/h1>\n\u003Cdiv>{@html data.post.content}\u003C/div>\n\n+++{#if next}\n\t\u003Cp>Next post: \u003Ca href=\"/blog/{next.slug}\">{next.title}\u003C/a>\u003C/p>\n{/if}+++\n```\n\n> [!NOTE] If multiple `load` functions return data with the same key, the last one 'wins' — the result of a layout `load` returning `{ a: 1, b: 2 }` and a page `load` returning `{ b: 3, c: 4 }` would be `{ a: 1, b: 3, c: 4 }`.\n\n## page.data\n\nThe `+page.svelte` component, and each `+layout.svelte` component above it, has access to its own data plus all the data from its parents.\n\nIn some cases, we might need the opposite — a parent layout might need to access page data or data from a child layout. For example, the root layout might want to access a `title` property returned from a `load` function in `+page.js` or `+page.server.js`. This can be done with `page.data`:\n\n```svelte\n\u003C!--- file: src/routes/+layout.svelte --->\n\u003Cscript>\n\timport { page } from '$app/state';\n\u003C/script>\n\n\u003Csvelte:head>\n\t\u003Ctitle>{page.data.title}\u003C/title>\n\u003C/svelte:head>\n```\n\nType information for `page.data` is provided by `App.PageData`.\n\n> [!LEGACY]\n> `$app/state` was added in SvelteKit 2.12. If you're using an earlier version or are using Svelte 4, use `$app/stores` instead.\n> It provides a `page` store with the same interface that you can subscribe to, e.g. `$page.data.title`.\n\n## Universal vs server\n\nAs we've seen, there are two types of `load` function:\n\n* `+page.js` and `+layout.js` files export _universal_ `load` functions that run both on the server and in the browser\n* `+page.server.js` and `+layout.server.js` files export _server_ `load` functions that only run server-side\n\nConceptually, they're the same thing, but there are some important differences to be aware of.\n\n### When does which load function run?\n\nServer `load` functions _always_ run on the server.\n\nBy default, universal `load` functions run on the server during SSR when the user first visits your page. They will then run again during hydration, reusing any responses from [fetch requests](#Making-fetch-requests). All subsequent invocations of universal `load` functions happen in the browser. You can customize the behavior through [page options](page-options). If you disable [server-side rendering](page-options#ssr), you'll get an SPA and universal `load` functions _always_ run on the client.\n\nIf a route contains both universal and server `load` functions, the server `load` runs first.\n\nA `load` function is invoked at runtime, unless you [prerender](page-options#prerender) the page — in that case, it's invoked at build time.\n\n### Input\n\nBoth universal and server `load` functions have access to properties describing the request (`params`, `route` and `url`) and various functions (`fetch`, `setHeaders`, `parent`, `depends` and `untrack`). These are described in the following sections.\n\nServer `load` functions are called with a `ServerLoadEvent`, which inherits `clientAddress`, `cookies`, `locals`, `platform` and `request` from `RequestEvent`.\n\nUniversal `load` functions are called with a `LoadEvent`, which has a `data` property. If you have `load` functions in both `+page.js` and `+page.server.js` (or `+layout.js` and `+layout.server.js`), the return value of the server `load` function is the `data` property of the universal `load` function's argument.\n\n### Output\n\nA universal `load` function can return an object containing any values, including things like custom classes and component constructors.\n\nA server `load` function must return data that can be serialized with [devalue](https://github.com/rich-harris/devalue) — anything that can be represented as JSON plus things like `BigInt`, `Date`, `Map`, `Set` and `RegExp`, or repeated/cyclical references — so that it can be transported over the network. Your data can include [promises](#Streaming-with-promises), in which case it will be streamed to browsers. If you need to serialize/deserialize custom types, use [transport hooks](hooks#Universal-hooks-transport).\n\n### When to use which\n\nServer `load` functions are convenient when you need to access data directly from a database or filesystem, or need to use private environment variables.\n\nUniversal `load` functions are useful when you need to `fetch` data from an external API and don't need private credentials, since SvelteKit can get the data directly from the API rather than going via your server. They are also useful when you need to return something that can't be serialized, such as a Svelte component constructor.\n\nIn rare cases, you might need to use both together — for example, you might need to return an instance of a custom class that was initialised with data from your server. When using both, the server `load` return value is _not_ passed directly to the page, but to the universal `load` function (as the `data` property):\n\n```js\n/// file: src/routes/+page.server.js\n/** @type {import('./$types').PageServerLoad} */\nexport async function load() {\n\treturn {\n\t\tserverMessage: 'hello from server load function'\n\t};\n}\n```\n\n```js\n/// file: src/routes/+page.js\n// @errors: 18047\n/** @type {import('./$types').PageLoad} */\nexport async function load({ data }) {\n\treturn {\n\t\tserverMessage: data.serverMessage,\n\t\tuniversalMessage: 'hello from universal load function'\n\t};\n}\n```\n\n## Using URL data\n\nOften the `load` function depends on the URL in one way or another. For this, the `load` function provides you with `url`, `route` and `params`.\n\n### url\n\nAn instance of [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL), containing properties like the `origin`, `hostname`, `pathname` and `searchParams` (which contains the parsed query string as a [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) object). `url.hash` cannot be accessed during `load`, since it is unavailable on the server.\n\n> [!NOTE] In some environments this is derived from request headers during server-side rendering. If you're using [adapter-node](adapter-node), for example, you may need to configure the adapter in order for the URL to be correct.\n\n### route\n\nContains the name of the current route directory, relative to `src/routes`:\n\n```js\n/// file: src/routes/a/[b]/[...c]/+page.js\n/** @type {import('./$types').PageLoad} */\nexport function load({ route }) {\n\tconsole.log(route.id); // '/a/[b]/[...c]'\n}\n```\n\n### params\n\n`params` is derived from `url.pathname` and `route.id`.\n\nGiven a `route.id` of `/a/[b]/[...c]` and a `url.pathname` of `/a/x/y/z`, the `params` object would look like this:\n\n```json\n{\n\t\"b\": \"x\",\n\t\"c\": \"y/z\"\n}\n```\n\n## Making fetch requests\n\nTo get data from an external API or a `+server.js` handler, you can use the provided `fetch` function, which behaves identically to the [native `fetch` web API](https://developer.mozilla.org/en-US/docs/Web/API/fetch) with a few additional features:\n\n- It can be used to make credentialed requests on the server, as it inherits the `cookie` and `authorization` headers for the page request.\n- It can make relative requests on the server (ordinarily, `fetch` requires a URL with an origin when used in a server context).\n- Internal requests (e.g. for `+server.js` routes) go directly to the handler function when running on the server, without the overhead of an HTTP call.\n- During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the `text`, `json` and `arrayBuffer` methods of the `Response` object. Note that headers will _not_ be serialized, unless explicitly included via [`filterSerializedResponseHeaders`](hooks#Server-hooks-handle).\n- During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request - if you received a warning in your browser console when using the browser `fetch` instead of the `load` `fetch`, this is why.\n\n```js\n/// file: src/routes/items/[id]/+page.js\n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\n\treturn { item };\n}\n```\n\n## Cookies\n\nA server `load` function can get and set [`cookies`](@sveltejs-kit#Cookies).\n\n```js\n/// file: src/routes/+layout.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function getUser(sessionid: string | undefined): Promise\u003C{ name: string, avatar: string }>\n}\n\n// @filename: index.js\n// ---cut---\nimport * as db from '$lib/server/database';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nCookies will only be passed through the provided `fetch` function if the target host is the same as the SvelteKit application or a more specific subdomain of it.\n\nFor example, if SvelteKit is serving my.domain.com:\n- domain.com WILL NOT receive cookies\n- my.domain.com WILL receive cookies\n- api.domain.com WILL NOT receive cookies\n- sub.my.domain.com WILL receive cookies\n\nOther cookies will not be passed when `credentials: 'include'` is set, because SvelteKit does not know which domain which cookie belongs to (the browser does not pass this information along), so it's not safe to forward any of them. Use the [handleFetch hook](hooks#Server-hooks-handleFetch) to work around it.\n\n## Headers\n\nBoth server and universal `load` functions have access to a `setHeaders` function that, when running on the server, can set headers for the response. (When running in the browser, `setHeaders` has no effect.) This is useful if you want the page to be cached, for example:\n\n```js\n// @errors: 2322 1360\n/// file: src/routes/products/+page.js\n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch, setHeaders }) {\n\tconst url = `https://cms.example.com/products.json`;\n\tconst response = await fetch(url);\n\n\t// Headers are only set during SSR, caching the page's HTML\n\t// for the same length of time as the underlying data.\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nSetting the same header multiple times (even in separate `load` functions) is an error. You can only set a given header once using the `setHeaders` function. You cannot add a `set-cookie` header with `setHeaders` — use `cookies.set(name, value, options)` instead.\n\n## Using parent data\n\nOccasionally it's useful for a `load` function to access data from a parent `load` function, which can be done with `await parent()`:\n\n```js\n/// file: src/routes/+layout.js\n/** @type {import('./$types').LayoutLoad} */\nexport function load() {\n\treturn { a: 1 };\n}\n```\n\n```js\n/// file: src/routes/abc/+layout.js\n/** @type {import('./$types').LayoutLoad} */\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n```js\n/// file: src/routes/abc/+page.js\n/** @type {import('./$types').PageLoad} */\nexport async function load({ parent }) {\n\tconst { a, b } = await parent();\n\treturn { c: a + b };\n}\n```\n\n```svelte\n\u003C!--- file: src/routes/abc/+page.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\u003C/script>\n\n\u003C!-- renders `1 + 2 = 3` -->\n\u003Cp>{data.a} + {data.b} = {data.c}\u003C/p>\n```\n\n> [!NOTE] Notice that the `load` function in `+page.js` receives the merged data from both layout `load` functions, not just the immediate parent.\n\nInside `+page.server.js` and `+layout.server.js`, `parent` returns data from parent `+layout.server.js` files.\n\nIn `+page.js` or `+layout.js` it will return data from parent `+layout.js` files. However, a missing `+layout.js` is treated as a `({ data }) => data` function, meaning that it will also return data from parent `+layout.server.js` files that are not 'shadowed' by a `+layout.js` file\n\nTake care not to introduce waterfalls when using `await parent()`. Here, for example, `getData(params)` does not depend on the result of calling `parent()`, so we should call it first to avoid a delayed render.\n\n```js\n/// file: +page.js\n// @filename: ambient.d.ts\ndeclare function getData(params: Record\u003Cstring, string>): Promise\u003C{ meta: any }>\n\n// @filename: index.js\n// ---cut---\n/** @type {import('./$types').PageLoad} */\nexport async function load({ params, parent }) {\n\t---const parentData = await parent();---\n\tconst data = await getData(params);\n\t+++const parentData = await parent();+++\n\n\treturn {\n\t\t...data,\n\t\tmeta: { ...parentData.meta, ...data.meta }\n\t};\n}\n```\n\n## Errors\n\nIf an error is thrown during `load`, the nearest [`+error.svelte`](routing#error) will be rendered. For [_expected_](errors#Expected-errors) errors, use the `error` helper from `@sveltejs/kit` to specify the HTTP status code and an optional message:\n\n```js\n/// file: src/routes/admin/+layout.server.js\n// @filename: ambient.d.ts\ndeclare namespace App {\n\tinterface Locals {\n\t\tuser?: {\n\t\t\tname: string;\n\t\t\tisAdmin: boolean;\n\t\t}\n\t}\n}\n\n// @filename: index.js\n// ---cut---\nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n\n\tif (!locals.user.isAdmin) {\n\t\terror(403, 'not an admin');\n\t}\n}\n```\n\nCalling `error(...)` will throw an exception, making it easy to stop execution from inside helper functions.\n\nIf an [_unexpected_](errors#Unexpected-errors) error is thrown, SvelteKit will invoke [`handleError`](hooks#Shared-hooks-handleError) and treat it as a 500 Internal Error.\n\n> [!NOTE] [In SvelteKit 1.x](migrating-to-sveltekit-2#redirect-and-error-are-no-longer-thrown-by-you) you had to `throw` the error yourself\n\n## Redirects\n\nTo redirect users, use the `redirect` helper from `@sveltejs/kit` to specify the location to which they should be redirected alongside a `3xx` status code. Like `error(...)`, calling `redirect(...)` will throw an exception, making it easy to stop execution from inside helper functions.\n\n```js\n/// file: src/routes/user/+layout.server.js\n// @filename: ambient.d.ts\ndeclare namespace App {\n\tinterface Locals {\n\t\tuser?: {\n\t\t\tname: string;\n\t\t}\n\t}\n}\n\n// @filename: index.js\n// ---cut---\nimport { redirect } from '@sveltejs/kit';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\n> [!NOTE] Don't use `redirect()` inside a `try {...}` block, as the redirect will immediately trigger the catch statement.\n\nIn the browser, you can also navigate programmatically outside of a `load` function using [`goto`]($app-navigation#goto) from [`$app.navigation`]($app-navigation).\n\n> [!NOTE] [In SvelteKit 1.x](migrating-to-sveltekit-2#redirect-and-error-are-no-longer-thrown-by-you) you had to `throw` the `redirect` yourself\n\n## Streaming with promises\n\nWhen using a server `load`, promises will be streamed to the browser as they resolve. This is useful if you have slow, non-essential data, since you can start rendering the page before all the data is available:\n\n```js\n/// file: src/routes/blog/[slug]/+page.server.js\n// @filename: ambient.d.ts\ndeclare global {\n\tconst loadPost: (slug: string) => Promise\u003C{ title: string, content: string }>;\n\tconst loadComments: (slug: string) => Promise\u003C{ content: string }>;\n}\n\nexport {};\n\n// @filename: index.js\n// ---cut---\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\treturn {\n\t\t// make sure the `await` happens at the end, otherwise we\n\t\t// can't start loading comments until we've loaded the post\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\nThis is useful for creating skeleton loading states, for example:\n\n```svelte\n\u003C!--- file: src/routes/blog/[slug]/+page.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\u003C/script>\n\n\u003Ch1>{data.post.title}\u003C/h1>\n\u003Cdiv>{@html data.post.content}\u003C/div>\n\n{#await data.comments}\n\tLoading comments...\n{:then comments}\n\t{#each comments as comment}\n\t\t\u003Cp>{comment.content}\u003C/p>\n\t{/each}\n{:catch error}\n\t\u003Cp>error loading comments: {error.message}\u003C/p>\n{/await}\n```\n\nWhen streaming data, be careful to handle promise rejections correctly. More specifically, the server could crash with an \"unhandled promise rejection\" error if a lazy-loaded promise fails before rendering starts (at which point it's caught) and isn't handling the error in some way. When using SvelteKit's `fetch` directly in the `load` function, SvelteKit will handle this case for you. For other promises, it is enough to attach a noop-`catch` to the promise to mark it as handled.\n\n```js\n/// file: src/routes/+page.server.js\n/** @type {import('./$types').PageServerLoad} */\nexport function load({ fetch }) {\n\tconst ok_manual = Promise.reject();\n\tok_manual.catch(() => {});\n\n\treturn {\n\t\tok_manual,\n\t\tok_fetch: fetch('/fetch/that/could/fail'),\n\t\tdangerous_unhandled: Promise.reject()\n\t};\n}\n```\n\n> [!NOTE] On platforms that do not support streaming, such as AWS Lambda or Firebase, responses will be buffered. This means the page will only render once all promises resolve. If you are using a proxy (e.g. NGINX), make sure it does not buffer responses from the proxied server.\n\n> [!NOTE] Streaming data will only work when JavaScript is enabled. You should avoid returning promises from a universal `load` function if the page is server rendered, as these are _not_ streamed — instead, the promise is recreated when the function reruns in the browser.\n\n> [!NOTE] The headers and status code of a response cannot be changed once the response has started streaming, therefore you cannot `setHeaders` or throw redirects inside a streamed promise.\n\n> [!NOTE] [In SvelteKit 1.x](migrating-to-sveltekit-2#Top-level-promises-are-no-longer-awaited) top-level promises were automatically awaited, only nested promises were streamed.\n\n## Parallel loading\n\nWhen rendering (or navigating to) a page, SvelteKit runs all `load` functions concurrently, avoiding a waterfall of requests. During client-side navigation, the result of calling multiple server `load` functions are grouped into a single response. Once all `load` functions have returned, the page is rendered.\n\n## Rerunning load functions\n\nSvelteKit tracks the dependencies of each `load` function to avoid rerunning it unnecessarily during navigation.\n\nFor example, given a pair of `load` functions like these...\n\n```js\n/// file: src/routes/blog/[slug]/+page.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function getPost(slug: string): Promise\u003C{ title: string, content: string }>\n}\n\n// @filename: index.js\n// ---cut---\nimport * as db from '$lib/server/database';\n\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\treturn {\n\t\tpost: await db.getPost(params.slug)\n\t};\n}\n```\n\n```js\n/// file: src/routes/blog/[slug]/+layout.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function getPostSummaries(): Promise\u003CArray\u003C{ title: string, slug: string }>>\n}\n\n// @filename: index.js\n// ---cut---\nimport * as db from '$lib/server/database';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport async function load() {\n\treturn {\n\t\tposts: await db.getPostSummaries()\n\t};\n}\n```\n\n...the one in `+page.server.js` will rerun if we navigate from `/blog/trying-the-raw-meat-diet` to `/blog/i-regret-my-choices` because `params.slug` has changed. The one in `+layout.server.js` will not, because the data is still valid. In other words, we won't call `db.getPostSummaries()` a second time.\n\nA `load` function that calls `await parent()` will also rerun if a parent `load` function is rerun.\n\nDependency tracking does not apply _after_ the `load` function has returned — for example, accessing `params.x` inside a nested [promise](#Streaming-with-promises) will not cause the function to rerun when `params.x` changes. (Don't worry, you'll get a warning in development if you accidentally do this.) Instead, access the parameter in the main body of your `load` function.\n\nSearch parameters are tracked independently from the rest of the url. For example, accessing `event.url.searchParams.get(\"x\")` inside a `load` function will make that `load` function re-run when navigating from `?x=1` to `?x=2`, but not when navigating from `?x=1&y=1` to `?x=1&y=2`.\n\n### Untracking dependencies\n\nIn rare cases, you may wish to exclude something from the dependency tracking mechanism. You can do this with the provided `untrack` function:\n\n```js\n/// file: src/routes/+page.js\n/** @type {import('./$types').PageLoad} */\nexport async function load({ untrack, url }) {\n\t// Untrack url.pathname so that path changes don't trigger a rerun\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Manual invalidation\n\nYou can also rerun `load` functions that apply to the current page using [`invalidate(url)`]($app-navigation#invalidate), which reruns all `load` functions that depend on `url`, and [`invalidateAll()`]($app-navigation#invalidateAll), which reruns every `load` function. Server load functions will never automatically depend on a fetched `url` to avoid leaking secrets to the client.\n\nA `load` function depends on `url` if it calls `fetch(url)` or `depends(url)`. Note that `url` can be a custom identifier that starts with `[a-z]:`:\n\n```js\n/// file: src/routes/random-number/+page.js\n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch, depends }) {\n\t// load reruns when `invalidate('https://api.example.com/random-number')` is called...\n\tconst response = await fetch('https://api.example.com/random-number');\n\n\t// ...or when `invalidate('app:random')` is called\n\tdepends('app:random');\n\n\treturn {\n\t\tnumber: await response.json()\n\t};\n}\n```\n\n```svelte\n\u003C!--- file: src/routes/random-number/+page.svelte --->\n\u003Cscript>\n\timport { invalidate, invalidateAll } from '$app/navigation';\n\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\n\tfunction rerunLoadFunction() {\n\t\t// any of these will cause the `load` function to rerun\n\t\tinvalidate('app:random');\n\t\tinvalidate('https://api.example.com/random-number');\n\t\tinvalidate(url => url.href.includes('random-number'));\n\t\tinvalidateAll();\n\t}\n\u003C/script>\n\n\u003Cp>random number: {data.number}\u003C/p>\n\u003Cbutton onclick={rerunLoadFunction}>Update random number\u003C/button>\n```\n\n### When do load functions rerun?\n\nTo summarize, a `load` function will rerun in the following situations:\n\n- It references a property of `params` whose value has changed\n- It references a property of `url` (such as `url.pathname` or `url.search`) whose value has changed. Properties in `request.url` are _not_ tracked\n- It calls `url.searchParams.get(...)`, `url.searchParams.getAll(...)` or `url.searchParams.has(...)` and the parameter in question changes. Accessing other properties of `url.searchParams` will have the same effect as accessing `url.search`.\n- It calls `await parent()` and a parent `load` function reran\n- A child `load` function calls `await parent()` and is rerunning, and the parent is a server load function\n- It declared a dependency on a specific URL via [`fetch`](#Making-fetch-requests) (universal load only) or [`depends`](@sveltejs-kit#LoadEvent), and that URL was marked invalid with [`invalidate(url)`]($app-navigation#invalidate)\n- All active `load` functions were forcibly rerun with [`invalidateAll()`]($app-navigation#invalidateAll)\n\n`params` and `url` can change in response to a `\u003Ca href=\"..\">` link click, a [`\u003Cform>` interaction](form-actions#GET-vs-POST), a [`goto`]($app-navigation#goto) invocation, or a [`redirect`](@sveltejs-kit#redirect).\n\nNote that rerunning a `load` function will update the `data` prop inside the corresponding `+layout.svelte` or `+page.svelte`; it does _not_ cause the component to be recreated. As a result, internal state is preserved. If this isn't what you want, you can reset whatever you need to reset inside an [`afterNavigate`]($app-navigation#afterNavigate) callback, and/or wrap your component in a [`{#key ...}`](../svelte/key) block.\n\n## Implications for authentication\n\nA couple features of loading data have important implications for auth checks:\n- Layout `load` functions do not run on every request, such as during client side navigation between child routes. [(When do load functions rerun?)](load#Rerunning-load-functions-When-do-load-functions-rerun)\n- Layout and page `load` functions run concurrently unless `await parent()` is called. If a layout `load` throws, the page `load` function runs, but the client will not receive the returned data.\n\nThere are a few possible strategies to ensure an auth check occurs before protected code.\n\nTo prevent data waterfalls and preserve layout `load` caches:\n- Use [hooks](hooks) to protect multiple routes before any `load` functions run\n- Use auth guards directly in `+page.server.js` `load` functions for route specific protection\n\nPutting an auth guard in `+layout.server.js` requires all child pages to call `await parent()` before protected code. Unless every child page depends on returned data from `await parent()`, the other options will be more performant.\n\n## Using `getRequestEvent`\n\nWhen running server `load` functions, the `event` object passed to the function as an argument can also be retrieved with [`getRequestEvent`]($app-server#getRequestEvent). This allows shared logic (such as authentication guards) to access information about the current request without it needing to be passed around.\n\nFor example, you might have a function that requires users to be logged in, and redirects them to `/login` if not:\n\n```js\n/// file: src/lib/server/auth.js\n// @filename: ambient.d.ts\ninterface User {\n\tname: string;\n}\n\ndeclare namespace App {\n\tinterface Locals {\n\t\tuser?: User;\n\t}\n}\n\n// @filename: index.ts\n// ---cut---\nimport { redirect } from '@sveltejs/kit';\nimport { getRequestEvent } from '$app/server';\n\nexport function requireLogin() {\n\tconst { locals, url } = getRequestEvent();\n\n\t// assume `locals.user` is populated in `handle`\n\tif (!locals.user) {\n\t\tconst redirectTo = url.pathname + url.search;\n\t\tconst params = new URLSearchParams({ redirectTo });\n\n\t\tredirect(307, `/login?${params}`);\n\t}\n\n\treturn locals.user;\n}\n```\n\nNow, you can call `requireLogin` in any `load` function (or [form action](form-actions), for example) to guarantee that the user is logged in:\n\n```js\n/// file: +page.server.js\n// @filename: ambient.d.ts\n\ndeclare module '$lib/server/auth' {\n\tinterface User {\n\t\tname: string;\n\t}\n\n\texport function requireLogin(): User;\n}\n\n// @filename: index.ts\n// ---cut---\nimport { requireLogin } from '$lib/server/auth';\n\nexport function load() {\n\tconst user = requireLogin();\n\n\t// `user` is guaranteed to be a user object here, because otherwise\n\t// `requireLogin` would throw a redirect and we wouldn't get here\n\treturn {\n\t\tmessage: `hello ${user.name}!`\n\t};\n}\n```\n\n## Further reading\n\n- [Tutorial: Loading data](/tutorial/kit/page-data)\n- [Tutorial: Errors and redirects](/tutorial/kit/error-basics)\n- [Tutorial: Advanced loading](/tutorial/kit/await-parent)\n","## Load Functions\n\nDefine `load` functions in `+page.js`/`+page.server.js` or `+layout.js`/`+layout.server.js` files. Return values are available to components via the `data` prop.\n\n```js\n// +page.js - runs on server and browser\nexport function load({ params }) {\n\treturn { post: { title: `Title for ${params.slug}` } };\n}\n\n// +page.server.js - runs only on server\nimport * as db from '$lib/server/database';\nexport async function load({ params }) {\n\treturn { post: await db.getPost(params.slug) };\n}\n```\n\n```svelte\n\u003Cscript>\n\tlet { data } = $props();\n\u003C/script>\n\u003Ch1>{data.post.title}\u003C/h1>\n```\n\n## Universal vs Server Load\n\n- **Universal** (`+page.js`, `+layout.js`): Run on server during SSR, then in browser. Can return non-serializable data (classes, components). Use for external API calls.\n- **Server** (`+page.server.js`, `+layout.server.js`): Run only on server. Must return serializable data (JSON, BigInt, Date, Map, Set, RegExp). Use for database access and private environment variables.\n\nWhen both exist, server load runs first and its return value becomes the `data` property of the universal load's argument.\n\n## Layout Data\n\nLayout `load` functions return data available to child layouts and pages. Data from multiple `load` functions merges, with later values overwriting earlier ones.\n\n```js\n// +layout.server.js\nexport async function load() {\n\treturn { posts: await db.getPostSummaries() };\n}\n```\n\n```svelte\n\u003C!-- +layout.svelte -->\n\u003Cscript>\n\tlet { data, children } = $props();\n\u003C/script>\n\u003Cmain>{@render children()}\u003C/main>\n\u003Caside>\n\t{#each data.posts as post}\n\t\t\u003Ca href=\"/blog/{post.slug}\">{post.title}\u003C/a>\n\t{/each}\n\u003C/aside>\n```\n\nAccess parent data in child pages via `page.data` or by importing `page` from `$app/state`.\n\n## URL Data\n\nLoad functions receive:\n- **`url`**: URL instance with `origin`, `hostname`, `pathname`, `searchParams`\n- **`route`**: Route directory name (e.g., `/a/[b]/[...c]`)\n- **`params`**: Parsed route parameters (e.g., `{ b: 'x', c: 'y/z' }`)\n\n## Fetch Requests\n\nUse the provided `fetch` function (not native fetch):\n- Inherits cookies and authorization headers on server\n- Allows relative URLs on server\n- Internal requests bypass HTTP overhead\n- Responses are captured and inlined during SSR\n- Responses are reused during hydration\n\n```js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\treturn { item: await res.json() };\n}\n```\n\n## Cookies\n\nServer load functions can access and set cookies:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn { user: await db.getUser(sessionid) };\n}\n```\n\nCookies are only passed through `fetch` if the target is the same host or a subdomain.\n\n## Headers\n\nBoth universal and server load functions can call `setHeaders()` to set response headers (server-side only):\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch('https://cms.example.com/products.json');\n\tsetHeaders({\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\treturn response.json();\n}\n```\n\nCannot set `set-cookie` headers; use `cookies.set()` instead.\n\n## Parent Data\n\nAccess parent load function data with `await parent()`:\n\n```js\n// +layout.js\nexport function load() {\n\treturn { a: 1 };\n}\n\n// +page.js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { c: a + 1 };\n}\n```\n\nIn server load functions, `parent()` returns data from parent server layouts. In universal load functions, it returns data from parent universal layouts (treating missing layouts as pass-through functions).\n\n## Errors and Redirects\n\nThrow errors with the `error` helper to render the nearest `+error.svelte`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUse `redirect` helper to redirect users:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\n## Streaming Promises\n\nServer load functions can return unresolved promises, which stream to the browser as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tpost: await loadPost(params.slug),\n\t\tcomments: loadComments(params.slug) // unresolved\n\t};\n}\n```\n\n```svelte\n{#await data.comments}\n\tLoading...\n{:then comments}\n\t{#each comments as comment}\n\t\t\u003Cp>{comment.content}\u003C/p>\n\t{/each}\n{:catch error}\n\t\u003Cp>Error: {error.message}\u003C/p>\n{/await}\n```\n\nAttach a noop `.catch()` to unhandled promises to prevent crashes.\n\n## Dependency Tracking and Rerunning\n\nLoad functions rerun when:\n- Referenced `params` properties change\n- Referenced `url` properties change (pathname, search, searchParams)\n- `await parent()` is called and parent reruns\n- A dependency declared via `fetch(url)` or `depends(url)` is invalidated\n\nManually rerun load functions with `invalidate(url)` or `invalidateAll()`:\n\n```js\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\treturn { number: await fetch('/api/random').json() };\n}\n```\n\n```svelte\n\u003Cscript>\n\timport { invalidate } from '$app/navigation';\n\tfunction refresh() {\n\t\tinvalidate('app:random');\n\t}\n\u003C/script>\n\u003Cbutton onclick={refresh}>Refresh\u003C/button>\n```\n\nExclude values from tracking with `untrack()`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n## Authentication\n\nFor auth checks:\n- Use hooks to protect routes before load functions run\n- Use auth guards in `+page.server.js` for route-specific protection\n- Use `getRequestEvent()` from `$app/server` to access request context in shared functions\n\n```js\n// src/lib/server/auth.js\nimport { redirect } from '@sveltejs/kit';\nimport { getRequestEvent } from '$app/server';\n\nexport function requireLogin() {\n\tconst { locals, url } = getRequestEvent();\n\tif (!locals.user) {\n\t\tredirect(307, `/login?redirectTo=${url.pathname}`);\n\t}\n\treturn locals.user;\n}\n```\n\n```js\n// +page.server.js\nimport { requireLogin } from '$lib/server/auth';\n\nexport function load() {\n\tconst user = requireLogin();\n\treturn { message: `hello ${user.name}!` };\n}\n```","## Load Functions\n\nDefine in `+page.js`/`+page.server.js` or `+layout.js`/`+layout.server.js`:\n\n```js\n// Universal (server + browser)\nexport function load({ params }) {\n\treturn { data: 'value' };\n}\n\n// Server-only\nexport async function load({ params }) {\n\treturn { data: await db.query() };\n}\n```\n\n## Universal vs Server\n\n- **Universal**: Run on server (SSR) then browser. Can return non-serializable data.\n- **Server**: Run only on server. Must return serializable data. Use for DB/secrets.\n\n## Key Features\n\n- **Layout data**: Available to child layouts and pages\n- **URL data**: Access `url`, `route`, `params`\n- **Fetch**: Use provided `fetch()` (inherits cookies, allows relative URLs)\n- **Cookies**: Server load can access/set via `cookies.get/set()`\n- **Headers**: Set response headers with `setHeaders()`\n- **Parent data**: Access parent load data with `await parent()`\n- **Errors/Redirects**: Use `error()` and `redirect()` helpers\n- **Streaming**: Return unresolved promises from server load\n- **Rerun**: Triggered by param/url changes or `invalidate()`\n- **Auth**: Use `getRequestEvent()` in shared auth functions","Define load functions in route files to fetch and return data to components, with separate universal and server-only variants offering different capabilities and execution contexts.","form-actions",{"name":181,"path":183,"children":184,"data":185},"core-concepts/form-actions",["Map"],{"type":22,"path":186,"relevant":44,"token_counts":187,"usage":191,"markdown":194},"20-core-concepts/30-form-actions.md",{"fulltext":188,"digest":189,"short_digest":190},5128,857,319,{"input":192,"output":193,"details":32},6173,1286,{"fulltext":195,"digest":196,"short_digest":197,"essence":198},"---\ntitle: Form actions\n---\n\nA `+page.server.js` file can export _actions_, which allow you to `POST` data to the server using the `\u003Cform>` element.\n\nWhen using `\u003Cform>`, client-side JavaScript is optional, but you can easily _progressively enhance_ your form interactions with JavaScript to provide the best user experience.\n\n## Default actions\n\nIn the simplest case, a page declares a `default` action:\n\n```js\n/// file: src/routes/login/+page.server.js\n/** @satisfies {import('./$types').Actions} */\nexport const actions = {\n\tdefault: async (event) => {\n\t\t// TODO log the user in\n\t}\n};\n```\n\nTo invoke this action from the `/login` page, just add a `\u003Cform>` — no JavaScript needed:\n\n```svelte\n\u003C!--- file: src/routes/login/+page.svelte --->\n\u003Cform method=\"POST\">\n\t\u003Clabel>\n\t\tEmail\n\t\t\u003Cinput name=\"email\" type=\"email\">\n\t\u003C/label>\n\t\u003Clabel>\n\t\tPassword\n\t\t\u003Cinput name=\"password\" type=\"password\">\n\t\u003C/label>\n\t\u003Cbutton>Log in\u003C/button>\n\u003C/form>\n```\n\nIf someone were to click the button, the browser would send the form data via `POST` request to the server, running the default action.\n\n> [!NOTE] Actions always use `POST` requests, since `GET` requests should never have side-effects.\n\nWe can also invoke the action from other pages (for example if there's a login widget in the nav in the root layout) by adding the `action` attribute, pointing to the page:\n\n```html\n/// file: src/routes/+layout.svelte\n\u003Cform method=\"POST\" action=\"/login\">\n\t\u003C!-- content -->\n\u003C/form>\n```\n\n## Named actions\n\nInstead of one `default` action, a page can have as many named actions as it needs:\n\n```js\n/// file: src/routes/login/+page.server.js\n/** @satisfies {import('./$types').Actions} */\nexport const actions = {\n---\tdefault: async (event) => {---\n+++\tlogin: async (event) => {+++\n\t\t// TODO log the user in\n\t},\n+++\tregister: async (event) => {\n\t\t// TODO register the user\n\t}+++\n};\n```\n\nTo invoke a named action, add a query parameter with the name prefixed by a `/` character:\n\n```svelte\n\u003C!--- file: src/routes/login/+page.svelte --->\n\u003Cform method=\"POST\" action=\"?/register\">\n```\n\n```svelte\n\u003C!--- file: src/routes/+layout.svelte --->\n\u003Cform method=\"POST\" action=\"/login?/register\">\n```\n\nAs well as the `action` attribute, we can use the `formaction` attribute on a button to `POST` the same form data to a different action than the parent `\u003Cform>`:\n\n```svelte\n/// file: src/routes/login/+page.svelte\n\u003Cform method=\"POST\" +++action=\"?/login\"+++>\n\t\u003Clabel>\n\t\tEmail\n\t\t\u003Cinput name=\"email\" type=\"email\">\n\t\u003C/label>\n\t\u003Clabel>\n\t\tPassword\n\t\t\u003Cinput name=\"password\" type=\"password\">\n\t\u003C/label>\n\t\u003Cbutton>Log in\u003C/button>\n\t+++\u003Cbutton formaction=\"?/register\">Register\u003C/button>+++\n\u003C/form>\n```\n\n> [!NOTE] We can't have default actions next to named actions, because if you POST to a named action without a redirect, the query parameter is persisted in the URL, which means the next default POST would go through the named action from before.\n\n## Anatomy of an action\n\nEach action receives a `RequestEvent` object, allowing you to read the data with `request.formData()`. After processing the request (for example, logging the user in by setting a cookie), the action can respond with data that will be available through the `form` property on the corresponding page and through `page.form` app-wide until the next update.\n\n```js\n/// file: src/routes/login/+page.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/db';\n\n// @filename: index.js\n// ---cut---\nimport * as db from '$lib/server/db';\n\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ cookies }) {\n\tconst user = await db.getUserFromSession(cookies.get('sessionid'));\n\treturn { user };\n}\n\n/** @satisfies {import('./$types').Actions} */\nexport const actions = {\n\tlogin: async ({ cookies, request }) => {\n\t\tconst data = await request.formData();\n\t\tconst email = data.get('email');\n\t\tconst password = data.get('password');\n\n\t\tconst user = await db.getUser(email);\n\t\tcookies.set('sessionid', await db.createSession(user), { path: '/' });\n\n\t\treturn { success: true };\n\t},\n\tregister: async (event) => {\n\t\t// TODO register the user\n\t}\n};\n```\n\n```svelte\n\u003C!--- file: src/routes/login/+page.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data, form } = $props();\n\u003C/script>\n\n{#if form?.success}\n\t\u003C!-- this message is ephemeral; it exists because the page was rendered in\n\t       response to a form submission. it will vanish if the user reloads -->\n\t\u003Cp>Successfully logged in! Welcome back, {data.user.name}\u003C/p>\n{/if}\n```\n\n> [!LEGACY]\n> `PageProps` was added in 2.16.0. In earlier versions, you had to type the `data` and `form` properties individually:\n> ```js\n> /// file: +page.svelte\n> /** @type {{ data: import('./$types').PageData, form: import('./$types').ActionData }} */\n> let { data, form } = $props();\n> ```\n>\n> In Svelte 4, you'd use `export let data` and `export let form` instead to declare properties.\n\n### Validation errors\n\nIf the request couldn't be processed because of invalid data, you can return validation errors — along with the previously submitted form values — back to the user so that they can try again. The `fail` function lets you return an HTTP status code (typically 400 or 422, in the case of validation errors) along with the data. The status code is available through `page.status` and the data through `form`:\n\n```js\n/// file: src/routes/login/+page.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/db';\n\n// @filename: index.js\n// ---cut---\n+++import { fail } from '@sveltejs/kit';+++\nimport * as db from '$lib/server/db';\n\n/** @satisfies {import('./$types').Actions} */\nexport const actions = {\n\tlogin: async ({ cookies, request }) => {\n\t\tconst data = await request.formData();\n\t\tconst email = data.get('email');\n\t\tconst password = data.get('password');\n\n+++\t\tif (!email) {\n\t\t\treturn fail(400, { email, missing: true });\n\t\t}+++\n\n\t\tconst user = await db.getUser(email);\n\n+++\t\tif (!user || user.password !== db.hash(password)) {\n\t\t\treturn fail(400, { email, incorrect: true });\n\t\t}+++\n\n\t\tcookies.set('sessionid', await db.createSession(user), { path: '/' });\n\n\t\treturn { success: true };\n\t},\n\tregister: async (event) => {\n\t\t// TODO register the user\n\t}\n};\n```\n\n> [!NOTE] Note that as a precaution, we only return the email back to the page — not the password.\n\n```svelte\n/// file: src/routes/login/+page.svelte\n\u003Cform method=\"POST\" action=\"?/login\">\n+++\t{#if form?.missing}\u003Cp class=\"error\">The email field is required\u003C/p>{/if}\n\t{#if form?.incorrect}\u003Cp class=\"error\">Invalid credentials!\u003C/p>{/if}+++\n\t\u003Clabel>\n\t\tEmail\n\t\t\u003Cinput name=\"email\" type=\"email\" +++value={form?.email ?? ''}+++>\n\t\u003C/label>\n\t\u003Clabel>\n\t\tPassword\n\t\t\u003Cinput name=\"password\" type=\"password\">\n\t\u003C/label>\n\t\u003Cbutton>Log in\u003C/button>\n\t\u003Cbutton formaction=\"?/register\">Register\u003C/button>\n\u003C/form>\n```\n\nThe returned data must be serializable as JSON. Beyond that, the structure is entirely up to you. For example, if you had multiple forms on the page, you could distinguish which `\u003Cform>` the returned `form` data referred to with an `id` property or similar.\n\n### Redirects\n\nRedirects (and errors) work exactly the same as in [`load`](load#Redirects):\n\n```js\n// @errors: 2345\n/// file: src/routes/login/+page.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/db';\n\n// @filename: index.js\n// ---cut---\nimport { fail, +++redirect+++ } from '@sveltejs/kit';\nimport * as db from '$lib/server/db';\n\n/** @satisfies {import('./$types').Actions} */\nexport const actions = {\n\tlogin: async ({ cookies, request, +++url+++ }) => {\n\t\tconst data = await request.formData();\n\t\tconst email = data.get('email');\n\t\tconst password = data.get('password');\n\n\t\tconst user = await db.getUser(email);\n\t\tif (!user) {\n\t\t\treturn fail(400, { email, missing: true });\n\t\t}\n\n\t\tif (user.password !== db.hash(password)) {\n\t\t\treturn fail(400, { email, incorrect: true });\n\t\t}\n\n\t\tcookies.set('sessionid', await db.createSession(user), { path: '/' });\n\n+++\t\tif (url.searchParams.has('redirectTo')) {\n\t\t\tredirect(303, url.searchParams.get('redirectTo'));\n\t\t}+++\n\n\t\treturn { success: true };\n\t},\n\tregister: async (event) => {\n\t\t// TODO register the user\n\t}\n};\n```\n\n## Loading data\n\nAfter an action runs, the page will be re-rendered (unless a redirect or an unexpected error occurs), with the action's return value available to the page as the `form` prop. This means that your page's `load` functions will run after the action completes.\n\nNote that `handle` runs before the action is invoked, and does not rerun before the `load` functions. This means that if, for example, you use `handle` to populate `event.locals` based on a cookie, you must update `event.locals` when you set or delete the cookie in an action:\n\n```js\n/// file: src/hooks.server.js\n// @filename: ambient.d.ts\ndeclare namespace App {\n\tinterface Locals {\n\t\tuser: {\n\t\t\tname: string;\n\t\t} | null\n\t}\n}\n\n// @filename: global.d.ts\ndeclare global {\n\tfunction getUser(sessionid: string | undefined): {\n\t\tname: string;\n\t};\n}\n\nexport {};\n\n// @filename: index.js\n// ---cut---\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tevent.locals.user = await getUser(event.cookies.get('sessionid'));\n\treturn resolve(event);\n}\n```\n\n```js\n/// file: src/routes/account/+page.server.js\n// @filename: ambient.d.ts\ndeclare namespace App {\n\tinterface Locals {\n\t\tuser: {\n\t\t\tname: string;\n\t\t} | null\n\t}\n}\n\n// @filename: index.js\n// ---cut---\n/** @type {import('./$types').PageServerLoad} */\nexport function load(event) {\n\treturn {\n\t\tuser: event.locals.user\n\t};\n}\n\n/** @satisfies {import('./$types').Actions} */\nexport const actions = {\n\tlogout: async (event) => {\n\t\tevent.cookies.delete('sessionid', { path: '/' });\n\t\tevent.locals.user = null;\n\t}\n};\n```\n\n## Progressive enhancement\n\nIn the preceding sections we built a `/login` action that [works without client-side JavaScript](https://kryogenix.org/code/browser/everyonehasjs.html) — not a `fetch` in sight. That's great, but when JavaScript _is_ available we can progressively enhance our form interactions to provide a better user experience.\n\n### use:enhance\n\nThe easiest way to progressively enhance a form is to add the `use:enhance` action:\n\n```svelte\n/// file: src/routes/login/+page.svelte\n\u003Cscript>\n\t+++import { enhance } from '$app/forms';+++\n\n\t/** @type {import('./$types').PageProps} */\n\tlet { form } = $props();\n\u003C/script>\n\n\u003Cform method=\"POST\" +++use:enhance+++>\n```\n\n> [!NOTE] `use:enhance` can only be used with forms that have `method=\"POST\"` and point to actions defined in a `+page.server.js` file. It will not work with `method=\"GET\"`, which is the default for forms without a specified method. Attempting to use `use:enhance` on forms without `method=\"POST\"` or posting to a `+server.js` endpoint will result in an error.\n\n> [!NOTE] Yes, it's a little confusing that the `enhance` action and `\u003Cform action>` are both called 'action'. These docs are action-packed. Sorry.\n\nWithout an argument, `use:enhance` will emulate the browser-native behaviour, just without the full-page reloads. It will:\n\n- update the `form` property, `page.form` and `page.status` on a successful or invalid response, but only if the action is on the same page you're submitting from. For example, if your form looks like `\u003Cform action=\"/somewhere/else\" ..>`, the `form` prop and the `page.form` state will _not_ be updated. This is because in the native form submission case you would be redirected to the page the action is on. If you want to have them updated either way, use [`applyAction`](#Progressive-enhancement-Customising-use:enhance)\n- reset the `\u003Cform>` element\n- invalidate all data using `invalidateAll` on a successful response\n- call `goto` on a redirect response\n- render the nearest `+error` boundary if an error occurs\n- [reset focus](accessibility#Focus-management) to the appropriate element\n\n### Customising use:enhance\n\nTo customise the behaviour, you can provide a `SubmitFunction` that runs immediately before the form is submitted, and (optionally) returns a callback that runs with the `ActionResult`.\n\n```svelte\n\u003Cform\n\tmethod=\"POST\"\n\tuse:enhance={({ formElement, formData, action, cancel, submitter }) => {\n\t\t// `formElement` is this `\u003Cform>` element\n\t\t// `formData` is its `FormData` object that's about to be submitted\n\t\t// `action` is the URL to which the form is posted\n\t\t// calling `cancel()` will prevent the submission\n\t\t// `submitter` is the `HTMLElement` that caused the form to be submitted\n\n\t\treturn async ({ result, update }) => {\n\t\t\t// `result` is an `ActionResult` object\n\t\t\t// `update` is a function which triggers the default logic that would be triggered if this callback wasn't set\n\t\t};\n\t}}\n>\n```\n\nYou can use these functions to show and hide loading UI, and so on.\n\nIf you return a callback, you override the default post-submission behavior. To get it back, call `update`, which accepts `invalidateAll` and `reset` parameters, or use `applyAction` on the result:\n\n```svelte\n/// file: src/routes/login/+page.svelte\n\u003Cscript>\n\timport { enhance, +++applyAction+++ } from '$app/forms';\n\n\t/** @type {import('./$types').PageProps} */\n\tlet { form } = $props();\n\u003C/script>\n\n\u003Cform\n\tmethod=\"POST\"\n\tuse:enhance={({ formElement, formData, action, cancel }) => {\n\t\treturn async ({ result }) => {\n\t\t\t// `result` is an `ActionResult` object\n+++\t\t\tif (result.type === 'redirect') {\n\t\t\t\tgoto(result.location);\n\t\t\t} else {\n\t\t\t\tawait applyAction(result);\n\t\t\t}+++\n\t\t};\n\t}}\n>\n```\n\nThe behaviour of `applyAction(result)` depends on `result.type`:\n\n- `success`, `failure` — sets `page.status` to `result.status` and updates `form` and `page.form` to `result.data` (regardless of where you are submitting from, in contrast to `update` from `enhance`)\n- `redirect` — calls `goto(result.location, { invalidateAll: true })`\n- `error` — renders the nearest `+error` boundary with `result.error`\n\nIn all cases, [focus will be reset](accessibility#Focus-management).\n\n### Custom event listener\n\nWe can also implement progressive enhancement ourselves, without `use:enhance`, with a normal event listener on the `\u003Cform>`:\n\n```svelte\n\u003C!--- file: src/routes/login/+page.svelte --->\n\u003Cscript>\n\timport { invalidateAll, goto } from '$app/navigation';\n\timport { applyAction, deserialize } from '$app/forms';\n\n\t/** @type {import('./$types').PageProps} */\n\tlet { form } = $props();\n\n\t/** @param {SubmitEvent & { currentTarget: EventTarget & HTMLFormElement}} event */\n\tasync function handleSubmit(event) {\n\t\tevent.preventDefault();\n\t\tconst data = new FormData(event.currentTarget, event.submitter);\n\n\t\tconst response = await fetch(event.currentTarget.action, {\n\t\t\tmethod: 'POST',\n\t\t\tbody: data\n\t\t});\n\n\t\t/** @type {import('@sveltejs/kit').ActionResult} */\n\t\tconst result = deserialize(await response.text());\n\n\t\tif (result.type === 'success') {\n\t\t\t// rerun all `load` functions, following the successful update\n\t\t\tawait invalidateAll();\n\t\t}\n\n\t\tapplyAction(result);\n\t}\n\u003C/script>\n\n\u003Cform method=\"POST\" onsubmit={handleSubmit}>\n\t\u003C!-- content -->\n\u003C/form>\n```\n\nNote that you need to `deserialize` the response before processing it further using the corresponding method from `$app/forms`. `JSON.parse()` isn't enough because form actions - like `load` functions - also support returning `Date` or `BigInt` objects.\n\nIf you have a `+server.js` alongside your `+page.server.js`, `fetch` requests will be routed there by default. To `POST` to an action in `+page.server.js` instead, use the custom `x-sveltekit-action` header:\n\n```js\n// @errors: 2532 2304\nconst response = await fetch(this.action, {\n\tmethod: 'POST',\n\tbody: data,\n+++\theaders: {\n\t\t'x-sveltekit-action': 'true'\n\t}+++\n});\n```\n\n## Alternatives\n\nForm actions are the preferred way to send data to the server, since they can be progressively enhanced, but you can also use [`+server.js`](routing#server) files to expose (for example) a JSON API. Here's how such an interaction could look like:\n\n```svelte\n\u003C!--- file: src/routes/send-message/+page.svelte --->\n\u003Cscript>\n\tfunction rerun() {\n\t\tfetch('/api/ci', {\n\t\t\tmethod: 'POST'\n\t\t});\n\t}\n\u003C/script>\n\n\u003Cbutton onclick={rerun}>Rerun CI\u003C/button>\n```\n\n```js\n// @errors: 2355 1360 2322\n/// file: src/routes/api/ci/+server.js\n/** @type {import('./$types').RequestHandler} */\nexport function POST() {\n\t// do something\n}\n```\n\n## GET vs POST\n\nAs we've seen, to invoke a form action you must use `method=\"POST\"`.\n\nSome forms don't need to `POST` data to the server — search inputs, for example. For these you can use `method=\"GET\"` (or, equivalently, no `method` at all), and SvelteKit will treat them like `\u003Ca>` elements, using the client-side router instead of a full page navigation:\n\n```html\n\u003Cform action=\"/search\">\n\t\u003Clabel>\n\t\tSearch\n\t\t\u003Cinput name=\"q\">\n\t\u003C/label>\n\u003C/form>\n```\n\nSubmitting this form will navigate to `/search?q=...` and invoke your load function but will not invoke an action. As with `\u003Ca>` elements, you can set the [`data-sveltekit-reload`](link-options#data-sveltekit-reload), [`data-sveltekit-replacestate`](link-options#data-sveltekit-replacestate), [`data-sveltekit-keepfocus`](link-options#data-sveltekit-keepfocus) and [`data-sveltekit-noscroll`](link-options#data-sveltekit-noscroll) attributes on the `\u003Cform>` to control the router's behaviour.\n\n## Further reading\n\n- [Tutorial: Forms](/tutorial/kit/the-form-element)\n","## Default Actions\n\nExport an `actions` object with a `default` action from `+page.server.js` to handle form submissions:\n\n```js\nexport const actions = {\n\tdefault: async (event) => {\n\t\t// handle POST\n\t}\n};\n```\n\nUse a `\u003Cform method=\"POST\">` to invoke it. The action receives a `RequestEvent` and can read form data via `request.formData()`.\n\n## Named Actions\n\nDefine multiple named actions instead of a default:\n\n```js\nexport const actions = {\n\tlogin: async (event) => {},\n\tregister: async (event) => {}\n};\n```\n\nInvoke with query parameters: `\u003Cform method=\"POST\" action=\"?/login\">` or use `formaction` on buttons: `\u003Cbutton formaction=\"?/register\">`.\n\nCannot mix default and named actions on the same page.\n\n## Returning Data\n\nActions return data available as the `form` prop on the page:\n\n```js\nexport const actions = {\n\tlogin: async ({ cookies, request }) => {\n\t\tconst data = await request.formData();\n\t\tconst email = data.get('email');\n\t\tcookies.set('sessionid', await db.createSession(user), { path: '/' });\n\t\treturn { success: true };\n\t}\n};\n```\n\n```svelte\n{#if form?.success}\n\t\u003Cp>Successfully logged in!\u003C/p>\n{/if}\n```\n\n## Validation Errors\n\nUse the `fail` function to return HTTP status codes with validation errors:\n\n```js\nimport { fail } from '@sveltejs/kit';\n\nexport const actions = {\n\tlogin: async ({ request }) => {\n\t\tconst data = await request.formData();\n\t\tconst email = data.get('email');\n\t\tif (!email) {\n\t\t\treturn fail(400, { email, missing: true });\n\t\t}\n\t}\n};\n```\n\n```svelte\n{#if form?.missing}\u003Cp class=\"error\">Email required\u003C/p>{/if}\n\u003Cinput value={form?.email ?? ''}>\n```\n\n## Redirects\n\nUse the `redirect` function to redirect after successful action:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport const actions = {\n\tlogin: async ({ cookies, request, url }) => {\n\t\t// ... login logic\n\t\tif (url.searchParams.has('redirectTo')) {\n\t\t\tredirect(303, url.searchParams.get('redirectTo'));\n\t\t}\n\t\treturn { success: true };\n\t}\n};\n```\n\n## Progressive Enhancement\n\nAdd `use:enhance` to progressively enhance forms without full-page reloads:\n\n```svelte\n\u003Cscript>\n\timport { enhance } from '$app/forms';\n\u003C/script>\n\n\u003Cform method=\"POST\" use:enhance>\n```\n\nCustomize behavior with a `SubmitFunction`:\n\n```svelte\n\u003Cform method=\"POST\" use:enhance={({ formData, cancel }) => {\n\treturn async ({ result }) => {\n\t\tif (result.type === 'redirect') {\n\t\t\tgoto(result.location);\n\t\t} else {\n\t\t\tawait applyAction(result);\n\t\t}\n\t};\n}>\n```\n\nUse `applyAction` to manually handle results. Use `deserialize` when implementing custom event listeners with `fetch`.\n\n## Loading Data\n\nPage `load` functions run after actions complete. If using `handle` to populate `event.locals` from cookies, manually update `event.locals` when setting/deleting cookies in actions.\n\n## GET vs POST\n\nUse `method=\"POST\"` for actions. Use `method=\"GET\"` for search/filter forms—these invoke `load` functions but not actions, and use client-side routing.","## Form Actions Basics\n\nExport `actions` from `+page.server.js` to handle POST requests:\n\n```js\nexport const actions = {\n\tdefault: async (event) => {},\n\tlogin: async (event) => {},\n\tregister: async (event) => {}\n};\n```\n\nInvoke with `\u003Cform method=\"POST\" action=\"?/login\">` or `\u003Cbutton formaction=\"?/register\">`.\n\n## Handling Data & Errors\n\nRead form data and return results:\n\n```js\nexport const actions = {\n\tlogin: async ({ request }) => {\n\t\tconst data = await request.formData();\n\t\tif (!data.get('email')) {\n\t\t\treturn fail(400, { missing: true });\n\t\t}\n\t\treturn { success: true };\n\t}\n};\n```\n\nAccess in component via `form` prop. Use `redirect()` for redirects.\n\n## Progressive Enhancement\n\nAdd `use:enhance` for client-side form handling without full-page reloads:\n\n```svelte\n\u003Cscript>\n\timport { enhance, applyAction } from '$app/forms';\n\u003C/script>\n\n\u003Cform method=\"POST\" use:enhance={({ formData }) => {\n\treturn async ({ result }) => {\n\t\tawait applyAction(result);\n\t};\n}>\n```\n\nUse `deserialize` when implementing custom fetch-based handlers.","Server-side form actions in +page.server.js handle POST requests with progressive enhancement support via use:enhance.","page-options",{"name":199,"path":201,"children":202,"data":203},"core-concepts/page-options",["Map"],{"type":22,"path":204,"relevant":44,"token_counts":205,"usage":209,"markdown":212},"20-core-concepts/40-page-options.md",{"fulltext":206,"digest":207,"short_digest":208},3503,405,184,{"input":210,"output":211,"details":32},4548,705,{"fulltext":213,"digest":214,"short_digest":215,"essence":216},"---\ntitle: Page options\n---\n\nBy default, SvelteKit will render (or [prerender](glossary#Prerendering)) any component first on the server and send it to the client as HTML. It will then render the component again in the browser to make it interactive in a process called [_hydration_](glossary#Hydration). For this reason, you need to ensure that components can run in both places. SvelteKit will then initialize a [_router_](routing) that takes over subsequent navigations.\n\nYou can control each of these on a page-by-page basis by exporting options from [`+page.js`](routing#page-page.js) or [`+page.server.js`](routing#page-page.server.js), or for groups of pages using a shared [`+layout.js`](routing#layout-layout.js) or [`+layout.server.js`](routing#layout-layout.server.js). To define an option for the whole app, export it from the root layout. Child layouts and pages override values set in parent layouts, so — for example — you can enable prerendering for your entire app then disable it for pages that need to be dynamically rendered.\n\nYou can mix and match these options in different areas of your app. For example, you could prerender your marketing page for maximum speed, server-render your dynamic pages for SEO and accessibility and turn your admin section into an SPA by rendering it on the client only. This makes SvelteKit very versatile.\n\n## prerender\n\nIt's likely that at least some routes of your app can be represented as a simple HTML file generated at build time. These routes can be [_prerendered_](glossary#Prerendering).\n\n```js\n/// file: +page.js/+page.server.js/+server.js\nexport const prerender = true;\n```\n\nAlternatively, you can set `export const prerender = true` in your root `+layout.js` or `+layout.server.js` and prerender everything except pages that are explicitly marked as _not_ prerenderable:\n\n```js\n/// file: +page.js/+page.server.js/+server.js\nexport const prerender = false;\n```\n\nRoutes with `prerender = true` will be excluded from manifests used for dynamic SSR, making your server (or serverless/edge functions) smaller. In some cases you might want to prerender a route but also include it in the manifest (for example, with a route like `/blog/[slug]` where you want to prerender your most recent/popular content but server-render the long tail) — for these cases, there's a third option, 'auto':\n\n```js\n/// file: +page.js/+page.server.js/+server.js\nexport const prerender = 'auto';\n```\n\n> [!NOTE] If your entire app is suitable for prerendering, you can use [`adapter-static`](adapter-static), which will output files suitable for use with any static webserver.\n\nThe prerenderer will start at the root of your app and generate files for any prerenderable pages or `+server.js` routes it finds. Each page is scanned for `\u003Ca>` elements that point to other pages that are candidates for prerendering — because of this, you generally don't need to specify which pages should be accessed. If you _do_ need to specify which pages should be accessed by the prerenderer, you can do so with [`config.kit.prerender.entries`](configuration#prerender), or by exporting an [`entries`](#entries) function from your dynamic route.\n\nWhile prerendering, the value of `building` imported from [`$app/environment`]($app-environment) will be `true`.\n\n### Prerendering server routes\n\nUnlike the other page options, `prerender` also applies to `+server.js` files. These files are _not_ affected by layouts, but will inherit default values from the pages that fetch data from them, if any. For example if a `+page.js` contains this `load` function...\n\n```js\n/// file: +page.js\nexport const prerender = true;\n\n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch }) {\n\tconst res = await fetch('/my-server-route.json');\n\treturn await res.json();\n}\n```\n\n...then `src/routes/my-server-route.json/+server.js` will be treated as prerenderable if it doesn't contain its own `export const prerender = false`.\n\n### When not to prerender\n\nThe basic rule is this: for a page to be prerenderable, any two users hitting it directly must get the same content from the server.\n\n> [!NOTE] Not all pages are suitable for prerendering. Any content that is prerendered will be seen by all users. You can of course fetch personalized data in `onMount` in a prerendered page, but this may result in a poorer user experience since it will involve blank initial content or loading indicators.\n\nNote that you can still prerender pages that load data based on the page's parameters, such as a `src/routes/blog/[slug]/+page.svelte` route.\n\nAccessing [`url.searchParams`](load#Using-URL-data-url) during prerendering is forbidden. If you need to use it, ensure you are only doing so in the browser (for example in `onMount`).\n\nPages with [actions](form-actions) cannot be prerendered, because a server must be able to handle the action `POST` requests.\n\n### Route conflicts\n\nBecause prerendering writes to the filesystem, it isn't possible to have two endpoints that would cause a directory and a file to have the same name. For example, `src/routes/foo/+server.js` and `src/routes/foo/bar/+server.js` would try to create `foo` and `foo/bar`, which is impossible.\n\nFor that reason among others, it's recommended that you always include a file extension — `src/routes/foo.json/+server.js` and `src/routes/foo/bar.json/+server.js` would result in `foo.json` and `foo/bar.json` files living harmoniously side-by-side.\n\nFor _pages_, we skirt around this problem by writing `foo/index.html` instead of `foo`.\n\n### Troubleshooting\n\nIf you encounter an error like 'The following routes were marked as prerenderable, but were not prerendered' it's because the route in question (or a parent layout, if it's a page) has `export const prerender = true` but the page wasn't reached by the prerendering crawler and thus wasn't prerendered.\n\nSince these routes cannot be dynamically server-rendered, this will cause errors when people try to access the route in question. There are a few ways to fix it:\n\n* Ensure that SvelteKit can find the route by following links from [`config.kit.prerender.entries`](configuration#prerender) or the [`entries`](#entries) page option. Add links to dynamic routes (i.e. pages with `[parameters]` ) to this option if they are not found through crawling the other entry points, else they are not prerendered because SvelteKit doesn't know what value the parameters should have. Pages not marked as prerenderable will be ignored and their links to other pages will not be crawled, even if some of them would be prerenderable.\n* Ensure that SvelteKit can find the route by discovering a link to it from one of your other prerendered pages that have server-side rendering enabled.\n* Change `export const prerender = true` to `export const prerender = 'auto'`. Routes with `'auto'` can be dynamically server rendered\n\n## entries\n\nSvelteKit will discover pages to prerender automatically, by starting at _entry points_ and crawling them. By default, all your non-dynamic routes are considered entry points — for example, if you have these routes...\n\n```sh\n/             # non-dynamic\n/blog         # non-dynamic\n/blog/[slug]  # dynamic, because of `[slug]`\n```\n\n...SvelteKit will prerender `/` and `/blog`, and in the process discover links like `\u003Ca href=\"/blog/hello-world\">` which give it new pages to prerender.\n\nMost of the time, that's enough. In some situations, links to pages like `/blog/hello-world` might not exist (or might not exist on prerendered pages), in which case we need to tell SvelteKit about their existence.\n\nThis can be done with [`config.kit.prerender.entries`](configuration#prerender), or by exporting an `entries` function from a `+page.js`, a `+page.server.js` or a `+server.js` belonging to a dynamic route:\n\n```js\n/// file: src/routes/blog/[slug]/+page.server.js\n/** @type {import('./$types').EntryGenerator} */\nexport function entries() {\n\treturn [\n\t\t{ slug: 'hello-world' },\n\t\t{ slug: 'another-blog-post' }\n\t];\n}\n\nexport const prerender = true;\n```\n\n`entries` can be an `async` function, allowing you to (for example) retrieve a list of posts from a CMS or database, in the example above.\n\n## ssr\n\nNormally, SvelteKit renders your page on the server first and sends that HTML to the client where it's [hydrated](glossary#Hydration). If you set `ssr` to `false`, it renders an empty 'shell' page instead. This is useful if your page is unable to be rendered on the server (because you use browser-only globals like `document` for example), but in most situations it's not recommended ([see appendix](glossary#SSR)).\n\n```js\n/// file: +page.js\nexport const ssr = false;\n// If both `ssr` and `csr` are `false`, nothing will be rendered!\n```\n\nIf you add `export const ssr = false` to your root `+layout.js`, your entire app will only be rendered on the client — which essentially means you turn your app into an SPA.\n\n> [!NOTE] If all your page options are boolean or string literal values, SvelteKit will evaluate them statically. If not, it will import your `+page.js` or `+layout.js` file on the server (both at build time, and at runtime if your app isn't fully static) so it can evaluate the options. In the second case, browser-only code must not run when the module is loaded. In practice, this means you should import browser-only code in your `+page.svelte` or `+layout.svelte` file instead.\n\n## csr\n\nOrdinarily, SvelteKit [hydrates](glossary#Hydration) your server-rendered HTML into an interactive client-side-rendered (CSR) page. Some pages don't require JavaScript at all — many blog posts and 'about' pages fall into this category. In these cases you can disable CSR:\n\n```js\n/// file: +page.js\nexport const csr = false;\n// If both `csr` and `ssr` are `false`, nothing will be rendered!\n```\n\nDisabling CSR does not ship any JavaScript to the client. This means:\n\n* The webpage should work with HTML and CSS only.\n* `\u003Cscript>` tags inside all Svelte components are removed.\n* `\u003Cform>` elements cannot be [progressively enhanced](form-actions#Progressive-enhancement).\n* Links are handled by the browser with a full-page navigation.\n* Hot Module Replacement (HMR) will be disabled.\n\nYou can enable `csr` during development (for example to take advantage of HMR) like so:\n\n```js\n/// file: +page.js\nimport { dev } from '$app/environment';\n\nexport const csr = dev;\n```\n\n## trailingSlash\n\nBy default, SvelteKit will remove trailing slashes from URLs — if you visit `/about/`, it will respond with a redirect to `/about`. You can change this behaviour with the `trailingSlash` option, which can be one of `'never'` (the default), `'always'`, or `'ignore'`.\n\nAs with other page options, you can export this value from a `+layout.js` or a `+layout.server.js` and it will apply to all child pages. You can also export the configuration from `+server.js` files.\n\n```js\n/// file: src/routes/+layout.js\nexport const trailingSlash = 'always';\n```\n\nThis option also affects [prerendering](#prerender). If `trailingSlash` is `always`, a route like `/about` will result in an `about/index.html` file, otherwise it will create `about.html`, mirroring static webserver conventions.\n\n> [!NOTE] Ignoring trailing slashes is not recommended — the semantics of relative paths differ between the two cases (`./y` from `/x` is `/y`, but from `/x/` is `/x/y`), and `/x` and `/x/` are treated as separate URLs which is harmful to SEO.\n\n## config\n\nWith the concept of [adapters](adapters), SvelteKit is able to run on a variety of platforms. Each of these might have specific configuration to further tweak the deployment — for example on Vercel you could choose to deploy some parts of your app on the edge and others on serverless environments.\n\n`config` is an object with key-value pairs at the top level. Beyond that, the concrete shape is dependent on the adapter you're using. Every adapter should provide a `Config` interface to import for type safety. Consult the documentation of your adapter for more information.\n\n```js\n// @filename: ambient.d.ts\ndeclare module 'some-adapter' {\n\texport interface Config { runtime: string }\n}\n\n// @filename: index.js\n// ---cut---\n/// file: src/routes/+page.js\n/** @type {import('some-adapter').Config} */\nexport const config = {\n\truntime: 'edge'\n};\n```\n\n`config` objects are merged at the top level (but _not_ deeper levels). This means you don't need to repeat all the values in a `+page.js` if you want to only override some of the values in the upper `+layout.js`. For example this layout configuration...\n\n```js\n/// file: src/routes/+layout.js\nexport const config = {\n\truntime: 'edge',\n\tregions: 'all',\n\tfoo: {\n\t\tbar: true\n\t}\n}\n```\n\n...is overridden by this page configuration...\n\n```js\n/// file: src/routes/+page.js\nexport const config = {\n\tregions: ['us1', 'us2'],\n\tfoo: {\n\t\tbaz: true\n\t}\n}\n```\n\n...which results in the config value `{ runtime: 'edge', regions: ['us1', 'us2'], foo: { baz: true } }` for that page.\n\n## Further reading\n\n- [Tutorial: Page options](/tutorial/kit/page-options)\n","## prerender\nExport `export const prerender = true` from `+page.js`, `+page.server.js`, `+server.js`, or layout files to generate static HTML at build time. Use `prerender = false` to disable for specific pages when enabled globally. Use `prerender = 'auto'` to allow dynamic server rendering as fallback.\n\nPages must return identical content for all users to be prerenderable. Cannot prerender pages with form actions. Specify which dynamic routes to prerender via `entries()` function:\n```js\nexport function entries() {\n  return [{ slug: 'hello-world' }, { slug: 'another-blog-post' }];\n}\nexport const prerender = true;\n```\n\n## ssr\nSet `export const ssr = false` to skip server-side rendering and send an empty shell to the client instead. Useful for pages using browser-only APIs. Setting in root layout converts entire app to SPA.\n\n## csr\nSet `export const csr = false` to disable client-side rendering. Results in no JavaScript shipped to client—pages work with HTML/CSS only, no script tags, no form progressive enhancement, full-page navigation only.\n\nCan conditionally enable during development:\n```js\nimport { dev } from '$app/environment';\nexport const csr = dev;\n```\n\n## trailingSlash\nControl trailing slash behavior with `export const trailingSlash = 'never' | 'always' | 'ignore'` (default: `'never'`). Affects both routing and prerendering output structure.\n\n## config\nExport adapter-specific configuration as `export const config = { ... }`. Objects merge at top level only, allowing child pages to override parent layout values without repeating unchanged properties.","## prerender\n`export const prerender = true/false/'auto'` generates static HTML at build time. Specify dynamic routes via `entries()` function. Pages must return identical content for all users.\n\n## ssr\n`export const ssr = false` skips server rendering, sends empty shell. Setting in root layout makes entire app client-only (SPA).\n\n## csr\n`export const csr = false` disables client-side rendering—no JavaScript shipped, HTML/CSS only, full-page navigation.\n\n## trailingSlash\n`export const trailingSlash = 'never' | 'always' | 'ignore'` controls URL trailing slash behavior.\n\n## config\n`export const config = { ... }` sets adapter-specific configuration, merged at top level only.","Export page options from layout and page files to control server rendering, prerendering, client rendering, trailing slashes, and adapter-specific configuration.","state-management",{"name":217,"path":219,"children":220,"data":221},"core-concepts/state-management",["Map"],{"type":22,"path":222,"relevant":44,"token_counts":223,"usage":227,"markdown":230},"20-core-concepts/50-state-management.md",{"fulltext":224,"digest":225,"short_digest":226},2189,635,174,{"input":228,"output":229,"details":32},3234,934,{"fulltext":231,"digest":232,"short_digest":233,"essence":234},"---\ntitle: State management\n---\n\nIf you're used to building client-only apps, state management in an app that spans server and client might seem intimidating. This section provides tips for avoiding some common gotchas.\n\n## Avoid shared state on the server\n\nBrowsers are _stateful_ — state is stored in memory as the user interacts with the application. Servers, on the other hand, are _stateless_ — the content of the response is determined entirely by the content of the request.\n\nConceptually, that is. In reality, servers are often long-lived and shared by multiple users. For that reason it's important not to store data in shared variables. For example, consider this code:\n\n```js\n// @errors: 7034 7005\n/// file: +page.server.js\nlet user;\n\n/** @type {import('./$types').PageServerLoad} */\nexport function load() {\n\treturn { user };\n}\n\n/** @satisfies {import('./$types').Actions} */\nexport const actions = {\n\tdefault: async ({ request }) => {\n\t\tconst data = await request.formData();\n\n\t\t// NEVER DO THIS!\n\t\tuser = {\n\t\t\tname: data.get('name'),\n\t\t\tembarrassingSecret: data.get('secret')\n\t\t};\n\t}\n}\n```\n\nThe `user` variable is shared by everyone who connects to this server. If Alice submitted an embarrassing secret, and Bob visited the page after her, Bob would know Alice's secret. In addition, when Alice returns to the site later in the day, the server may have restarted, losing her data.\n\nInstead, you should _authenticate_ the user using [`cookies`](load#Cookies) and persist the data to a database.\n\n## No side-effects in load\n\nFor the same reason, your `load` functions should be _pure_ — no side-effects (except maybe the occasional `console.log(...)`). For example, you might be tempted to write to a store or global state inside a `load` function so that you can use the value in your components:\n\n```js\n/// file: +page.js\n// @filename: ambient.d.ts\ndeclare module '$lib/user' {\n\texport const user: { set: (value: any) => void };\n}\n\n// @filename: index.js\n// ---cut---\nimport { user } from '$lib/user';\n\n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch }) {\n\tconst response = await fetch('/api/user');\n\n\t// NEVER DO THIS!\n\tuser.set(await response.json());\n}\n```\n\nAs with the previous example, this puts one user's information in a place that is shared by _all_ users. Instead, just return the data...\n\n```js\n/// file: +page.js\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ fetch }) {\n\tconst response = await fetch('/api/user');\n\n+++\treturn {\n\t\tuser: await response.json()\n\t};+++\n}\n```\n\n...and pass it around to the components that need it, or use [`page.data`](load#page.data).\n\nIf you're not using SSR, then there's no risk of accidentally exposing one user's data to another. But you should still avoid side-effects in your `load` functions — your application will be much easier to reason about without them.\n\n## Using state and stores with context\n\nYou might wonder how we're able to use `page.data` and other [app state]($app-state) (or [app stores]($app-stores)) if we can't use global state. The answer is that app state and app stores on the server use Svelte's [context API](/tutorial/svelte/context-api) — the state (or store) is attached to the component tree with `setContext`, and when you subscribe you retrieve it with `getContext`. We can do the same thing with our own state:\n\n```svelte\n\u003C!--- file: src/routes/+layout.svelte --->\n\u003Cscript>\n\timport { setContext } from 'svelte';\n\n\t/** @type {import('./$types').LayoutProps} */\n\tlet { data } = $props();\n\n\t// Pass a function referencing our state\n\t// to the context for child components to access\n\tsetContext('user', () => data.user);\n\u003C/script>\n```\n\n```svelte\n\u003C!--- file: src/routes/user/+page.svelte --->\n\u003Cscript>\n\timport { getContext } from 'svelte';\n\n\t// Retrieve user store from context\n\tconst user = getContext('user');\n\u003C/script>\n\n\u003Cp>Welcome {user().name}\u003C/p>\n```\n\n> [!NOTE] We're passing a function into `setContext` to keep reactivity across boundaries. Read more about it [here](/docs/svelte/$state#Passing-state-into-functions)\n\n> [!LEGACY]\n> You also use stores from `svelte/store` for this, but when using Svelte 5 it is recommended to make use of universal reactivity instead.\n\nUpdating the value of context-based state in deeper-level pages or components while the page is being rendered via SSR will not affect the value in the parent component because it has already been rendered by the time the state value is updated. In contrast, on the client (when CSR is enabled, which is the default) the value will be propagated and components, pages, and layouts higher in the hierarchy will react to the new value. Therefore, to avoid values 'flashing' during state updates during hydration, it is generally recommended to pass state down into components rather than up.\n\nIf you're not using SSR (and can guarantee that you won't need to use SSR in future) then you can safely keep state in a shared module, without using the context API.\n\n## Component and page state is preserved\n\nWhen you navigate around your application, SvelteKit reuses existing layout and page components. For example, if you have a route like this...\n\n```svelte\n\u003C!--- file: src/routes/blog/[slug]/+page.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\n\t// THIS CODE IS BUGGY!\n\tconst wordCount = data.content.split(' ').length;\n\tconst estimatedReadingTime = wordCount / 250;\n\u003C/script>\n\n\u003Cheader>\n\t\u003Ch1>{data.title}\u003C/h1>\n\t\u003Cp>Reading time: {Math.round(estimatedReadingTime)} minutes\u003C/p>\n\u003C/header>\n\n\u003Cdiv>{@html data.content}\u003C/div>\n```\n\n...then navigating from `/blog/my-short-post` to `/blog/my-long-post` won't cause the layout, page and any other components within to be destroyed and recreated. Instead the `data` prop (and by extension `data.title` and `data.content`) will update (as it would with any other Svelte component) and, because the code isn't rerunning, lifecycle methods like `onMount` and `onDestroy` won't rerun and `estimatedReadingTime` won't be recalculated.\n\nInstead, we need to make the value [_reactive_](/tutorial/svelte/state):\n\n```svelte\n/// file: src/routes/blog/[slug]/+page.svelte\n\u003Cscript>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\n+++\tlet wordCount = $derived(data.content.split(' ').length);\n\tlet estimatedReadingTime = $derived(wordCount / 250);+++\n\u003C/script>\n```\n\n> [!NOTE] If your code in `onMount` and `onDestroy` has to run again after navigation you can use [afterNavigate]($app-navigation#afterNavigate) and [beforeNavigate]($app-navigation#beforeNavigate) respectively.\n\nReusing components like this means that things like sidebar scroll state are preserved, and you can easily animate between changing values. In the case that you do need to completely destroy and remount a component on navigation, you can use this pattern:\n\n```svelte\n\u003Cscript>\n\timport { page } from '$app/state';\n\u003C/script>\n\n{#key page.url.pathname}\n\t\u003CBlogPost title={data.title} content={data.title} />\n{/key}\n```\n\n## Storing state in the URL\n\nIf you have state that should survive a reload and/or affect SSR, such as filters or sorting rules on a table, URL search parameters (like `?sort=price&order=ascending`) are a good place to put them. You can put them in `\u003Ca href=\"...\">` or `\u003Cform action=\"...\">` attributes, or set them programmatically via `goto('?key=value')`. They can be accessed inside `load` functions via the `url` parameter, and inside components via `page.url.searchParams`.\n\n## Storing ephemeral state in snapshots\n\nSome UI state, such as 'is the accordion open?', is disposable — if the user navigates away or refreshes the page, it doesn't matter if the state is lost. In some cases, you _do_ want the data to persist if the user navigates to a different page and comes back, but storing the state in the URL or in a database would be overkill. For this, SvelteKit provides [snapshots](snapshots), which let you associate component state with a history entry.\n","## Avoid shared state on the server\n\nServers are stateless and shared by multiple users. Don't store data in shared variables — this exposes one user's data to others and causes data loss on server restart. Instead, authenticate users with cookies and persist data to a database.\n\n## No side-effects in load functions\n\nLoad functions should be pure. Don't write to stores or global state inside load functions:\n\n```js\n// WRONG\nimport { user } from '$lib/user';\nexport async function load({ fetch }) {\n\tconst response = await fetch('/api/user');\n\tuser.set(await response.json()); // Shared by all users!\n}\n\n// RIGHT\nexport async function load({ fetch }) {\n\tconst response = await fetch('/api/user');\n\treturn { user: await response.json() };\n}\n```\n\nReturn data and pass it to components that need it, or use `page.data`.\n\n## Using state and stores with context\n\nUse Svelte's context API to safely share state on the server:\n\n```svelte\n\u003C!-- +layout.svelte -->\n\u003Cscript>\n\timport { setContext } from 'svelte';\n\tlet { data } = $props();\n\tsetContext('user', () => data.user);\n\u003C/script>\n\n\u003C!-- +page.svelte -->\n\u003Cscript>\n\timport { getContext } from 'svelte';\n\tconst user = getContext('user');\n\u003C/script>\n\u003Cp>Welcome {user().name}\u003C/p>\n```\n\nPass functions into context to maintain reactivity. During SSR, state updates in child components don't affect parent components (already rendered), but on the client they do. Pass state down rather than up to avoid flashing during hydration.\n\n## Component and page state is preserved\n\nWhen navigating between routes with the same layout/page component, the component isn't destroyed — it's reused. This means `onMount`/`onDestroy` don't rerun and local state persists. Make dependent values reactive:\n\n```svelte\n\u003Cscript>\n\tlet { data } = $props();\n\tlet wordCount = $derived(data.content.split(' ').length);\n\tlet estimatedReadingTime = $derived(wordCount / 250);\n\u003C/script>\n```\n\nTo destroy and remount on navigation, use `{#key page.url.pathname}`.\n\n## Storing state in the URL\n\nFor state that should survive reloads or affect SSR (filters, sorting), use URL search parameters: `?sort=price&order=ascending`. Access them in load functions via `url` parameter or in components via `page.url.searchParams`.\n\n## Storing ephemeral state in snapshots\n\nFor disposable UI state like 'is accordion open?', use snapshots to associate component state with history entries.","**Avoid shared state on server** — don't store data in shared variables; use cookies and databases instead.\n\n**No side-effects in load** — return data instead of writing to stores:\n```js\nexport async function load({ fetch }) {\n\treturn { user: await fetch('/api/user').then(r => r.json()) };\n}\n```\n\n**Use context API for safe state sharing** — pass functions into context to maintain reactivity across SSR boundaries.\n\n**Component state is preserved** — make dependent values reactive with `$derived` when data changes.\n\n**URL search parameters** — store state that needs to survive reloads: `?sort=price&order=ascending`.\n\n**Snapshots** — preserve ephemeral UI state across navigation.","Guidelines for managing state in server-rendered and client-side applications, covering shared state pitfalls, load function purity, context API usage, component lifecycle preservation, and state persistence strategies.","remote-functions",{"name":235,"path":237,"children":238,"data":239},"core-concepts/remote-functions",["Map"],{"type":22,"path":240,"relevant":44,"token_counts":241,"usage":245,"markdown":248},"20-core-concepts/60-remote-functions.md",{"fulltext":242,"digest":243,"short_digest":244},11261,1123,341,{"input":246,"output":247,"details":32},12306,1587,{"fulltext":249,"digest":250,"short_digest":251,"essence":252},"---\ntitle: Remote functions\n---\n\n\u003Cblockquote class=\"since note\">\n\t\u003Cp>Available since 2.27\u003C/p>\n\u003C/blockquote>\n\nRemote functions are a tool for type-safe communication between client and server. They can be _called_ anywhere in your app, but always _run_ on the server, meaning they can safely access [server-only modules](server-only-modules) containing things like environment variables and database clients.\n\nCombined with Svelte's experimental support for [`await`](/docs/svelte/await-expressions), it allows you to load and manipulate data directly inside your components.\n\nThis feature is currently experimental, meaning it is likely to contain bugs and is subject to change without notice. You must opt in by adding the `kit.experimental.remoteFunctions` option in your `svelte.config.js` and optionally, the `compilerOptions.experimental.async` option to use `await` in components:\n\n```js\n/// file: svelte.config.js\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\texperimental: {\n\t\t\t+++remoteFunctions: true+++\n\t\t}\n\t},\n\tcompilerOptions: {\n\t\texperimental: {\n\t\t\t+++async: true+++\n\t\t}\n\t}\n};\n\nexport default config;\n```\n\n## Overview\n\nRemote functions are exported from a `.remote.js` or `.remote.ts` file, and come in four flavours: `query`, `form`, `command` and `prerender`. On the client, the exported functions are transformed to `fetch` wrappers that invoke their counterparts on the server via a generated HTTP endpoint. Remote files can be placed anywhere in your `src` directory (except inside the `src/lib/server` directory), and third party libraries can provide them, too.\n\n## query\n\nThe `query` function allows you to read dynamic data from the server (for _static_ data, consider using [`prerender`](#prerender) instead):\n\n```js\n/// file: src/routes/blog/data.remote.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function sql(strings: TemplateStringsArray, ...values: any[]): Promise\u003Cany[]>;\n}\n// @filename: index.js\n// ---cut---\nimport { query } from '$app/server';\nimport * as db from '$lib/server/database';\n\nexport const getPosts = query(async () => {\n\tconst posts = await db.sql`\n\t\tSELECT title, slug\n\t\tFROM post\n\t\tORDER BY published_at\n\t\tDESC\n\t`;\n\n\treturn posts;\n});\n```\n\n> [!NOTE] Throughout this page, you'll see imports from fictional modules like `$lib/server/database` and `$lib/server/auth`. These are purely for illustrative purposes — you can use whatever database client and auth setup you like.\n>\n> The `db.sql` function above is a [tagged template function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates) that escapes any interpolated values.\n\nThe query returned from `getPosts` works as a [`Promise`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) that resolves to `posts`:\n\n```svelte\n\u003C!--- file: src/routes/blog/+page.svelte --->\n\u003Cscript>\n\timport { getPosts } from './data.remote';\n\u003C/script>\n\n\u003Ch1>Recent posts\u003C/h1>\n\n\u003Cul>\n\t{#each await getPosts() as { title, slug }}\n\t\t\u003Cli>\u003Ca href=\"/blog/{slug}\">{title}\u003C/a>\u003C/li>\n\t{/each}\n\u003C/ul>\n```\n\nUntil the promise resolves — and if it errors — the nearest [`\u003Csvelte:boundary>`](../svelte/svelte-boundary) will be invoked.\n\nWhile using `await` is recommended, as an alternative the query also has `loading`, `error` and `current` properties:\n\n```svelte\n\u003C!--- file: src/routes/blog/+page.svelte --->\n\u003Cscript>\n\timport { getPosts } from './data.remote';\n\n\tconst query = getPosts();\n\u003C/script>\n\n\u003Ch1>Recent posts\u003C/h1>\n\n{#if query.error}\n\t\u003Cp>oops!\u003C/p>\n{:else if query.loading}\n\t\u003Cp>loading...\u003C/p>\n{:else}\n\t\u003Cul>\n\t\t{#each query.current as { title, slug }}\n\t\t\t\u003Cli>\u003Ca href=\"/blog/{slug}\">{title}\u003C/a>\u003C/li>\n\t\t{/each}\n\t\u003C/ul>\n{/if}\n```\n\n> [!NOTE] For the rest of this document, we'll use the `await` form.\n\n### Query arguments\n\nQuery functions can accept an argument, such as the `slug` of an individual post:\n\n```svelte\n\u003C!--- file: src/routes/blog/[slug]/+page.svelte --->\n\u003Cscript>\n\timport { getPost } from '../data.remote';\n\n\tlet { params } = $props();\n\n\tconst post = $derived(await getPost(params.slug));\n\u003C/script>\n\n\u003Ch1>{post.title}\u003C/h1>\n\u003Cdiv>{@html post.content}\u003C/div>\n```\n\nSince `getPost` exposes an HTTP endpoint, it's important to validate this argument to be sure that it's the correct type. For this, we can use any [Standard Schema](https://standardschema.dev/) validation library such as [Zod](https://zod.dev/) or [Valibot](https://valibot.dev/):\n\n```js\n/// file: src/routes/blog/data.remote.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function sql(strings: TemplateStringsArray, ...values: any[]): Promise\u003Cany[]>;\n}\n// @filename: index.js\n// ---cut---\nimport * as v from 'valibot';\nimport { error } from '@sveltejs/kit';\nimport { query } from '$app/server';\nimport * as db from '$lib/server/database';\n\nexport const getPosts = query(async () => { /* ... */ });\n\nexport const getPost = query(v.string(), async (slug) => {\n\tconst [post] = await db.sql`\n\t\tSELECT * FROM post\n\t\tWHERE slug = ${slug}\n\t`;\n\n\tif (!post) error(404, 'Not found');\n\treturn post;\n});\n```\n\nBoth the argument and the return value are serialized with [devalue](https://github.com/sveltejs/devalue), which handles types like `Date` and `Map` (and custom types defined in your [transport hook](hooks#Universal-hooks-transport)) in addition to JSON.\n\n### Refreshing queries\n\nAny query can be re-fetched via its `refresh` method, which retrieves the latest value from the server:\n\n```svelte\n\u003Cbutton onclick={() => getPosts().refresh()}>\n\tCheck for new posts\n\u003C/button>\n```\n\n> [!NOTE] Queries are cached while they're on the page, meaning `getPosts() === getPosts()`. This means you don't need a reference like `const posts = getPosts()` in order to update the query.\n\n## query.batch\n\n`query.batch` works like `query` except that it batches requests that happen within the same macrotask. This solves the so-called n+1 problem: rather than each query resulting in a separate database call (for example), simultaneous queries are grouped together.\n\nOn the server, the callback receives an array of the arguments the function was called with. It must return a function of the form `(input: Input, index: number) => Output`. SvelteKit will then call this with each of the input arguments to resolve the individual calls with their results.\n\n```js\n/// file: weather.remote.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function sql(strings: TemplateStringsArray, ...values: any[]): Promise\u003Cany[]>;\n}\n// @filename: index.js\n// ---cut---\nimport * as v from 'valibot';\nimport { query } from '$app/server';\nimport * as db from '$lib/server/database';\n\nexport const getWeather = query.batch(v.string(), async (cities) => {\n\tconst weather = await db.sql`\n\t\tSELECT * FROM weather\n\t\tWHERE city = ANY(${cities})\n\t`;\n\tconst lookup = new Map(weather.map(w => [w.city, w]));\n\n\treturn (city) => lookup.get(city);\n});\n```\n\n```svelte\n\u003C!--- file: Weather.svelte --->\n\u003Cscript>\n\timport CityWeather from './CityWeather.svelte';\n\timport { getWeather } from './weather.remote.js';\n\n\tlet { cities } = $props();\n\tlet limit = $state(5);\n\u003C/script>\n\n\u003Ch2>Weather\u003C/h2>\n\n{#each cities.slice(0, limit) as city}\n\t\u003Ch3>{city.name}\u003C/h3>\n\t\u003CCityWeather weather={await getWeather(city.id)} />\n{/each}\n\n{#if cities.length > limit}\n\t\u003Cbutton onclick={() => limit += 5}>\n\t\tLoad more\n\t\u003C/button>\n{/if}\n```\n\n## form\n\nThe `form` function makes it easy to write data to the server. It takes a callback that receives `data` constructed from the submitted [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData)...\n\n```ts\n/// file: src/routes/blog/data.remote.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function sql(strings: TemplateStringsArray, ...values: any[]): Promise\u003Cany[]>;\n}\n\ndeclare module '$lib/server/auth' {\n\tinterface User {\n\t\tname: string;\n\t}\n\n\t/**\n\t * Gets a user's info from their cookies, using `getRequestEvent`\n\t */\n\texport function getUser(): Promise\u003CUser | null>;\n}\n// @filename: index.js\n// ---cut---\nimport * as v from 'valibot';\nimport { error, redirect } from '@sveltejs/kit';\nimport { query, form } from '$app/server';\nimport * as db from '$lib/server/database';\nimport * as auth from '$lib/server/auth';\n\nexport const getPosts = query(async () => { /* ... */ });\n\nexport const getPost = query(v.string(), async (slug) => { /* ... */ });\n\nexport const createPost = form(\n\tv.object({\n\t\ttitle: v.pipe(v.string(), v.nonEmpty()),\n\t\tcontent:v.pipe(v.string(), v.nonEmpty())\n\t}),\n\tasync ({ title, content }) => {\n\t\t// Check the user is logged in\n\t\tconst user = await auth.getUser();\n\t\tif (!user) error(401, 'Unauthorized');\n\n\t\tconst slug = title.toLowerCase().replace(/ /g, '-');\n\n\t\t// Insert into the database\n\t\tawait db.sql`\n\t\t\tINSERT INTO post (slug, title, content)\n\t\t\tVALUES (${slug}, ${title}, ${content})\n\t\t`;\n\n\t\t// Redirect to the newly created page\n\t\tredirect(303, `/blog/${slug}`);\n\t}\n);\n```\n\n...and returns an object that can be spread onto a `\u003Cform>` element. The callback is called whenever the form is submitted.\n\n```svelte\n\u003C!--- file: src/routes/blog/new/+page.svelte --->\n\u003Cscript>\n\timport { createPost } from '../data.remote';\n\u003C/script>\n\n\u003Ch1>Create a new post\u003C/h1>\n\n\u003Cform {...createPost}>\n\t\u003C!-- form content goes here -->\n\n\t\u003Cbutton>Publish!\u003C/button>\n\u003C/form>\n```\n\nThe form object contains `method` and `action` properties that allow it to work without JavaScript (i.e. it submits data and reloads the page). It also has an [attachment](/docs/svelte/@attach) that progressively enhances the form when JavaScript is available, submitting data *without* reloading the entire page.\n\nAs with `query`, if the callback uses the submitted `data`, it should be [validated](#query-Query-arguments) by passing a [Standard Schema](https://standardschema.dev) as the first argument to `form`.\n\n### Fields\n\nA form is composed of a set of _fields_, which are defined by the schema. In the case of `createPost`, we have two fields, `title` and `content`, which are both strings. To get the attributes for a field, call its `.as(...)` method, specifying which [input type](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#input_types) to use:\n\n```svelte\n\u003Cform {...createPost}>\n\t\u003Clabel>\n\t\t\u003Ch2>Title\u003C/h2>\n\t\t+++\u003Cinput {...createPost.fields.title.as('text')} />+++\n\t\u003C/label>\n\n\t\u003Clabel>\n\t\t\u003Ch2>Write your post\u003C/h2>\n\t\t+++\u003Ctextarea {...createPost.fields.content.as('text')}>\u003C/textarea>+++\n\t\u003C/label>\n\n\t\u003Cbutton>Publish!\u003C/button>\n\u003C/form>\n```\n\nThese attributes allow SvelteKit to set the correct input type, set a `name` that is used to construct the `data` passed to the handler, populate the `value` of the form (for example following a failed submission, to save the user having to re-enter everything), and set the [`aria-invalid`](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-invalid) state.\n\n> [!NOTE] The generated `name` attribute uses JS object notation (e.g. `nested.array[0].value`). String keys that require quotes such as `object['nested-array'][0].value` are not supported. Under the hood, boolean checkbox and number field names are prefixed with `b:` and `n:`, respectively, to signal SvelteKit to coerce the values from strings prior to validation.\n\nFields can be nested in objects and arrays, and their values can be strings, numbers, booleans or `File` objects. For example, if your schema looked like this...\n\n```js\n/// file: data.remote.js\nimport * as v from 'valibot';\nimport { form } from '$app/server';\n// ---cut---\nconst datingProfile = v.object({\n\tname: v.string(),\n\tphoto: v.file(),\n\tinfo: v.object({\n\t\theight: v.number(),\n\t\tlikesDogs: v.optional(v.boolean(), false)\n\t}),\n\tattributes: v.array(v.string())\n});\n\nexport const createProfile = form(datingProfile, (data) => { /* ... */ });\n```\n\n...your form could look like this:\n\n```svelte\n\u003Cscript>\n\timport { createProfile } from './data.remote';\n\n\tconst { name, photo, info, attributes } = createProfile.fields;\n\u003C/script>\n\n\u003Cform {...createProfile} enctype=\"multipart/form-data\">\n\t\u003Clabel>\n\t\t\u003Cinput {...name.as('text')} /> Name\n\t\u003C/label>\n\n\t\u003Clabel>\n\t\t\u003Cinput {...photo.as('file')} /> Photo\n\t\u003C/label>\n\n\t\u003Clabel>\n\t\t\u003Cinput {...info.height.as('number')} /> Height (cm)\n\t\u003C/label>\n\n\t\u003Clabel>\n\t\t\u003Cinput {...info.likesDogs.as('checkbox')} /> I like dogs\n\t\u003C/label>\n\n\t\u003Ch2>My best attributes\u003C/h2>\n\t\u003Cinput {...attributes[0].as('text')} />\n\t\u003Cinput {...attributes[1].as('text')} />\n\t\u003Cinput {...attributes[2].as('text')} />\n\n\t\u003Cbutton>submit\u003C/button>\n\u003C/form>\n```\n\nBecause our form contains a `file` input, we've added an `enctype=\"multipart/form-data\"` attribute. The values for `info.height` and `info.likesDogs` are coerced to a number and a boolean respectively.\n\n> [!NOTE] If a `checkbox` input is unchecked, the value is not included in the [`FormData`](https://developer.mozilla.org/en-US/docs/Web/API/FormData) object that SvelteKit constructs the data from. As such, we have to make the value optional in our schema. In Valibot that means using `v.optional(v.boolean(), false)` instead of just `v.boolean()`, whereas in Zod it would mean using `z.coerce.boolean\u003Cboolean>()`.\n\nIn the case of `radio` and `checkbox` inputs that all belong to the same field, the `value` must be specified as a second argument to `.as(...)`:\n\n```js\n/// file: data.remote.js\nimport * as v from 'valibot';\nimport { form } from '$app/server';\n// ---cut---\nexport const survey = form(\n\tv.object({\n\t\toperatingSystem: v.picklist(['windows', 'mac', 'linux']),\n\t\tlanguages: v.optional(v.array(v.picklist(['html', 'css', 'js'])), [])\n\t}),\n\t(data) => { /* ... */ }\n);\n```\n\n```svelte\n\u003Cform {...survey}>\n\t\u003Ch2>Which operating system do you use?\u003C/h2>\n\n\t{#each ['windows', 'mac', 'linux'] as os}\n\t\t\u003Clabel>\n\t\t\t\u003Cinput {...survey.fields.operatingSystem.as('radio', os)}>\n\t\t\t{os}\n\t\t\u003C/label>\n\t{/each}\n\n\t\u003Ch2>Which languages do you write code in?\u003C/h2>\n\n\t{#each ['html', 'css', 'js'] as language}\n\t\t\u003Clabel>\n\t\t\t\u003Cinput {...survey.fields.languages.as('checkbox', language)}>\n\t\t\t{language}\n\t\t\u003C/label>\n\t{/each}\n\n\t\u003Cbutton>submit\u003C/button>\n\u003C/form>\n```\n\nAlternatively, you could use `select` and `select multiple`:\n\n```svelte\n\u003Cform {...survey}>\n\t\u003Ch2>Which operating system do you use?\u003C/h2>\n\n\t\u003Cselect {...survey.fields.operatingSystem.as('select')}>\n\t\t\u003Coption>windows\u003C/option>\n\t\t\u003Coption>mac\u003C/option>\n\t\t\u003Coption>linux\u003C/option>\n\t\u003C/select>\n\n\t\u003Ch2>Which languages do you write code in?\u003C/h2>\n\n\t\u003Cselect {...survey.fields.languages.as('select multiple')}>\n\t\t\u003Coption>html\u003C/option>\n\t\t\u003Coption>css\u003C/option>\n\t\t\u003Coption>js\u003C/option>\n\t\u003C/select>\n\n\t\u003Cbutton>submit\u003C/button>\n\u003C/form>\n```\n\n> [!NOTE] As with unchecked `checkbox` inputs, if no selections are made then the data will be `undefined`. For this reason, the `languages` field uses `v.optional(v.array(...), [])` rather than just `v.array(...)`.\n\n### Programmatic validation\n\nIn addition to declarative schema validation, you can programmatically mark fields as invalid inside the form handler using the `invalid` function. This is useful for cases where you can't know if something is valid until you try to perform some action:\n\n```js\n/// file: src/routes/shop/data.remote.js\nimport * as v from 'valibot';\nimport { form } from '$app/server';\nimport * as db from '$lib/server/database';\n\nexport const buyHotcakes = form(\n\tv.object({\n\t\tqty: v.pipe(\n\t\t\tv.number(),\n\t\t\tv.minValue(1, 'you must buy at least one hotcake')\n\t\t)\n\t}),\n\tasync (data, invalid) => {\n\t\ttry {\n\t\t\tawait db.buy(data.qty);\n\t\t} catch (e) {\n\t\t\tif (e.code === 'OUT_OF_STOCK') {\n\t\t\t\tinvalid(\n\t\t\t\t\tinvalid.qty(`we don't have enough hotcakes`)\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}\n);\n```\n\nThe `invalid` function works as both a function and a proxy:\n\n- Call `invalid(issue1, issue2, ...issueN)` to throw a validation error\n- If an issue is a `string`, it applies to the form as a whole (and will show up in `fields.allIssues()`)\n- Use `invalid.fieldName(message)` to create an issue for a specific field. Like `fields` this is type-safe and you can use regular property access syntax to create issues for deeply nested objects (e.g. `invalid.profile.email('Email already exists')` or `invalid.items[0].qty('Insufficient stock')`)\n\n### Validation\n\nIf the submitted data doesn't pass the schema, the callback will not run. Instead, each invalid field's `issues()` method will return an array of `{ message: string }` objects, and the `aria-invalid` attribute (returned from `as(...)`) will be set to `true`:\n\n```svelte\n\u003Cform {...createPost}>\n\t\u003Clabel>\n\t\t\u003Ch2>Title\u003C/h2>\n\n+++\t\t{#each createPost.fields.title.issues() as issue}\n\t\t\t\u003Cp class=\"issue\">{issue.message}\u003C/p>\n\t\t{/each}+++\n\n\t\t\u003Cinput {...createPost.fields.title.as('text')} />\n\t\u003C/label>\n\n\t\u003Clabel>\n\t\t\u003Ch2>Write your post\u003C/h2>\n\n+++\t\t{#each createPost.fields.content.issues() as issue}\n\t\t\t\u003Cp class=\"issue\">{issue.message}\u003C/p>\n\t\t{/each}+++\n\n\t\t\u003Ctextarea {...createPost.fields.content.as('text')}>\u003C/textarea>\n\t\u003C/label>\n\n\t\u003Cbutton>Publish!\u003C/button>\n\u003C/form>\n```\n\nYou don't need to wait until the form is submitted to validate the data — you can call `validate()` programmatically, for example in an `oninput` callback (which will validate the data on every keystroke) or an `onchange` callback:\n\n```svelte\n\u003Cform {...createPost} oninput={() => createPost.validate()}>\n\t\u003C!-- -->\n\u003C/form>\n```\n\nBy default, issues will be ignored if they belong to form controls that haven't yet been interacted with. To validate _all_ inputs, call `validate({ includeUntouched: true })`.\n\nFor client-side validation, you can specify a _preflight_ schema which will populate `issues()` and prevent data being sent to the server if the data doesn't validate:\n\n```svelte\n\u003Cscript>\n\timport * as v from 'valibot';\n\timport { createPost } from '../data.remote';\n\n\tconst schema = v.object({\n\t\ttitle: v.pipe(v.string(), v.nonEmpty()),\n\t\tcontent: v.pipe(v.string(), v.nonEmpty())\n\t});\n\u003C/script>\n\n\u003Ch1>Create a new post\u003C/h1>\n\n\u003Cform {...+++createPost.preflight(schema)+++}>\n\t\u003C!-- -->\n\u003C/form>\n```\n\n> [!NOTE] The preflight schema can be the same object as your server-side schema, if appropriate, though it won't be able to do server-side checks like 'this value already exists in the database'. Note that you cannot export a schema from a `.remote.ts` or `.remote.js` file, so the schema must either be exported from a shared module, or from a `\u003Cscript module>` block in the component containing the `\u003Cform>`.\n\nTo get a list of _all_ issues, rather than just those belonging to a single field, you can use the `fields.allIssues()` method:\n\n```svelte\n{#each createPost.fields.allIssues() as issue}\n\t\u003Cp>{issue.message}\u003C/p>\n{/each}\n```\n\n### Getting/setting inputs\n\nEach field has a `value()` method that reflects its current value. As the user interacts with the form, it is automatically updated:\n\n```svelte\n\u003Cform {...createPost}>\n\t\u003C!-- -->\n\u003C/form>\n\n\u003Cdiv class=\"preview\">\n\t\u003Ch2>{createPost.fields.title.value()}\u003C/h2>\n\t\u003Cdiv>{@html render(createPost.fields.content.value())}\u003C/div>\n\u003C/div>\n```\n\nAlternatively, `createPost.fields.value()` would return a `{ title, content }` object.\n\nYou can update a field (or a collection of fields) via the `set(...)` method:\n\n```svelte\n\u003Cscript>\n\timport { createPost } from '../data.remote';\n\n\t// this...\n\tcreatePost.fields.set({\n\t\ttitle: 'My new blog post',\n\t\tcontent: 'Lorem ipsum dolor sit amet...'\n\t});\n\n\t// ...is equivalent to this:\n\tcreatePost.fields.title.set('My new blog post');\n\tcreatePost.fields.content.set('Lorem ipsum dolor sit amet');\n\u003C/script>\n```\n\n### Handling sensitive data\n\nIn the case of a non-progressively-enhanced form submission (i.e. where JavaScript is unavailable, for whatever reason) `value()` is also populated if the submitted data is invalid, so that the user does not need to fill the entire form out from scratch.\n\nYou can prevent sensitive data (such as passwords and credit card numbers) from being sent back to the user by using a name with a leading underscore:\n\n```svelte\n\u003Cform {...register}>\n\t\u003Clabel>\n\t\tUsername\n\t\t\u003Cinput {...register.fields.username.as('text')} />\n\t\u003C/label>\n\n\t\u003Clabel>\n\t\tPassword\n\t\t\u003Cinput +++{...register.fields._password.as('password')}+++ />\n\t\u003C/label>\n\n\t\u003Cbutton>Sign up!\u003C/button>\n\u003C/form>\n```\n\nIn this example, if the data does not validate, only the first `\u003Cinput>` will be populated when the page reloads.\n\n### Single-flight mutations\n\nBy default, all queries used on the page (along with any `load` functions) are automatically refreshed following a successful form submission. This ensures that everything is up-to-date, but it's also inefficient: many queries will be unchanged, and it requires a second trip to the server to get the updated data.\n\nInstead, we can specify which queries should be refreshed in response to a particular form submission. This is called a _single-flight mutation_, and there are two ways to achieve it. The first is to refresh the query on the server, inside the form handler:\n\n```js\nimport * as v from 'valibot';\nimport { error, redirect } from '@sveltejs/kit';\nimport { query, form } from '$app/server';\nconst slug = '';\nconst post = { id: '' };\n/** @type {any} */\nconst externalApi = '';\n// ---cut---\nexport const getPosts = query(async () => { /* ... */ });\n\nexport const getPost = query(v.string(), async (slug) => { /* ... */ });\n\nexport const createPost = form(\n\tv.object({/* ... */}),\n\tasync (data) => {\n\t\t// form logic goes here...\n\n\t\t// Refresh `getPosts()` on the server, and send\n\t\t// the data back with the result of `createPost`\n\t\t+++await getPosts().refresh();+++\n\n\t\t// Redirect to the newly created page\n\t\tredirect(303, `/blog/${slug}`);\n\t}\n);\n\nexport const updatePost = form(\n\tv.object({/* ... */}),\n\tasync (data) => {\n\t\t// form logic goes here...\n\t\tconst result = externalApi.update(post);\n\n\t\t// The API already gives us the updated post,\n\t\t// no need to refresh it, we can set it directly\n\t\t+++await getPost(post.id).set(result);+++\n\t}\n);\n```\n\nThe second is to drive the single-flight mutation from the client, which we'll see in the section on [`enhance`](#form-enhance).\n\n### Returns and redirects\n\nThe example above uses [`redirect(...)`](@sveltejs-kit#redirect), which sends the user to the newly created page. Alternatively, the callback could return data, in which case it would be available as `createPost.result`:\n\n```ts\n/// file: src/routes/blog/data.remote.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function sql(strings: TemplateStringsArray, ...values: any[]): Promise\u003Cany[]>;\n}\n\ndeclare module '$lib/server/auth' {\n\tinterface User {\n\t\tname: string;\n\t}\n\n\t/**\n\t * Gets a user's info from their cookies, using `getRequestEvent`\n\t */\n\texport function getUser(): Promise\u003CUser | null>;\n}\n// @filename: index.js\nimport * as v from 'valibot';\nimport { error, redirect } from '@sveltejs/kit';\nimport { query, form } from '$app/server';\nimport * as db from '$lib/server/database';\nimport * as auth from '$lib/server/auth';\n\nexport const getPosts = query(async () => { /* ... */ });\n\nexport const getPost = query(v.string(), async (slug) => { /* ... */ });\n\n// ---cut---\nexport const createPost = form(\n\tv.object({/* ... */}),\n\tasync (data) => {\n\t\t// ...\n\n\t\treturn { success: true };\n\t}\n);\n```\n\n```svelte\n\u003C!--- file: src/routes/blog/new/+page.svelte --->\n\u003Cscript>\n\timport { createPost } from '../data.remote';\n\u003C/script>\n\n\u003Ch1>Create a new post\u003C/h1>\n\n\u003Cform {...createPost}>\n\t\u003C!-- -->\n\u003C/form>\n\n{#if createPost.result?.success}\n\t\u003Cp>Successfully published!\u003C/p>\n{/if}\n```\n\nThis value is _ephemeral_ — it will vanish if you resubmit, navigate away, or reload the page.\n\n> [!NOTE] The `result` value need not indicate success — it can also contain validation errors, along with any data that should repopulate the form on page reload.\n\nIf an error occurs during submission, the nearest `+error.svelte` page will be rendered.\n\n### enhance\n\nWe can customize what happens when the form is submitted with the `enhance` method:\n\n```svelte\n\u003C!--- file: src/routes/blog/new/+page.svelte --->\n\u003Cscript>\n\timport { createPost } from '../data.remote';\n\timport { showToast } from '$lib/toast';\n\u003C/script>\n\n\u003Ch1>Create a new post\u003C/h1>\n\n\u003Cform {...createPost.enhance(async ({ form, data, submit }) => {\n\ttry {\n\t\tawait submit();\n\t\tform.reset();\n\n\t\tshowToast('Successfully published!');\n\t} catch (error) {\n\t\tshowToast('Oh no! Something went wrong');\n\t}\n})}>\n\t\u003C!-- -->\n\u003C/form>\n```\n\n> When using `enhance`, the `\u003Cform>` is not automatically reset — you must call `form.reset()` if you want to clear the inputs.\n\nThe callback receives the `form` element, the `data` it contains, and a `submit` function.\n\nTo enable client-driven [single-flight mutations](#form-Single-flight-mutations), use `submit().updates(...)`. For example, if the `getPosts()` query was used on this page, we could refresh it like so:\n\n```ts\nimport type { RemoteQuery, RemoteQueryOverride } from '@sveltejs/kit';\ninterface Post {}\ndeclare function submit(): Promise\u003Cany> & {\n\tupdates(...queries: Array\u003CRemoteQuery\u003Cany> | RemoteQueryOverride>): Promise\u003Cany>;\n}\n\ndeclare function getPosts(): RemoteQuery\u003CPost[]>;\n// ---cut---\nawait submit().updates(getPosts());\n```\n\nWe can also _override_ the current data while the submission is ongoing:\n\n```ts\nimport type { RemoteQuery, RemoteQueryOverride } from '@sveltejs/kit';\ninterface Post {}\ndeclare function submit(): Promise\u003Cany> & {\n\tupdates(...queries: Array\u003CRemoteQuery\u003Cany> | RemoteQueryOverride>): Promise\u003Cany>;\n}\n\ndeclare function getPosts(): RemoteQuery\u003CPost[]>;\ndeclare const newPost: Post;\n// ---cut---\nawait submit().updates(\n\tgetPosts().withOverride((posts) => [newPost, ...posts])\n);\n```\n\nThe override will be applied immediately, and released when the submission completes (or fails).\n\n### Multiple instances of a form\n\nSome forms may be repeated as part of a list. In this case you can create separate instances of a form function via `for(id)` to achieve isolation.\n\n```svelte\n\u003C!--- file: src/routes/todos/+page.svelte --->\n\u003Cscript>\n\timport { getTodos, modifyTodo } from '../data.remote';\n\u003C/script>\n\n\u003Ch1>Todos\u003C/h1>\n\n{#each await getTodos() as todo}\n\t{@const modify = modifyTodo.for(todo.id)}\n\t\u003Cform {...modify}>\n\t\t\u003C!-- -->\n\t\t\u003Cbutton disabled={!!modify.pending}>save changes\u003C/button>\n\t\u003C/form>\n{/each}\n```\n\n### buttonProps\n\nBy default, submitting a form will send a request to the URL indicated by the `\u003Cform>` element's [`action`](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/form#attributes_for_form_submission) attribute, which in the case of a remote function is a property on the form object generated by SvelteKit.\n\nIt's possible for a `\u003Cbutton>` inside the `\u003Cform>` to send the request to a _different_ URL, using the [`formaction`](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/button#formaction) attribute. For example, you might have a single form that allows you to log in or register depending on which button was clicked.\n\nThis attribute exists on the `buttonProps` property of a form object:\n\n```svelte\n\u003C!--- file: src/routes/login/+page.svelte --->\n\u003Cscript>\n\timport { login, register } from '$lib/auth';\n\u003C/script>\n\n\u003Cform {...login}>\n\t\u003Clabel>\n\t\tYour username\n\t\t\u003Cinput {...login.fields.username.as('text')} />\n\t\u003C/label>\n\n\t\u003Clabel>\n\t\tYour password\n\t\t\u003Cinput {...login.fields._password.as('password')} />\n\t\u003C/label>\n\n\t\u003Cbutton>login\u003C/button>\n\t\u003Cbutton {...register.buttonProps}>register\u003C/button>\n\u003C/form>\n```\n\nLike the form object itself, `buttonProps` has an `enhance` method for customizing submission behaviour.\n\n## command\n\nThe `command` function, like `form`, allows you to write data to the server. Unlike `form`, it's not specific to an element and can be called from anywhere.\n\n> [!NOTE] Prefer `form` where possible, since it gracefully degrades if JavaScript is disabled or fails to load.\n\nAs with `query` and `form`, if the function accepts an argument, it should be [validated](#query-Query-arguments) by passing a [Standard Schema](https://standardschema.dev) as the first argument to `command`.\n\n```ts\n/// file: likes.remote.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function sql(strings: TemplateStringsArray, ...values: any[]): Promise\u003Cany[]>;\n}\n// @filename: index.js\n// ---cut---\nimport * as v from 'valibot';\nimport { query, command } from '$app/server';\nimport * as db from '$lib/server/database';\n\nexport const getLikes = query(v.string(), async (id) => {\n\tconst [row] = await db.sql`\n\t\tSELECT likes\n\t\tFROM item\n\t\tWHERE id = ${id}\n\t`;\n\n\treturn row.likes;\n});\n\nexport const addLike = command(v.string(), async (id) => {\n\tawait db.sql`\n\t\tUPDATE item\n\t\tSET likes = likes + 1\n\t\tWHERE id = ${id}\n\t`;\n});\n```\n\nNow simply call `addLike`, from (for example) an event handler:\n\n```svelte\n\u003C!--- file: +page.svelte --->\n\u003Cscript>\n\timport { getLikes, addLike } from './likes.remote';\n\timport { showToast } from '$lib/toast';\n\n\tlet { item } = $props();\n\u003C/script>\n\n\u003Cbutton\n\tonclick={async () => {\n\t\ttry {\n\t\t\tawait addLike(item.id);\n\t\t} catch (error) {\n\t\t\tshowToast('Something went wrong!');\n\t\t}\n\t}}\n>\n\tadd like\n\u003C/button>\n\n\u003Cp>likes: {await getLikes(item.id)}\u003C/p>\n```\n\n> [!NOTE] Commands cannot be called during render.\n\n### Updating queries\n\nTo update `getLikes(item.id)`, or any other query, we need to tell SvelteKit _which_ queries need to be refreshed (unlike `form`, which by default invalidates everything, to approximate the behaviour of a native form submission).\n\nWe either do that inside the command itself...\n\n```js\n/// file: likes.remote.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function sql(strings: TemplateStringsArray, ...values: any[]): Promise\u003Cany[]>;\n}\n// @filename: index.js\n// ---cut---\nimport * as v from 'valibot';\nimport { query, command } from '$app/server';\nimport * as db from '$lib/server/database';\n// ---cut---\nexport const getLikes = query(v.string(), async (id) => { /* ... */ });\n\nexport const addLike = command(v.string(), async (id) => {\n\tawait db.sql`\n\t\tUPDATE item\n\t\tSET likes = likes + 1\n\t\tWHERE id = ${id}\n\t`;\n\n\t+++getLikes(id).refresh();+++\n\t// Just like within form functions you can also do\n\t// getLikes(id).set(...)\n\t// in case you have the result already\n});\n```\n\n...or when we call it:\n\n```ts\nimport { RemoteCommand, RemoteQueryFunction } from '@sveltejs/kit';\n\ninterface Item { id: string }\n\ndeclare const addLike: RemoteCommand\u003Cstring, void>;\ndeclare const getLikes: RemoteQueryFunction\u003Cstring, number>;\ndeclare function showToast(message: string): void;\ndeclare const item: Item;\n// ---cut---\ntry {\n\tawait addLike(item.id).+++updates(getLikes(item.id))+++;\n} catch (error) {\n\tshowToast('Something went wrong!');\n}\n```\n\nAs before, we can use `withOverride` for optimistic updates:\n\n```ts\nimport { RemoteCommand, RemoteQueryFunction } from '@sveltejs/kit';\n\ninterface Item { id: string }\n\ndeclare const addLike: RemoteCommand\u003Cstring, void>;\ndeclare const getLikes: RemoteQueryFunction\u003Cstring, number>;\ndeclare function showToast(message: string): void;\ndeclare const item: Item;\n// ---cut---\ntry {\n\tawait addLike(item.id).updates(\n\t\tgetLikes(item.id).+++withOverride((n) => n + 1)+++\n\t);\n} catch (error) {\n\tshowToast('Something went wrong!');\n}\n```\n\n## prerender\n\nThe `prerender` function is similar to `query`, except that it will be invoked at build time to prerender the result. Use this for data that changes at most once per redeployment.\n\n```js\n/// file: src/routes/blog/data.remote.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function sql(strings: TemplateStringsArray, ...values: any[]): Promise\u003Cany[]>;\n}\n// @filename: index.js\n// ---cut---\nimport { prerender } from '$app/server';\nimport * as db from '$lib/server/database';\n\nexport const getPosts = prerender(async () => {\n\tconst posts = await db.sql`\n\t\tSELECT title, slug\n\t\tFROM post\n\t\tORDER BY published_at\n\t\tDESC\n\t`;\n\n\treturn posts;\n});\n```\n\nYou can use `prerender` functions on pages that are otherwise dynamic, allowing for partial prerendering of your data. This results in very fast navigation, since prerendered data can live on a CDN along with your other static assets.\n\nIn the browser, prerendered data is saved using the [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache) API. This cache survives page reloads, and will be cleared when the user first visits a new deployment of your app.\n\n> [!NOTE] When the entire page has `export const prerender = true`, you cannot use queries, as they are dynamic.\n\n### Prerender arguments\n\nAs with queries, prerender functions can accept an argument, which should be [validated](#query-Query-arguments) with a [Standard Schema](https://standardschema.dev/):\n\n```js\n/// file: src/routes/blog/data.remote.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function sql(strings: TemplateStringsArray, ...values: any[]): Promise\u003Cany[]>;\n}\n// @filename: index.js\n// ---cut---\nimport * as v from 'valibot';\nimport { error } from '@sveltejs/kit';\nimport { prerender } from '$app/server';\nimport * as db from '$lib/server/database';\n\nexport const getPosts = prerender(async () => { /* ... */ });\n\nexport const getPost = prerender(v.string(), async (slug) => {\n\tconst [post] = await db.sql`\n\t\tSELECT * FROM post\n\t\tWHERE slug = ${slug}\n\t`;\n\n\tif (!post) error(404, 'Not found');\n\treturn post;\n});\n```\n\nAny calls to `getPost(...)` found by SvelteKit's crawler while [prerendering pages](page-options#prerender) will be saved automatically, but you can also specify which values it should be called with using the `inputs` option:\n\n```js\n/// file: src/routes/blog/data.remote.js\nimport * as v from 'valibot';\nimport { prerender } from '$app/server';\n// ---cut---\n\nexport const getPost = prerender(\n\tv.string(),\n\tasync (slug) => { /* ... */ },\n\t{\n\t\tinputs: () => [\n\t\t\t'first-post',\n\t\t\t'second-post',\n\t\t\t'third-post'\n\t\t]\n\t}\n);\n```\n\n> [!NOTE] Svelte does not yet support asynchronous server-side rendering, so it's likely that you're only calling remote functions from the browser, rather than during prerendering. Because of this, you will need to use `inputs`, for now. We're actively working on this roadblock.\n\nBy default, prerender functions are excluded from your server bundle, which means that you cannot call them with any arguments that were _not_ prerendered. You can set `dynamic: true` to change this behaviour:\n\n```js\n/// file: src/routes/blog/data.remote.js\nimport * as v from 'valibot';\nimport { prerender } from '$app/server';\n// ---cut---\n\nexport const getPost = prerender(\n\tv.string(),\n\tasync (slug) => { /* ... */ },\n\t{\n\t\t+++dynamic: true+++,\n\t\tinputs: () => [\n\t\t\t'first-post',\n\t\t\t'second-post',\n\t\t\t'third-post'\n\t\t]\n\t}\n);\n```\n\n## Handling validation errors\n\nAs long as _you're_ not passing invalid data to your remote functions, there are only two reasons why the argument passed to a `command`, `query` or `prerender` function would fail validation:\n\n- the function signature changed between deployments, and some users are currently on an older version of your app\n- someone is trying to attack your site by poking your exposed endpoints with bad data\n\nIn the second case, we don't want to give the attacker any help, so SvelteKit will generate a generic [400 Bad Request](https://http.dog/400) response. You can control the message by implementing the [`handleValidationError`](hooks#Server-hooks-handleValidationError) server hook, which, like [`handleError`](hooks#Shared-hooks-handleError), must return an [`App.Error`](errors#Type-safety) (which defaults to `{ message: string }`):\n\n```js\n/// file: src/hooks.server.ts\n/** @type {import('@sveltejs/kit').HandleValidationError} */\nexport function handleValidationError({ event, issues }) {\n\treturn {\n\t\tmessage: 'Nice try, hacker!'\n\t};\n}\n```\n\nIf you know what you're doing and want to opt out of validation, you can pass the string `'unchecked'` in place of a schema:\n\n```ts\n/// file: data.remote.ts\nimport { query } from '$app/server';\n\nexport const getStuff = query('unchecked', async ({ id }: { id: string }) => {\n\t// the shape might not actually be what TypeScript thinks\n\t// since bad actors might call this function with other arguments\n});\n```\n\n## Using `getRequestEvent`\n\nInside `query`, `form` and `command` you can use [`getRequestEvent`]($app-server#getRequestEvent) to get the current [`RequestEvent`](@sveltejs-kit#RequestEvent) object. This makes it easy to build abstractions for interacting with cookies, for example:\n\n```ts\n/// file: user.remote.ts\nimport { getRequestEvent, query } from '$app/server';\nimport { findUser } from '$lib/server/database';\n\nexport const getProfile = query(async () => {\n\tconst user = await getUser();\n\n\treturn {\n\t\tname: user.name,\n\t\tavatar: user.avatar\n\t};\n});\n\n// this query could be called from multiple places, but\n// the function will only run once per request\nconst getUser = query(async () => {\n\tconst { cookies } = getRequestEvent();\n\n\treturn await findUser(cookies.get('session_id'));\n});\n```\n\nNote that some properties of `RequestEvent` are different inside remote functions:\n\n- you cannot set headers (other than writing cookies, and then only inside `form` and `command` functions)\n- `route`, `params` and `url` relate to the page the remote function was called from, _not_ the URL of the endpoint SvelteKit creates for the remote function. Queries are not re-run when the user navigates (unless the argument to the query changes as a result of navigation), and so you should be mindful of how you use these values. In particular, never use them to determine whether or not a user is authorized to access certain data.\n\n## Redirects\n\nInside `query`, `form` and `prerender` functions it is possible to use the [`redirect(...)`](@sveltejs-kit#redirect) function. It is *not* possible inside `command` functions, as you should avoid redirecting here. (If you absolutely have to, you can return a `{ redirect: location }` object and deal with it in the client.)\n","Remote functions enable type-safe client-server communication. They're exported from `.remote.js` or `.remote.ts` files and always run on the server, allowing safe access to server-only modules like databases and environment variables.\n\n**Setup**: Enable in `svelte.config.js`:\n```js\nkit: { experimental: { remoteFunctions: true } },\ncompilerOptions: { experimental: { async: true } }\n```\n\n**query**: Read dynamic data from server. Accepts optional validation schema and returns a Promise with `loading`, `error`, `current` properties, or use with `await`. Supports `refresh()` to re-fetch and caching while on page.\n\n```js\nexport const getPost = query(v.string(), async (slug) => {\n  const [post] = await db.sql`SELECT * FROM post WHERE slug = ${slug}`;\n  if (!post) error(404, 'Not found');\n  return post;\n});\n```\n\n**query.batch**: Batches simultaneous queries into single request. Server callback receives array of arguments and returns function `(input, index) => output`.\n\n```js\nexport const getWeather = query.batch(v.string(), async (cities) => {\n  const weather = await db.sql`SELECT * FROM weather WHERE city = ANY(${cities})`;\n  const lookup = new Map(weather.map(w => [w.city, w]));\n  return (city) => lookup.get(city);\n});\n```\n\n**form**: Write data via HTML form. Takes validation schema and handler. Returns object with `method`, `action` for progressive enhancement, and `fields` for building inputs.\n\n```js\nexport const createPost = form(\n  v.object({ title: v.pipe(v.string(), v.nonEmpty()), content: v.pipe(v.string(), v.nonEmpty()) }),\n  async ({ title, content }) => {\n    const user = await auth.getUser();\n    if (!user) error(401, 'Unauthorized');\n    await db.sql`INSERT INTO post (slug, title, content) VALUES (${slug}, ${title}, ${content})`;\n    redirect(303, `/blog/${slug}`);\n  }\n);\n```\n\nField attributes via `.as(type)`: `input {...field.as('text')}`, `textarea {...field.as('text')}`, `input {...field.as('checkbox')}`, `input {...field.as('radio', value)}`, `select {...field.as('select')}`.\n\nValidation: Call `validate()` programmatically. Use `preflight(schema)` for client-side validation. Access issues via `field.issues()` or `fields.allIssues()`. Programmatically mark invalid with `invalid(issue1, issue2)` or `invalid.fieldName(message)`.\n\nGet/set values: `field.value()` returns current value, `fields.value()` returns object. Update with `fields.set({...})` or `field.set(value)`.\n\nSensitive data: Prefix field name with underscore to prevent repopulation on validation failure: `_password`.\n\nSingle-flight mutations: Refresh queries after form submission via `await getPosts().refresh()` or `await getPost(id).set(result)` inside handler, or client-side with `submit().updates(getPosts())` and `withOverride((posts) => [...])`.\n\nReturns: Handler can return data available as `form.result` or use `redirect()`. Result is ephemeral.\n\nEnhance: Customize submission with `form.enhance(async ({ form, data, submit }) => {...})`. Must call `form.reset()` manually.\n\nMultiple instances: Use `form.for(id)` for isolated form instances in lists.\n\nButton props: Use `buttonProps` for different form actions per button via `formaction` attribute.\n\n**command**: Call data-writing function from anywhere (not form-specific). Like `form` but no progressive enhancement. Cannot be called during render. Update queries via `command(id).updates(query(id))` or inside command with `query(id).refresh()`.\n\n**prerender**: Invoke at build time for static data. Specify inputs via `inputs: () => [...]`. Set `dynamic: true` to allow runtime calls with non-prerendered arguments. Data cached via Cache API.\n\n**Validation**: Arguments validated with Standard Schema (Zod, Valibot). Failed validation returns 400 Bad Request. Implement `handleValidationError` hook to customize error. Pass `'unchecked'` to skip validation.\n\n**getRequestEvent**: Access current RequestEvent inside remote functions for cookies/auth. Note: `route`, `params`, `url` relate to calling page, not endpoint. Cannot set headers (except cookies in form/command).\n\n**Redirects**: Supported in `query`, `form`, `prerender`. Not in `command`.","Remote functions enable type-safe client-server communication, always running on server. Four types: `query` (read), `query.batch` (batch reads), `form` (write with progressive enhancement), `command` (write from anywhere), `prerender` (build-time static data).\n\n**query**:\n```js\nexport const getPost = query(v.string(), async (slug) => {\n  const [post] = await db.sql`SELECT * FROM post WHERE slug = ${slug}`;\n  return post;\n});\n```\nUse with `await getPost(slug)` or access `.loading`, `.error`, `.current`. Call `.refresh()` to re-fetch.\n\n**form**:\n```js\nexport const createPost = form(v.object({title: v.string(), content: v.string()}), async (data) => {\n  await db.insert(data);\n  redirect(303, '/blog');\n});\n```\nSpread onto `\u003Cform>`, access fields via `createPost.fields.title.as('text')`. Validate with `validate()`, get issues via `field.issues()`. Single-flight mutations: `submit().updates(query())`.\n\n**command**: Like form but callable from anywhere, no progressive enhancement. Update queries via `.updates(query())`.\n\n**prerender**: Build-time execution for static data. Specify `inputs: () => [...]`.\n\nEnable in config: `kit: { experimental: { remoteFunctions: true } }`","Type-safe client-server communication with query, form, command, and prerender functions that run on server and support validation, progressive enhancement, and single-flight mutations.",{"name":142,"path":254,"children":255,"data":256},"core-concepts/core-concepts",["Map"],{"type":22,"path":257,"relevant":44,"token_counts":258,"usage":261,"markdown":263},"20-core-concepts/index.md",{"fulltext":117,"digest":259,"short_digest":260},65,20,{"input":121,"output":262,"details":32},186,{"fulltext":264,"digest":265,"short_digest":266,"essence":267},"---\ntitle: Core concepts\n---\n","This page serves as an introduction to the fundamental concepts of SvelteKit. It appears to be an index or overview page that likely links to or introduces key topics developers need to understand when working with SvelteKit, such as routing, components, stores, and other architectural patterns.","Overview page introducing fundamental SvelteKit concepts and architectural patterns.","Index page for core SvelteKit concepts and foundational topics.",{"type":129,"path":269,"relevant":44,"token_counts":270,"usage":274,"markdown":277},"20-core-concepts",{"fulltext":271,"digest":272,"short_digest":273},1691,700,288,{"input":275,"output":276,"details":32},2817,1111,{"fulltext":278,"digest":279,"short_digest":280,"essence":281},"\n\n## Pages\n\n### routing\nFilesystem-based routing with special `+` prefixed files for pages, layouts, API endpoints, and error handling.\n\nRoutes defined by `src/routes` directory structure with `+` prefixed files. `+page.svelte` for pages, `+page.js`/`+page.server.js` for load functions, `+layout.svelte` for shared markup, `+server.js` for API endpoints, `+error.svelte` for error pages. Load functions run on server/client or server-only. `+server.js` exports HTTP handlers. Use `$types` for type safety.\n\n### loading-data\nDefine load functions in route files to fetch and return data to components, with separate universal and server-only variants offering different capabilities and execution contexts.\n\n## Load Functions\n\nDefine in `+page.js`/`+page.server.js` or `+layout.js`/`+layout.server.js`:\n\n```js\n// Universal (server + browser)\nexport function load({ params }) {\n\treturn { data: 'value' };\n}\n\n// Server-only\nexport async function load({ params }) {\n\treturn { data: await db.query() };\n}\n```\n\n## Universal vs Server\n\n- **Universal**: Run on server (SSR) then browser. Can return non-serializable data.\n- **Server**: Run only on server. Must return serializable data. Use for DB/secrets.\n\n## Key Features\n\n- **Layout data**: Available to child layouts and pages\n- **URL data**: Access `url`, `route`, `params`\n- **Fetch**: Use provided `fetch()` (inherits cookies, allows relative URLs)\n- **Cookies**: Server load can access/set via `cookies.get/set()`\n- **Headers**: Set response headers with `setHeaders()`\n- **Parent data**: Access parent load data with `await parent()`\n- **Errors/Redirects**: Use `error()` and `redirect()` helpers\n- **Streaming**: Return unresolved promises from server load\n- **Rerun**: Triggered by param/url changes or `invalidate()`\n- **Auth**: Use `getRequestEvent()` in shared auth functions\n\n### form-actions\nServer-side form actions in +page.server.js handle POST requests with progressive enhancement support via use:enhance.\n\n## Form Actions Basics\n\nExport `actions` from `+page.server.js` to handle POST requests:\n\n```js\nexport const actions = {\n\tdefault: async (event) => {},\n\tlogin: async (event) => {},\n\tregister: async (event) => {}\n};\n```\n\nInvoke with `\u003Cform method=\"POST\" action=\"?/login\">` or `\u003Cbutton formaction=\"?/register\">`.\n\n## Handling Data & Errors\n\nRead form data and return results:\n\n```js\nexport const actions = {\n\tlogin: async ({ request }) => {\n\t\tconst data = await request.formData();\n\t\tif (!data.get('email')) {\n\t\t\treturn fail(400, { missing: true });\n\t\t}\n\t\treturn { success: true };\n\t}\n};\n```\n\nAccess in component via `form` prop. Use `redirect()` for redirects.\n\n## Progressive Enhancement\n\nAdd `use:enhance` for client-side form handling without full-page reloads:\n\n```svelte\n\u003Cscript>\n\timport { enhance, applyAction } from '$app/forms';\n\u003C/script>\n\n\u003Cform method=\"POST\" use:enhance={({ formData }) => {\n\treturn async ({ result }) => {\n\t\tawait applyAction(result);\n\t};\n}>\n```\n\nUse `deserialize` when implementing custom fetch-based handlers.\n\n### page-options\nExport page options from layout and page files to control server rendering, prerendering, client rendering, trailing slashes, and adapter-specific configuration.\n\n## prerender\n`export const prerender = true/false/'auto'` generates static HTML at build time. Specify dynamic routes via `entries()` function. Pages must return identical content for all users.\n\n## ssr\n`export const ssr = false` skips server rendering, sends empty shell. Setting in root layout makes entire app client-only (SPA).\n\n## csr\n`export const csr = false` disables client-side rendering—no JavaScript shipped, HTML/CSS only, full-page navigation.\n\n## trailingSlash\n`export const trailingSlash = 'never' | 'always' | 'ignore'` controls URL trailing slash behavior.\n\n## config\n`export const config = { ... }` sets adapter-specific configuration, merged at top level only.\n\n### state-management\nGuidelines for managing state in server-rendered and client-side applications, covering shared state pitfalls, load function purity, context API usage, component lifecycle preservation, and state persistence strategies.\n\n**Avoid shared state on server** — don't store data in shared variables; use cookies and databases instead.\n\n**No side-effects in load** — return data instead of writing to stores:\n```js\nexport async function load({ fetch }) {\n\treturn { user: await fetch('/api/user').then(r => r.json()) };\n}\n```\n\n**Use context API for safe state sharing** — pass functions into context to maintain reactivity across SSR boundaries.\n\n**Component state is preserved** — make dependent values reactive with `$derived` when data changes.\n\n**URL search parameters** — store state that needs to survive reloads: `?sort=price&order=ascending`.\n\n**Snapshots** — preserve ephemeral UI state across navigation.\n\n### remote-functions\nType-safe client-server communication with query, form, command, and prerender functions that run on server and support validation, progressive enhancement, and single-flight mutations.\n\nRemote functions enable type-safe client-server communication, always running on server. Four types: `query` (read), `query.batch` (batch reads), `form` (write with progressive enhancement), `command` (write from anywhere), `prerender` (build-time static data).\n\n**query**:\n```js\nexport const getPost = query(v.string(), async (slug) => {\n  const [post] = await db.sql`SELECT * FROM post WHERE slug = ${slug}`;\n  return post;\n});\n```\nUse with `await getPost(slug)` or access `.loading`, `.error`, `.current`. Call `.refresh()` to re-fetch.\n\n**form**:\n```js\nexport const createPost = form(v.object({title: v.string(), content: v.string()}), async (data) => {\n  await db.insert(data);\n  redirect(303, '/blog');\n});\n```\nSpread onto `\u003Cform>`, access fields via `createPost.fields.title.as('text')`. Validate with `validate()`, get issues via `field.issues()`. Single-flight mutations: `submit().updates(query())`.\n\n**command**: Like form but callable from anywhere, no progressive enhancement. Update queries via `.updates(query())`.\n\n**prerender**: Build-time execution for static data. Specify `inputs: () => [...]`.\n\nEnable in config: `kit: { experimental: { remoteFunctions: true } }`\n\n### core-concepts\nIndex page for core SvelteKit concepts and foundational topics.\n\nOverview page introducing fundamental SvelteKit concepts and architectural patterns.\n\n","## Routing\nRoutes defined by `src/routes` directory structure with `+` prefixed files: `+page.svelte` for pages, `+page.js`/`+page.server.js` for load functions, `+layout.svelte` for shared markup, `+server.js` for API endpoints, `+error.svelte` for error pages.\n\n## Load Functions\nDefine in `+page.js`/`+page.server.js` or `+layout.js`/`+layout.server.js`. Universal load functions run on server and browser; server-only load functions run only on server and must return serializable data. Access `params`, `url`, `route`, `cookies`, set headers, access parent data, stream promises, and trigger reruns on param/url changes or `invalidate()`.\n\n```js\nexport async function load({ params, fetch, cookies }) {\n\tconst data = await fetch('/api/data');\n\tcookies.set('key', 'value');\n\treturn { data };\n}\n```\n\n## Form Actions\nExport `actions` from `+page.server.js` to handle POST requests. Read form data, return results or errors with `fail()`, redirect with `redirect()`. Add `use:enhance` directive for client-side handling without full-page reloads.\n\n```js\nexport const actions = {\n\tlogin: async ({ request }) => {\n\t\tconst data = await request.formData();\n\t\tif (!data.get('email')) return fail(400, { missing: true });\n\t\treturn { success: true };\n\t}\n};\n```\n\n## Page Options\nExport configuration from layout and page files:\n- `prerender = true/'auto'` — generates static HTML at build time\n- `ssr = false` — skips server rendering, sends empty shell\n- `csr = false` — disables client-side rendering, HTML/CSS only\n- `trailingSlash = 'never' | 'always' | 'ignore'` — controls URL trailing slash behavior\n- `config = {...}` — adapter-specific configuration\n\n## State Management\nAvoid shared state on server; use cookies and databases instead. Don't write to stores in load functions—return data instead. Use context API for safe state sharing. Store persistent state in URL search parameters. Preserve ephemeral UI state with snapshots.\n\n## Remote Functions\nType-safe client-server communication with `query` (read), `form` (write with progressive enhancement), `command` (write from anywhere), and `prerender` (build-time data).\n\n```js\nexport const getPost = query(v.string(), async (slug) => {\n\tconst [post] = await db.sql`SELECT * FROM post WHERE slug = ${slug}`;\n\treturn post;\n});\n\nexport const createPost = form(v.object({title: v.string()}), async (data) => {\n\tawait db.insert(data);\n\tredirect(303, '/blog');\n});\n```\n\nEnable with `kit: { experimental: { remoteFunctions: true } }`","## Routing\n`src/routes` directory with `+` prefixed files: `+page.svelte`, `+page.server.js`, `+layout.svelte`, `+server.js`, `+error.svelte`.\n\n## Load Functions\n```js\nexport async function load({ params, fetch, cookies }) {\n\treturn { data: await fetch('/api/data') };\n}\n```\nUniversal and server-only variants. Access params, url, cookies, set headers, stream promises.\n\n## Form Actions\n```js\nexport const actions = {\n\tlogin: async ({ request }) => {\n\t\tconst data = await request.formData();\n\t\treturn fail(400, { missing: true });\n\t}\n};\n```\nUse `use:enhance` for client-side handling.\n\n## Page Options\n`prerender`, `ssr`, `csr`, `trailingSlash`, `config` exports control rendering and behavior.\n\n## State Management\nAvoid shared server state. Return data from load functions. Use context API, URL parameters, and snapshots for state.\n\n## Remote Functions\nType-safe `query`, `form`, `command`, `prerender` functions. Enable with `kit: { experimental: { remoteFunctions: true } }`","Foundational patterns for routing, data loading, form handling, rendering configuration, state management, and type-safe client-server communication in SvelteKit applications.","build-and-deploy",{"name":282,"path":282,"children":284,"data":498},["Map",285,286,303,304,321,322,338,339,356,357,374,375,392,393,410,411,427,428,445,446,463,464,282,481],"building-your-app",{"name":285,"path":287,"children":288,"data":289},"build-and-deploy/building-your-app",["Map"],{"type":22,"path":290,"relevant":44,"token_counts":291,"usage":295,"markdown":298},"25-build-and-deploy/10-building-your-app.md",{"fulltext":292,"digest":293,"short_digest":294},349,267,72,{"input":296,"output":297,"details":32},1398,445,{"fulltext":299,"digest":300,"short_digest":301,"essence":302},"---\ntitle: Building your app\n---\n\nBuilding a SvelteKit app happens in two stages, which both happen when you run `vite build` (usually via `npm run build`).\n\nFirstly, Vite creates an optimized production build of your server code, your browser code, and your service worker (if you have one). [Prerendering](page-options#prerender) is executed at this stage, if appropriate.\n\nSecondly, an _adapter_ takes this production build and tunes it for your target environment — more on this on the following pages.\n\n## During the build\n\nSvelteKit will load your `+page/layout(.server).js` files (and all files they import) for analysis during the build. Any code that should _not_ be executed at this stage must check that `building` from [`$app/environment`]($app-environment) is `false`:\n\n```js\n+++import { building } from '$app/environment';+++\nimport { setupMyDatabase } from '$lib/server/database';\n\n+++if (!building) {+++\n\tsetupMyDatabase();\n+++}+++\n\nexport function load() {\n\t// ...\n}\n```\n\n## Preview your app\n\nAfter building, you can view your production build locally with `vite preview` (via `npm run preview`). Note that this will run the app in Node, and so is not a perfect reproduction of your deployed app — adapter-specific adjustments like the [`platform` object](adapters#Platform-specific-context) do not apply to previews.\n","## Build Process\n\nSvelteKit builds happen in two stages via `vite build` (or `npm run build`):\n\n1. **Vite optimization**: Creates optimized production builds of server code, browser code, and service worker. Prerendering executes at this stage if configured.\n2. **Adapter tuning**: An adapter takes the production build and optimizes it for your target environment.\n\n## Avoiding Code Execution During Build\n\nSvelteKit loads `+page/layout(.server).js` files and their imports during the build for analysis. Code that shouldn't execute at build time must check the `building` flag from `$app/environment`:\n\n```js\nimport { building } from '$app/environment';\nimport { setupMyDatabase } from '$lib/server/database';\n\nif (!building) {\n\tsetupMyDatabase();\n}\n\nexport function load() {\n\t// ...\n}\n```\n\n## Preview Your Build\n\nAfter building, preview the production build locally with `vite preview` (or `npm run preview`). This runs in Node and doesn't perfectly reproduce your deployed app — adapter-specific features like the `platform` object don't apply to previews.","SvelteKit builds in two stages: Vite optimizes your code, then an adapter tunes it for your target environment. Prevent code execution during build by checking `building` from `$app/environment`. Preview your build with `vite preview`, though it won't perfectly match your deployed app.","How to build a SvelteKit app and prevent code from running during the build process.","adapters",{"name":303,"path":305,"children":306,"data":307},"build-and-deploy/adapters",["Map"],{"type":22,"path":308,"relevant":44,"token_counts":309,"usage":313,"markdown":316},"25-build-and-deploy/20-adapters.md",{"fulltext":310,"digest":311,"short_digest":312},477,249,73,{"input":314,"output":315,"details":32},1523,435,{"fulltext":317,"digest":318,"short_digest":319,"essence":320},"---\ntitle: Adapters\n---\n\nBefore you can deploy your SvelteKit app, you need to _adapt_ it for your deployment target. Adapters are small plugins that take the built app as input and generate output for deployment.\n\nOfficial adapters exist for a variety of platforms — these are documented on the following pages:\n\n- [`@sveltejs/adapter-cloudflare`](adapter-cloudflare) for Cloudflare Workers and Cloudflare Pages\n- [`@sveltejs/adapter-netlify`](adapter-netlify) for Netlify\n- [`@sveltejs/adapter-node`](adapter-node) for Node servers\n- [`@sveltejs/adapter-static`](adapter-static) for static site generation (SSG)\n- [`@sveltejs/adapter-vercel`](adapter-vercel) for Vercel\n\nAdditional [community-provided adapters](/packages#sveltekit-adapters) exist for other platforms.\n\n## Using adapters\n\nYour adapter is specified in `svelte.config.js`:\n\n```js\n/// file: svelte.config.js\n// @filename: ambient.d.ts\ndeclare module 'svelte-adapter-foo' {\n\tconst adapter: (opts: any) => import('@sveltejs/kit').Adapter;\n\texport default adapter;\n}\n\n// @filename: index.js\n// ---cut---\nimport adapter from 'svelte-adapter-foo';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// adapter options go here\n\t\t})\n\t}\n};\n\nexport default config;\n```\n\n## Platform-specific context\n\nSome adapters may have access to additional information about the request. For example, Cloudflare Workers can access an `env` object containing KV namespaces etc. This can be passed to the `RequestEvent` used in [hooks](hooks) and [server routes](routing#server) as the `platform` property — consult each adapter's documentation to learn more.\n\n","Adapters are plugins that transform a built SvelteKit app for deployment to specific platforms.\n\n**Official adapters:**\n- `@sveltejs/adapter-cloudflare` — Cloudflare Workers and Pages\n- `@sveltejs/adapter-netlify` — Netlify\n- `@sveltejs/adapter-node` — Node servers\n- `@sveltejs/adapter-static` — Static site generation\n- `@sveltejs/adapter-vercel` — Vercel\n\nCommunity adapters are available for other platforms.\n\n**Configuration:**\nSpecify your adapter in `svelte.config.js`:\n\n```js\nimport adapter from 'svelte-adapter-foo';\n\nconst config = {\n\tkit: {\n\t\tadapter: adapter({ /* options */ })\n\t}\n};\n\nexport default config;\n```\n\n**Platform context:**\nSome adapters provide platform-specific data (e.g., Cloudflare's `env` object with KV namespaces) accessible via the `platform` property in `RequestEvent` within hooks and server routes.","Adapters transform built SvelteKit apps for deployment. Official adapters exist for Cloudflare, Netlify, Node, static sites, and Vercel. Configure in `svelte.config.js` with `kit.adapter`. Platform-specific context is available via `RequestEvent.platform`.","Adapters are deployment plugins configured in svelte.config.js that prepare SvelteKit apps for specific platforms.","zero-config-deployments",{"name":321,"path":323,"children":324,"data":325},"build-and-deploy/zero-config-deployments",["Map"],{"type":22,"path":326,"relevant":44,"token_counts":327,"usage":330,"markdown":333},"25-build-and-deploy/30-adapter-auto.md",{"fulltext":328,"digest":329,"short_digest":28},514,185,{"input":331,"output":332,"details":32},1561,384,{"fulltext":334,"digest":335,"short_digest":336,"essence":337},"---\ntitle: Zero-config deployments\n---\n\nWhen you create a new SvelteKit project with `npx sv create`, it installs [`adapter-auto`](https://github.com/sveltejs/kit/tree/main/packages/adapter-auto) by default. This adapter automatically installs and uses the correct adapter for supported environments when you deploy:\n\n- [`@sveltejs/adapter-cloudflare`](adapter-cloudflare) for [Cloudflare Pages](https://developers.cloudflare.com/pages/)\n- [`@sveltejs/adapter-netlify`](adapter-netlify) for [Netlify](https://netlify.com/)\n- [`@sveltejs/adapter-vercel`](adapter-vercel) for [Vercel](https://vercel.com/)\n- [`svelte-adapter-azure-swa`](https://github.com/geoffrich/svelte-adapter-azure-swa) for [Azure Static Web Apps](https://docs.microsoft.com/en-us/azure/static-web-apps/)\n- [`svelte-kit-sst`](https://github.com/sst/v2/tree/master/packages/svelte-kit-sst) for [AWS via SST](https://sst.dev/docs/start/aws/svelte)\n- [`@sveltejs/adapter-node`](adapter-node) for [Google Cloud Run](https://cloud.google.com/run)\n\nIt's recommended to install the appropriate adapter to your `devDependencies` once you've settled on a target environment, since this will add the adapter to your lockfile and slightly improve install times on CI.\n\n## Environment-specific configuration\n\nTo add configuration options, such as `{ edge: true }` in [`adapter-vercel`](adapter-vercel) and [`adapter-netlify`](adapter-netlify), you must install the underlying adapter — `adapter-auto` does not take any options.\n\n## Adding community adapters\n\nYou can add zero-config support for additional adapters by editing [adapters.js](https://github.com/sveltejs/kit/blob/main/packages/adapter-auto/adapters.js) and opening a pull request.\n","**adapter-auto** automatically detects and uses the correct deployment adapter for your environment. It's installed by default with `npx sv create`.\n\nSupported environments:\n- Cloudflare Pages\n- Netlify\n- Vercel\n- Azure Static Web Apps\n- AWS via SST\n- Google Cloud Run\n\nOnce you've chosen a target environment, install the specific adapter to your devDependencies. This adds it to your lockfile and improves CI install times.\n\nTo use environment-specific configuration options (like `{ edge: true }` in adapter-vercel or adapter-netlify), you must install the underlying adapter directly — adapter-auto doesn't accept options.\n\nCommunity adapters can be added to zero-config support by editing adapters.js in the adapter-auto package and submitting a pull request.","**adapter-auto** automatically selects the correct deployment adapter based on your environment (Cloudflare Pages, Netlify, Vercel, Azure Static Web Apps, AWS SST, or Google Cloud Run).\n\nInstall the specific adapter to devDependencies for environment-specific configuration options and better CI performance. adapter-auto itself takes no options.","adapter-auto automatically detects and uses the correct deployment adapter for supported hosting platforms, with option to install specific adapters for configuration and performance.","node-servers",{"name":338,"path":340,"children":341,"data":342},"build-and-deploy/node-servers",["Map"],{"type":22,"path":343,"relevant":44,"token_counts":344,"usage":348,"markdown":351},"25-build-and-deploy/40-adapter-node.md",{"fulltext":345,"digest":346,"short_digest":347},3663,849,307,{"input":349,"output":350,"details":32},4710,1273,{"fulltext":352,"digest":353,"short_digest":354,"essence":355},"---\ntitle: Node servers\n---\n\nTo generate a standalone Node server, use [`adapter-node`](https://github.com/sveltejs/kit/tree/main/packages/adapter-node).\n\n## Usage\n\nInstall with `npm i -D @sveltejs/adapter-node`, then add the adapter to your `svelte.config.js`:\n\n```js\n// @errors: 2307\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-node';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n\nexport default config;\n```\n\n## Deploying\n\nFirst, build your app with `npm run build`. This will create the production server in the output directory specified in the adapter options, defaulting to `build`.\n\nYou will need the output directory, the project's `package.json`, and the production dependencies in `node_modules` to run the application. Production dependencies can be generated by copying the `package.json` and `package-lock.json` and then running `npm ci --omit dev` (you can skip this step if your app doesn't have any dependencies). You can then start your app with this command:\n\n```sh\nnode build\n```\n\nDevelopment dependencies will be bundled into your app using [Rollup](https://rollupjs.org). To control whether a given package is bundled or externalised, place it in `devDependencies` or `dependencies` respectively in your `package.json`.\n\n### Compressing responses\n\nYou will typically want to compress responses coming from the server. If you're already deploying your server behind a reverse proxy for SSL or load balancing, it typically results in better performance to also handle compression at that layer since Node.js is single-threaded.\n\nHowever, if you're building a [custom server](#Custom-server) and do want to add a compression middleware there, note that we would recommend using [`@polka/compression`](https://www.npmjs.com/package/@polka/compression) since SvelteKit streams responses and the more popular `compression` package does not support streaming and may cause errors when used.\n\n## Environment variables\n\nIn `dev` and `preview`, SvelteKit will read environment variables from your `.env` file (or `.env.local`, or `.env.[mode]`, [as determined by Vite](https://vitejs.dev/guide/env-and-mode.html#env-files).)\n\nIn production, `.env` files are _not_ automatically loaded. To do so, install `dotenv` in your project...\n\n```sh\nnpm install dotenv\n```\n\n...and invoke it before running the built app:\n\n```sh\nnode +++-r dotenv/config+++ build\n```\n\nIf you use Node.js v20.6+, you can use the [`--env-file`](https://nodejs.org/en/learn/command-line/how-to-read-environment-variables-from-nodejs) flag instead:\n\n```sh\nnode +++--env-file=.env+++ build\n```\n\n### `PORT`, `HOST` and `SOCKET_PATH`\n\nBy default, the server will accept connections on `0.0.0.0` using port 3000. These can be customised with the `PORT` and `HOST` environment variables:\n\n```sh\nHOST=127.0.0.1 PORT=4000 node build\n```\n\nAlternatively, the server can be configured to accept connections on a specified socket path. When this is done using the `SOCKET_PATH` environment variable, the `HOST` and `PORT` environment variables will be disregarded.\n\n```sh\nSOCKET_PATH=/tmp/socket node build\n```\n\n### `ORIGIN`, `PROTOCOL_HEADER`, `HOST_HEADER`, and `PORT_HEADER`\n\nHTTP doesn't give SvelteKit a reliable way to know the URL that is currently being requested. The simplest way to tell SvelteKit where the app is being served is to set the `ORIGIN` environment variable:\n\n```sh\nORIGIN=https://my.site node build\n\n# or e.g. for local previewing and testing\nORIGIN=http://localhost:3000 node build\n```\n\nWith this, a request for the `/stuff` pathname will correctly resolve to `https://my.site/stuff`. Alternatively, you can specify headers that tell SvelteKit about the request protocol and host, from which it can construct the origin URL:\n\n```sh\nPROTOCOL_HEADER=x-forwarded-proto HOST_HEADER=x-forwarded-host node build\n```\n\n> [!NOTE] [`x-forwarded-proto`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Proto) and [`x-forwarded-host`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-Host) are de facto standard headers that forward the original protocol and host if you're using a reverse proxy (think load balancers and CDNs). You should only set these variables if your server is behind a trusted reverse proxy; otherwise, it'd be possible for clients to spoof these headers.\n>\n> If you're hosting your proxy on a non-standard port and your reverse proxy supports `x-forwarded-port`, you can also set `PORT_HEADER=x-forwarded-port`.\n\nIf `adapter-node` can't correctly determine the URL of your deployment, you may experience this error when using [form actions](form-actions):\n\n> [!NOTE] Cross-site POST form submissions are forbidden\n\n### `ADDRESS_HEADER` and `XFF_DEPTH`\n\nThe [`RequestEvent`](@sveltejs-kit#RequestEvent) object passed to hooks and endpoints includes an `event.getClientAddress()` function that returns the client's IP address. By default this is the connecting `remoteAddress`. If your server is behind one or more proxies (such as a load balancer), this value will contain the innermost proxy's IP address rather than the client's, so we need to specify an `ADDRESS_HEADER` to read the address from:\n\n```sh\nADDRESS_HEADER=True-Client-IP node build\n```\n\n> [!NOTE] Headers can easily be spoofed. As with `PROTOCOL_HEADER` and `HOST_HEADER`, you should [know what you're doing](https://adam-p.ca/blog/2022/03/x-forwarded-for/) before setting these.\n\nIf the `ADDRESS_HEADER` is `X-Forwarded-For`, the header value will contain a comma-separated list of IP addresses. The `XFF_DEPTH` environment variable should specify how many trusted proxies sit in front of your server. E.g. if there are three trusted proxies, proxy 3 will forward the addresses of the original connection and the first two proxies:\n\n```\n\u003Cclient address>, \u003Cproxy 1 address>, \u003Cproxy 2 address>\n```\n\nSome guides will tell you to read the left-most address, but this leaves you [vulnerable to spoofing](https://adam-p.ca/blog/2022/03/x-forwarded-for/):\n\n```\n\u003Cspoofed address>, \u003Cclient address>, \u003Cproxy 1 address>, \u003Cproxy 2 address>\n```\n\nWe instead read from the _right_, accounting for the number of trusted proxies. In this case, we would use `XFF_DEPTH=3`.\n\n> [!NOTE] If you need to read the left-most address instead (and don't care about spoofing) — for example, to offer a geolocation service, where it's more important for the IP address to be _real_ than _trusted_, you can do so by inspecting the `x-forwarded-for` header within your app.\n\n### `BODY_SIZE_LIMIT`\n\nThe maximum request body size to accept in bytes including while streaming. The body size can also be specified with a unit suffix for kilobytes (`K`), megabytes (`M`), or gigabytes (`G`). For example, `512K` or `1M`. Defaults to 512kb. You can disable this option with a value of `Infinity` (0 in older versions of the adapter) and implement a custom check in [`handle`](hooks#Server-hooks-handle) if you need something more advanced.\n\n### `SHUTDOWN_TIMEOUT`\n\nThe number of seconds to wait before forcefully closing any remaining connections after receiving a `SIGTERM` or `SIGINT` signal. Defaults to `30`. Internally the adapter calls [`closeAllConnections`](https://nodejs.org/api/http.html#servercloseallconnections). See [Graceful shutdown](#Graceful-shutdown) for more details.\n\n### `IDLE_TIMEOUT`\n\nWhen using systemd socket activation, `IDLE_TIMEOUT` specifies the number of seconds after which the app is automatically put to sleep when receiving no requests. If not set, the app runs continuously. See [Socket activation](#Socket-activation) for more details.\n\n## Options\n\nThe adapter can be configured with various options:\n\n```js\n// @errors: 2307\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-node';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// default options are shown\n\t\t\tout: 'build',\n\t\t\tprecompress: true,\n\t\t\tenvPrefix: ''\n\t\t})\n\t}\n};\n\nexport default config;\n```\n\n### out\n\nThe directory to build the server to. It defaults to `build` — i.e. `node build` would start the server locally after it has been created.\n\n### precompress\n\nEnables precompressing using gzip and brotli for assets and prerendered pages. It defaults to `true`.\n\n### envPrefix\n\nIf you need to change the name of the environment variables used to configure the deployment (for example, to deconflict with environment variables you don't control), you can specify a prefix:\n\n```js\nenvPrefix: 'MY_CUSTOM_';\n```\n\n```sh\nMY_CUSTOM_HOST=127.0.0.1 \\\nMY_CUSTOM_PORT=4000 \\\nMY_CUSTOM_ORIGIN=https://my.site \\\nnode build\n```\n\n## Graceful shutdown\n\nBy default `adapter-node` gracefully shuts down the HTTP server when a `SIGTERM` or `SIGINT` signal is received. It will:\n\n1. reject new requests ([`server.close`](https://nodejs.org/api/http.html#serverclosecallback))\n2. wait for requests that have already been made but not received a response yet to finish and close connections once they become idle ([`server.closeIdleConnections`](https://nodejs.org/api/http.html#servercloseidleconnections))\n3. and finally, close any remaining connections that are still active after [`SHUTDOWN_TIMEOUT`](#Environment-variables-SHUTDOWN_TIMEOUT) seconds. ([`server.closeAllConnections`](https://nodejs.org/api/http.html#servercloseallconnections))\n\n> [!NOTE] If you want to customize this behaviour you can use a [custom server](#Custom-server).\n\nYou can listen to the `sveltekit:shutdown` event which is emitted after the HTTP server has closed all connections. Unlike Node's `exit` event, the `sveltekit:shutdown` event supports asynchronous operations and is always emitted when all connections are closed even if the server has dangling work such as open database connections.\n\n```js\n// @errors: 2304\nprocess.on('sveltekit:shutdown', async (reason) => {\n  await jobs.stop();\n  await db.close();\n});\n```\n\nThe parameter `reason` has one of the following values:\n\n- `SIGINT` - shutdown was triggered by a `SIGINT` signal\n- `SIGTERM` - shutdown was triggered by a `SIGTERM` signal\n- `IDLE` - shutdown was triggered by [`IDLE_TIMEOUT`](#Environment-variables-IDLE_TIMEOUT)\n\n## Socket activation\n\nMost Linux operating systems today use a modern process manager called systemd to start the server and run and manage services. You can configure your server to allocate a socket and start and scale your app on demand. This is called [socket activation](https://0pointer.de/blog/projects/socket-activated-containers.html). In this case, the OS will pass two environment variables to your app — `LISTEN_PID` and `LISTEN_FDS`. The adapter will then listen on file descriptor 3 which refers to a systemd socket unit that you will have to create.\n\n> [!NOTE] You can still use [`envPrefix`](#Options-envPrefix) with systemd socket activation. `LISTEN_PID` and `LISTEN_FDS` are always read without a prefix.\n\nTo take advantage of socket activation follow these steps.\n\n1. Run your app as a [systemd service](https://www.freedesktop.org/software/systemd/man/latest/systemd.service.html). It can either run directly on the host system or inside a container (using Docker or a systemd portable service for example). If you additionally pass an [`IDLE_TIMEOUT`](#Environment-variables-IDLE_TIMEOUT) environment variable to your app it will gracefully shutdown if there are no requests for `IDLE_TIMEOUT` seconds. systemd will automatically start your app again when new requests are coming in.\n\n```ini\n/// file: /etc/systemd/system/myapp.service\n[Service]\nEnvironment=NODE_ENV=production IDLE_TIMEOUT=60\nExecStart=/usr/bin/node /usr/bin/myapp/build\n```\n\n2. Create an accompanying [socket unit](https://www.freedesktop.org/software/systemd/man/latest/systemd.socket.html). The adapter only accepts a single socket.\n\n```ini\n/// file: /etc/systemd/system/myapp.socket\n[Socket]\nListenStream=3000\n\n[Install]\nWantedBy=sockets.target\n```\n\n3. Make sure systemd has recognised both units by running `sudo systemctl daemon-reload`. Then enable the socket on boot and start it immediately using `sudo systemctl enable --now myapp.socket`. The app will then automatically start once the first request is made to `localhost:3000`.\n\n## Custom server\n\nThe adapter creates two files in your build directory — `index.js` and `handler.js`. Running `index.js` — e.g. `node build`, if you use the default build directory — will start a server on the configured port.\n\nAlternatively, you can import the `handler.js` file, which exports a handler suitable for use with [Express](https://github.com/expressjs/express), [Connect](https://github.com/senchalabs/connect) or [Polka](https://github.com/lukeed/polka) (or even just the built-in [`http.createServer`](https://nodejs.org/dist/latest/docs/api/http.html#httpcreateserveroptions-requestlistener)) and set up your own server:\n\n```js\n// @errors: 2307 7006\n/// file: my-server.js\nimport { handler } from './build/handler.js';\nimport express from 'express';\n\nconst app = express();\n\n// add a route that lives separately from the SvelteKit app\napp.get('/healthcheck', (req, res) => {\n\tres.end('ok');\n});\n\n// let SvelteKit handle everything else, including serving prerendered pages and static assets\napp.use(handler);\n\napp.listen(3000, () => {\n\tconsole.log('listening on port 3000');\n});\n```\n","## Installation and Setup\n\nInstall `@sveltejs/adapter-node` and add to `svelte.config.js`:\n\n```js\nimport adapter from '@sveltejs/adapter-node';\n\nconst config = {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n\nexport default config;\n```\n\n## Building and Running\n\nBuild with `npm run build` (outputs to `build` directory by default). Deploy the `build` directory, `package.json`, and production dependencies. Start with `node build`.\n\nDevelopment dependencies are bundled via Rollup. Control bundling by placing packages in `devDependencies` (bundled) or `dependencies` (external).\n\n## Environment Variables\n\n**In production**, `.env` files aren't auto-loaded. Load with:\n```sh\nnode -r dotenv/config build\n# or Node.js v20.6+:\nnode --env-file=.env build\n```\n\n**Server configuration:**\n- `PORT` (default 3000) and `HOST` (default 0.0.0.0)\n- `SOCKET_PATH` - use Unix socket instead of HOST/PORT\n- `ORIGIN` - set the deployment URL (e.g., `https://my.site`)\n- `PROTOCOL_HEADER`, `HOST_HEADER`, `PORT_HEADER` - read from reverse proxy headers (e.g., `x-forwarded-proto`)\n- `ADDRESS_HEADER` - read client IP from header (e.g., `True-Client-IP`)\n- `XFF_DEPTH` - number of trusted proxies for `X-Forwarded-For` parsing\n- `BODY_SIZE_LIMIT` - max request body (default 512kb, supports K/M/G suffixes)\n- `SHUTDOWN_TIMEOUT` - seconds to wait before force-closing connections (default 30)\n- `IDLE_TIMEOUT` - seconds before auto-sleep with systemd socket activation\n\n## Adapter Options\n\n```js\nadapter({\n\tout: 'build',           // output directory\n\tprecompress: true,      // gzip/brotli compression\n\tenvPrefix: ''           // prefix for env vars (e.g., 'MY_CUSTOM_')\n})\n```\n\n## Compression\n\nFor custom servers, use `@polka/compression` instead of the popular `compression` package, as SvelteKit streams responses and `compression` doesn't support streaming.\n\n## Graceful Shutdown\n\nOn `SIGTERM`/`SIGINT`, the server rejects new requests, waits for in-flight requests to complete, then closes remaining connections after `SHUTDOWN_TIMEOUT`. Listen to `sveltekit:shutdown` event for cleanup:\n\n```js\nprocess.on('sveltekit:shutdown', async (reason) => {\n  // reason: 'SIGINT', 'SIGTERM', or 'IDLE'\n  await db.close();\n});\n```\n\n## Socket Activation (systemd)\n\nConfigure systemd socket activation for on-demand app scaling. Create service and socket units, then systemd passes `LISTEN_PID` and `LISTEN_FDS` environment variables. The adapter listens on file descriptor 3.\n\n## Custom Server\n\nThe build outputs `index.js` (standalone server) and `handler.js` (middleware). Import `handler.js` for Express/Connect/Polka:\n\n```js\nimport { handler } from './build/handler.js';\nimport express from 'express';\n\nconst app = express();\napp.get('/healthcheck', (req, res) => res.end('ok'));\napp.use(handler);\napp.listen(3000);\n```","## Setup\n\nInstall `@sveltejs/adapter-node` and add to `svelte.config.js`. Build with `npm run build`, deploy `build/`, `package.json`, and `node_modules/`. Start with `node build`.\n\n## Environment Variables\n\n- `PORT` (3000), `HOST` (0.0.0.0), `SOCKET_PATH`\n- `ORIGIN` - deployment URL\n- `PROTOCOL_HEADER`, `HOST_HEADER`, `PORT_HEADER` - reverse proxy headers\n- `ADDRESS_HEADER`, `XFF_DEPTH` - client IP detection\n- `BODY_SIZE_LIMIT` (512kb), `SHUTDOWN_TIMEOUT` (30s), `IDLE_TIMEOUT`\n\n## Adapter Options\n\n```js\nadapter({ out: 'build', precompress: true, envPrefix: '' })\n```\n\n## Custom Server\n\nImport `handler.js` for Express/Connect/Polka:\n\n```js\nimport { handler } from './build/handler.js';\nimport express from 'express';\napp.use(handler);\n```\n\n## Graceful Shutdown & systemd\n\nListen to `sveltekit:shutdown` event. Supports systemd socket activation with `LISTEN_PID`/`LISTEN_FDS`.","Deploy SvelteKit apps as standalone Node servers using adapter-node with environment variable configuration for proxies, ports, and graceful shutdown.","static-site-generation",{"name":356,"path":358,"children":359,"data":360},"build-and-deploy/static-site-generation",["Map"],{"type":22,"path":361,"relevant":44,"token_counts":362,"usage":366,"markdown":369},"25-build-and-deploy/50-adapter-static.md",{"fulltext":363,"digest":364,"short_digest":365},1728,493,96,{"input":367,"output":368,"details":32},2775,712,{"fulltext":370,"digest":371,"short_digest":372,"essence":373},"---\ntitle: Static site generation\n---\n\nTo use SvelteKit as a static site generator (SSG), use [`adapter-static`](https://github.com/sveltejs/kit/tree/main/packages/adapter-static).\n\nThis will prerender your entire site as a collection of static files. If you'd like to prerender only some pages and dynamically server-render others, you will need to use a different adapter together with [the `prerender` option](page-options#prerender).\n\n## Usage\n\nInstall with `npm i -D @sveltejs/adapter-static`, then add the adapter to your `svelte.config.js`:\n\n```js\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-static';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// default options are shown. On some platforms\n\t\t\t// these options are set automatically — see below\n\t\t\tpages: 'build',\n\t\t\tassets: 'build',\n\t\t\tfallback: undefined,\n\t\t\tprecompress: false,\n\t\t\tstrict: true\n\t\t})\n\t}\n};\n\nexport default config;\n```\n\n...and add the [`prerender`](page-options#prerender) option to your root layout:\n\n```js\n/// file: src/routes/+layout.js\n// If you're using a fallback (i.e. SPA mode) you don't need to prerender all\n// pages by setting this here, but should prerender as many as possible to\n// avoid large performance and SEO impacts\nexport const prerender = true;\n```\n\n> [!NOTE] You must ensure SvelteKit's [`trailingSlash`](page-options#trailingSlash) option is set appropriately for your environment. If your host does not render `/a.html` upon receiving a request for `/a` then you will need to set `trailingSlash: 'always'` in your root layout to create `/a/index.html` instead.\n\n## Zero-config support\n\nSome platforms have zero-config support (more to come in future):\n\n- [Vercel](https://vercel.com)\n\nOn these platforms, you should omit the adapter options so that `adapter-static` can provide the optimal configuration:\n\n```js\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-static';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter(---{...}---)\n\t}\n};\n\nexport default config;\n```\n\n## Options\n\n### pages\n\nThe directory to write prerendered pages to. It defaults to `build`.\n\n### assets\n\nThe directory to write static assets (the contents of `static`, plus client-side JS and CSS generated by SvelteKit) to. Ordinarily this should be the same as `pages`, and it will default to whatever the value of `pages` is, but in rare circumstances you might need to output pages and assets to separate locations.\n\n### fallback\n\nTo create a [single page app (SPA)](single-page-apps) you must specify the name of the fallback page to be generated by SvelteKit, which is used as the entry point for URLs that have not been prerendered. This is commonly `200.html`, but can vary depending on your deployment platform. You should avoid `index.html` where possible to avoid conflicting with a prerendered homepage. \n\n> This option has large negative performance and SEO impacts. It is only recommended in certain circumstances such as wrapping the site in a mobile app. See the [single page apps](single-page-apps) documentation for more details and alternatives.\n\n### precompress\n\nIf `true`, precompresses files with brotli and gzip. This will generate `.br` and `.gz` files.\n\n### strict\n\nBy default, `adapter-static` checks that either all pages and endpoints (if any) of your app were prerendered, or you have the `fallback` option set. This check exists to prevent you from accidentally publishing an app where some parts of it are not accessible, because they are not contained in the final output. If you know this is ok (for example when a certain page only exists conditionally), you can set `strict` to `false` to turn off this check.\n\n## GitHub Pages\n\nWhen building for [GitHub Pages](https://docs.github.com/en/pages/getting-started-with-github-pages/about-github-pages), if your repo name is not equivalent to `your-username.github.io`, make sure to update [`config.kit.paths.base`](configuration#paths) to match your repo name. This is because the site will be served from `https://your-username.github.io/your-repo-name` rather than from the root.\n\nYou'll also want to generate a fallback `404.html` page to replace the default 404 page shown by GitHub Pages.\n\nA config for GitHub Pages might look like the following:\n\n```js\n// @errors: 2322\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-static';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\tfallback: '404.html'\n\t\t}),\n\t\tpaths: {\n\t\t\tbase: process.argv.includes('dev') ? '' : process.env.BASE_PATH\n\t\t}\n\t}\n};\n\nexport default config;\n```\n\nYou can use GitHub actions to automatically deploy your site to GitHub Pages when you make a change. Here's an example workflow:\n\n```yaml\n### file: .github/workflows/deploy.yml\nname: Deploy to GitHub Pages\n\non:\n  push:\n    branches: 'main'\n\njobs:\n  build_site:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v4\n\n      # If you're using pnpm, add this step then change the commands and cache key below to use `pnpm`\n      # - name: Install pnpm\n      #   uses: pnpm/action-setup@v3\n      #   with:\n      #     version: 8\n\n      - name: Install Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: 20\n          cache: npm\n\n      - name: Install dependencies\n        run: npm i\n\n      - name: build\n        env:\n          BASE_PATH: '/${{ github.event.repository.name }}'\n        run: |\n          npm run build\n\n      - name: Upload Artifacts\n        uses: actions/upload-pages-artifact@v3\n        with:\n          # this should match the `pages` option in your adapter-static options\n          path: 'build/'\n\n  deploy:\n    needs: build_site\n    runs-on: ubuntu-latest\n\n    permissions:\n      pages: write\n      id-token: write\n\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n\n    steps:\n      - name: Deploy\n        id: deployment\n        uses: actions/deploy-pages@v4\n```\n\nIf you're not using GitHub actions to deploy your site (for example, you're pushing the built site to its own repo), add an empty `.nojekyll` file in your `static` directory to prevent Jekyll from interfering.\n","## Installation and Setup\n\nInstall `@sveltejs/adapter-static` and configure in `svelte.config.js`:\n\n```js\nimport adapter from '@sveltejs/adapter-static';\n\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\tpages: 'build',\n\t\t\tassets: 'build',\n\t\t\tfallback: undefined,\n\t\t\tprecompress: false,\n\t\t\tstrict: true\n\t\t})\n\t}\n};\n\nexport default config;\n```\n\nAdd `export const prerender = true;` to your root layout (`src/routes/+layout.js`).\n\n## Configuration Options\n\n- **pages**: Output directory for prerendered pages (default: `build`)\n- **assets**: Output directory for static assets (default: same as `pages`)\n- **fallback**: Fallback page for SPA mode (e.g., `200.html` or `404.html`). Has negative performance/SEO impacts\n- **precompress**: Generate `.br` and `.gz` compressed files when `true`\n- **strict**: Validates all pages/endpoints are prerendered or fallback is set (default: `true`)\n\n## Important Notes\n\nSet `trailingSlash: 'always'` in your root layout if your host doesn't serve `/a.html` for requests to `/a`.\n\nFor partial prerendering, use a different adapter with the `prerender` option instead of `adapter-static`.\n\n## GitHub Pages Deployment\n\nUpdate `config.kit.paths.base` to your repo name since the site is served from `https://your-username.github.io/your-repo-name`.\n\nGenerate a `404.html` fallback page:\n\n```js\nconst config = {\n\tkit: {\n\t\tadapter: adapter({ fallback: '404.html' }),\n\t\tpaths: {\n\t\t\tbase: process.argv.includes('dev') ? '' : process.env.BASE_PATH\n\t\t}\n\t}\n};\n```\n\nUse GitHub Actions to automate deployment (example workflow provided in documentation).\n\nAdd `.nojekyll` file to `static/` directory if not using GitHub Actions to prevent Jekyll interference.","Install `@sveltejs/adapter-static` and set `prerender = true` in root layout. Configure adapter options: `pages`, `assets`, `fallback` (for SPA), `precompress`, `strict`. Set `trailingSlash: 'always'` if needed. For GitHub Pages, update `paths.base` to repo name and generate `404.html` fallback.","Configure SvelteKit to prerender your entire site as static files using adapter-static with options for output directories, SPA fallback, compression, and GitHub Pages deployment.","single-page-apps",{"name":374,"path":376,"children":377,"data":378},"build-and-deploy/single-page-apps",["Map"],{"type":22,"path":379,"relevant":44,"token_counts":380,"usage":384,"markdown":387},"25-build-and-deploy/55-single-page-apps.md",{"fulltext":381,"digest":382,"short_digest":383},1166,517,193,{"input":385,"output":386,"details":32},2215,830,{"fulltext":388,"digest":389,"short_digest":390,"essence":391},"---\ntitle: Single-page apps\n---\n\nYou can turn a SvelteKit app into a fully client-rendered single-page app (SPA) by specifying a _fallback page_. This page will be served for any URLs that can't be served by other means such as returning a prerendered page.\n\n> [!NOTE] SPA mode has a large negative performance impact by forcing multiple network round trips (for the blank HTML document, then for the JavaScript, and then for any data needed for the page) before content can be shown. Unless you are serving the app from a local network (e.g. a mobile app that wraps a locally-served SPA) this will delay startup, especially when considering the latency of mobile devices. It also harms SEO by often causing sites to be downranked for performance (SPAs are much more likely to fail [Core Web Vitals](https://web.dev/explore/learn-core-web-vitals)), excluding search engines that don't render JS, and causing your site to receive less frequent updates from those that do. And finally, it makes your app inaccessible to users if JavaScript fails or is disabled (which happens [more often than you probably think](https://kryogenix.org/code/browser/everyonehasjs.html)).\n>\n> You can avoid these drawbacks by [prerendering](#Prerendering-individual-pages) as many pages as possible when using SPA mode (especially your homepage). If you can prerender all pages, you can simply use [static site generation](adapter-static) rather than a SPA. Otherwise, you should strongly consider using an adapter which supports server side rendering. SvelteKit has officially supported adapters for various providers with generous free tiers.\n\n## Usage\n\nFirst, disable SSR for the pages you don't want to prerender. These pages will be served via the fallback page; for example, to serve all pages via the fallback by default, you can update the root layout as shown below. You should [opt back into prerendering individual pages and directories](#Prerendering-individual-pages) where possible.\n```js\n/// file: src/routes/+layout.js\nexport const ssr = false;\n```\n\nIf you don't have any server-side logic (i.e. `+page.server.js`, `+layout.server.js` or `+server.js` files) you can use [`adapter-static`](adapter-static) to create your SPA. Install `adapter-static` with `npm i -D @sveltejs/adapter-static` and add it to your `svelte.config.js` with the `fallback` option:\n\n```js\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-static';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\tfallback: '200.html' // may differ from host to host\n\t\t})\n\t}\n};\n\nexport default config;\n```\n\nThe `fallback` page is an HTML page created by SvelteKit from your page template (e.g. `app.html`) that loads your app and navigates to the correct route. For example [Surge](https://surge.sh/help/adding-a-200-page-for-client-side-routing), a static web host, lets you add a `200.html` file that will handle any requests that don't correspond to static assets or prerendered pages.\n\nOn some hosts it may be something else entirely — consult your platform's documentation. We recommend avoiding `index.html` if possible as it may conflict with prerendering.\n\n> [!NOTE] Note that the fallback page will always contain absolute asset paths (i.e. beginning with `/` rather than `.`) regardless of the value of [`paths.relative`](configuration#paths), since it is used to respond to requests for arbitrary paths.\n\n## Prerendering individual pages\n\nIf you want certain pages to be prerendered, you can re-enable `ssr` alongside `prerender` for just those parts of your app:\n\n```js\n/// file: src/routes/my-prerendered-page/+page.js\nexport const prerender = true;\nexport const ssr = true;\n```\n\nYou won't need a Node server or server capable of running JavaScript to deploy this page. It will only server render your page while building your project for the purposes of outputting an `.html` page that can be served from any static web host.\n\n## Apache\n\nTo run an SPA on [Apache](https://httpd.apache.org/), you should add a `static/.htaccess` file to route requests to the fallback page:\n\n```\n\u003CIfModule mod_rewrite.c>\n\tRewriteEngine On\n\tRewriteBase /\n\tRewriteRule ^200\\.html$ - [L]\n\tRewriteCond %{REQUEST_FILENAME} !-f\n\tRewriteCond %{REQUEST_FILENAME} !-d\n\tRewriteRule . /200.html [L]\n\u003C/IfModule>\n```\n","## Creating a Single-Page App\n\nTurn a SvelteKit app into a fully client-rendered SPA by specifying a fallback page that serves any URLs not handled by other means.\n\n### Setup\n\nDisable SSR for pages you don't want to prerender in your root layout:\n\n```js\n/// file: src/routes/+layout.js\nexport const ssr = false;\n```\n\nUse `adapter-static` with the `fallback` option:\n\n```js\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-static';\n\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\tfallback: '200.html'\n\t\t})\n\t}\n};\n\nexport default config;\n```\n\nThe fallback page is an HTML file created from your app template that loads your app and navigates to the correct route. The specific filename depends on your host (e.g., Surge uses `200.html`).\n\n### Prerendering Individual Pages\n\nRe-enable SSR and add prerender for specific pages:\n\n```js\n/// file: src/routes/my-prerendered-page/+page.js\nexport const prerender = true;\nexport const ssr = true;\n```\n\nThese pages render at build time and output as static `.html` files, requiring no Node server to deploy.\n\n### Apache Configuration\n\nAdd `static/.htaccess` to route requests to the fallback page:\n\n```\n\u003CIfModule mod_rewrite.c>\n\tRewriteEngine On\n\tRewriteBase /\n\tRewriteRule ^200\\.html$ - [L]\n\tRewriteCond %{REQUEST_FILENAME} !-f\n\tRewriteCond %{REQUEST_FILENAME} !-d\n\tRewriteRule . /200.html [L]\n\u003C/IfModule>\n```\n\n### Performance Considerations\n\nSPAs have significant drawbacks: multiple network round trips delay startup, harm SEO through performance penalties and Core Web Vitals failures, exclude non-JS-rendering search engines, and fail when JavaScript is disabled. Prerender as many pages as possible, especially the homepage. If all pages can be prerendered, use static site generation instead. Otherwise, use an adapter supporting server-side rendering.","## Single-Page App Setup\n\nDisable SSR globally and use `adapter-static` with a fallback page:\n\n```js\n// src/routes/+layout.js\nexport const ssr = false;\n\n// svelte.config.js\nimport adapter from '@sveltejs/adapter-static';\nconst config = {\n\tkit: { adapter: adapter({ fallback: '200.html' }) }\n};\n```\n\nPrerender specific pages by enabling SSR and prerender for those routes:\n\n```js\nexport const prerender = true;\nexport const ssr = true;\n```\n\nFor Apache, add `.htaccess` to route unmatched requests to the fallback page.\n\n**Warning:** SPAs have poor performance, SEO, and accessibility. Prerender as many pages as possible or use static site generation instead.","Configure SvelteKit as a client-rendered single-page app using adapter-static with a fallback page, with options to prerender individual pages.","cloudflare-deployment",{"name":392,"path":394,"children":395,"data":396},"build-and-deploy/cloudflare-deployment",["Map"],{"type":22,"path":397,"relevant":44,"token_counts":398,"usage":402,"markdown":405},"25-build-and-deploy/60-adapter-cloudflare.md",{"fulltext":399,"digest":400,"short_digest":401},3382,902,333,{"input":403,"output":404,"details":32},4431,1358,{"fulltext":406,"digest":407,"short_digest":408,"essence":409},"---\ntitle: Cloudflare\n---\n\nTo deploy to [Cloudflare Workers](https://workers.cloudflare.com/) or [Cloudflare Pages](https://pages.cloudflare.com/), use [`adapter-cloudflare`](https://github.com/sveltejs/kit/tree/main/packages/adapter-cloudflare).\n\nThis adapter will be installed by default when you use [`adapter-auto`](adapter-auto). If you plan on staying with Cloudflare, you can switch from [`adapter-auto`](adapter-auto) to using this adapter directly so that `event.platform` is emulated during local development, type declarations are automatically applied, and the ability to set Cloudflare-specific options is provided.\n\n## Comparisons\n\n- `adapter-cloudflare` – supports all SvelteKit features; builds for Cloudflare Workers Static Assets and Cloudflare Pages\n- `adapter-cloudflare-workers` – deprecated. Supports all SvelteKit features; builds for Cloudflare Workers Sites\n- `adapter-static` – only produces client-side static assets; compatible with Cloudflare Workers Static Assets and Cloudflare Pages\n\n## Usage\n\nInstall with `npm i -D @sveltejs/adapter-cloudflare`, then add the adapter to your `svelte.config.js`:\n\n```js\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-cloudflare';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// See below for an explanation of these options\n\t\t\tconfig: undefined,\n\t\t\tplatformProxy: {\n\t\t\t\tconfigPath: undefined,\n\t\t\t\tenvironment: undefined,\n\t\t\t\tpersist: undefined\n\t\t\t},\n\t\t\tfallback: 'plaintext',\n\t\t\troutes: {\n\t\t\t\tinclude: ['/*'],\n\t\t\t\texclude: ['\u003Call>']\n\t\t\t}\n\t\t})\n\t}\n};\n\nexport default config;\n```\n\n## Options\n\n### config\n\nPath to your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/). If you would like to use a Wrangler configuration filename other than `wrangler.jsonc`, `wrangler.json`, or `wrangler.toml` you can specify it using this option.\n\n### platformProxy\n\nPreferences for the emulated `platform.env` local bindings. See the [getPlatformProxy](https://developers.cloudflare.com/workers/wrangler/api/#parameters-1) Wrangler API documentation for a full list of options.\n\n### fallback\n\nWhether to render a plaintext 404.html page or a rendered SPA fallback page for non-matching asset requests.\n\nFor Cloudflare Workers, the default behaviour is to return a null-body 404-status response for non-matching assets requests. However, if the [`assets.not_found_handling`](https://developers.cloudflare.com/workers/static-assets/routing/#2-not_found_handling) Wrangler configuration setting is set to `\"404-page\"`, this page will be served if a request fails to match an asset. If `assets.not_found_handling` is set to `\"single-page-application\"`, the adapter will render a SPA fallback index.html page regardless of the `fallback` option specified.\n\nFor Cloudflare Pages, this page will only be served when a request that matches an entry in `routes.exclude` fails to match an asset.\n\nMost of the time `plaintext` is sufficient, but if you are using `routes.exclude` to manually\nexclude a set of prerendered pages without exceeding the 100 route limit, you may wish to\nuse `spa` instead to avoid showing an unstyled 404 page to users.\n\nSee Cloudflare Pages' [Not Found behaviour](https://developers.cloudflare.com/pages/configuration/serving-pages/#not-found-behavior) for more info.\n\n### routes\n\nOnly for Cloudflare Pages. Allows you to customise the [`_routes.json`](https://developers.cloudflare.com/pages/functions/routing/#create-a-_routesjson-file) file generated by `adapter-cloudflare`.\n\n- `include` defines routes that will invoke a function, and defaults to `['/*']`\n- `exclude` defines routes that will _not_ invoke a function — this is a faster and cheaper way to serve your app's static assets. This array can include the following special values:\n\t- `\u003Cbuild>` contains your app's build artifacts (the files generated by Vite)\n\t- `\u003Cfiles>` contains the contents of your `static` directory\n\t- `\u003Cprerendered>` contains a list of prerendered pages\n\t- `\u003Call>` (the default) contains all of the above\n\nYou can have up to 100 `include` and `exclude` rules combined. Generally you can omit the `routes` options, but if (for example) your `\u003Cprerendered>` paths exceed that limit, you may find it helpful to manually create an `exclude` list that includes `'/articles/*'` instead of the auto-generated `['/articles/foo', '/articles/bar', '/articles/baz', ...]`.\n\n## Cloudflare Workers\n\n### Basic configuration\n\nWhen building for Cloudflare Workers, this adapter expects to find a [Wrangler configuration file](https://developers.cloudflare.com/workers/configuration/sites/configuration/) in the project root. It should look something like this:\n\n```jsonc\n/// file: wrangler.jsonc\n{\n\t\"name\": \"\u003Cany-name-you-want>\",\n\t\"main\": \".svelte-kit/cloudflare/_worker.js\",\n\t\"compatibility_date\": \"2025-01-01\",\n\t\"assets\": {\n\t\t\"binding\": \"ASSETS\",\n\t\t\"directory\": \".svelte-kit/cloudflare\",\n\t}\n}\n```\n\n### Deployment\n\nPlease follow the [framework guide](https://developers.cloudflare.com/workers/frameworks/framework-guides/svelte/) for Cloudflare Workers to begin.\n\n## Cloudflare Pages\n\n### Deployment\n\nPlease follow the [Get Started Guide](https://developers.cloudflare.com/pages/get-started/) for Cloudflare Pages to begin.\n\nIf you're using the [Git integration](https://developers.cloudflare.com/pages/get-started/git-integration/), your build settings should look like this:\n\n- Framework preset – SvelteKit\n- Build command – `npm run build` or `vite build`\n- Build output directory – `.svelte-kit/cloudflare`\n\n### Further reading\n\nYou may wish to refer to [Cloudflare's documentation for deploying a SvelteKit site on Cloudflare Pages](https://developers.cloudflare.com/pages/framework-guides/deploy-a-svelte-kit-site/).\n\n### Notes\n\nFunctions contained in the [`/functions` directory](https://developers.cloudflare.com/pages/functions/routing/) at the project's root will _not_ be included in the deployment. Instead, functions should be implemented as [server endpoints](routing#server) in your SvelteKit app, which is compiled to a [single `_worker.js` file](https://developers.cloudflare.com/pages/functions/advanced-mode/).\n\n## Runtime APIs\n\nThe [`env`](https://developers.cloudflare.com/workers/runtime-apis/fetch-event#parameters) object contains your project's [bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/), which consist of KV/DO namespaces, etc. It is passed to SvelteKit via the `platform` property, along with [`ctx`](https://developers.cloudflare.com/workers/runtime-apis/context/), [`caches`](https://developers.cloudflare.com/workers/runtime-apis/cache/), and [`cf`](https://developers.cloudflare.com/workers/runtime-apis/request/#incomingrequestcfproperties), meaning that you can access it in hooks and endpoints:\n\n```js\n// @filename: ambient.d.ts\nimport { DurableObjectNamespace } from '@cloudflare/workers-types';\n\ndeclare global {\n\tnamespace App {\n\t\tinterface Platform {\n\t\t\tenv: {\n\t\t\t\tYOUR_DURABLE_OBJECT_NAMESPACE: DurableObjectNamespace;\n\t\t\t};\n\t\t}\n\t}\n}\n// @filename: +server.js\n// ---cut---\n// @errors: 2355 2322\n/// file: +server.js\n/** @type {import('./$types').RequestHandler} */\nexport async function POST({ request, platform }) {\n\tconst x = platform?.env.YOUR_DURABLE_OBJECT_NAMESPACE.idFromName('x');\n}\n```\n\n> [!NOTE] SvelteKit's built-in [`$env` module]($env-static-private) should be preferred for environment variables.\n\nTo make these types available to your app, install [`@cloudflare/workers-types`](https://www.npmjs.com/package/@cloudflare/workers-types) and reference them in your `src/app.d.ts`:\n\n```ts\n/// file: src/app.d.ts\n+++import { KVNamespace, DurableObjectNamespace } from '@cloudflare/workers-types';+++\n\ndeclare global {\n\tnamespace App {\n\t\tinterface Platform {\n+++\t\t\tenv: {\n\t\t\t\tYOUR_KV_NAMESPACE: KVNamespace;\n\t\t\t\tYOUR_DURABLE_OBJECT_NAMESPACE: DurableObjectNamespace;\n\t\t\t};+++\n\t\t}\n\t}\n}\n\nexport {};\n```\n\n### Testing locally\n\nCloudflare specific values in the `platform` property are emulated during dev and preview modes. Local [bindings](https://developers.cloudflare.com/workers/wrangler/configuration/#bindings) are created based on your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/) and are used to populate `platform.env` during development and preview. Use the adapter config [`platformProxy` option](#Options-platformProxy) to change your preferences for the bindings.\n\nFor testing the build, you should use [Wrangler](https://developers.cloudflare.com/workers/wrangler/) version 4. Once you have built your site, run `wrangler dev .svelte-kit/cloudflare` if you're testing for Cloudflare Workers or `wrangler pages dev .svelte-kit/cloudflare` for Cloudflare Pages.\n\n## Headers and redirects\n\nThe [`_headers`](https://developers.cloudflare.com/pages/configuration/headers/) and [`_redirects`](https://developers.cloudflare.com/pages/configuration/redirects/) files, specific to Cloudflare, can be used for static asset responses (like images) by putting them into the project root folder.\n\nHowever, they will have no effect on responses dynamically rendered by SvelteKit, which should return custom headers or redirect responses from [server endpoints](routing#server) or with the [`handle`](hooks#Server-hooks-handle) hook.\n\n## Troubleshooting\n\n### Node.js compatibility\n\nIf you would like to enable [Node.js compatibility](https://developers.cloudflare.com/workers/runtime-apis/nodejs/), you can add the `nodejs_compat` compatibility flag to your Wrangler configuration file:\n\n```jsonc\n/// file: wrangler.jsonc\n{\n\t\"compatibility_flags\": [\"nodejs_compat\"]\n}\n```\n\n### Worker size limits\n\nWhen deploying your application, the server generated by SvelteKit is bundled into a single file. Wrangler will fail to publish your worker if it exceeds [the size limits](https://developers.cloudflare.com/workers/platform/limits/#worker-size) after minification. You're unlikely to hit this limit usually, but some large libraries can cause this to happen. In that case, you can try to reduce the size of your worker by only importing such libraries on the client side. See [the FAQ](./faq#How-do-I-use-a-client-side-library-accessing-document-or-window) for more information.\n\n### Accessing the file system\n\nYou can't use `fs` in Cloudflare Workers.\n\nInstead, use the [`read`]($app-server#read) function from `$app/server` to access your files. It works by fetching the file from the deployed public assets location.\n\nAlternatively, you can [prerender](page-options#prerender) the routes in question.\n\n## Migrating from Workers Sites\n\nCloudflare no longer recommends using [Workers Sites](https://developers.cloudflare.com/workers/configuration/sites/configuration/) and instead recommends using [Workers Static Assets](https://developers.cloudflare.com/workers/static-assets/). To migrate, replace `@sveltejs/adapter-cloudflare-workers` with `@sveltejs/adapter-cloudflare` and remove all `site` configuration settings from your Wrangler configuration file, then add the `assets.directory` and `assets.binding` configuration settings:\n\n### svelte.config.js\n\n```js\n// @errors: 2307\n/// file: svelte.config.js\n---import adapter from '@sveltejs/adapter-cloudflare-workers';---\n+++import adapter from '@sveltejs/adapter-cloudflare';+++\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n\nexport default config;\n```\n\n### wrangler.toml\n\n```toml\n/// file: wrangler.toml\n---site.bucket = \".cloudflare/public\"---\n+++assets.directory = \".cloudflare/public\"\nassets.binding = \"ASSETS\" # Exclude this if you don't have a `main` key configured.+++\n```\n\n### wrangler.jsonc\n\n```jsonc\n/// file: wrangler.jsonc\n{\n---\t\"site\": {\n\t\t\"bucket\": \".cloudflare/public\"\n\t},---\n+++\t\"assets\": {\n\t\t\"directory\": \".cloudflare/public\",\n\t\t\"binding\": \"ASSETS\" // Exclude this if you don't have a `main` key configured.\n\t}+++\n}\n```\n","## Installation\n\nInstall `@sveltejs/adapter-cloudflare` and add to `svelte.config.js`:\n\n```js\nimport adapter from '@sveltejs/adapter-cloudflare';\n\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\tconfig: undefined,\n\t\t\tplatformProxy: {\n\t\t\t\tconfigPath: undefined,\n\t\t\t\tenvironment: undefined,\n\t\t\t\tpersist: undefined\n\t\t\t},\n\t\t\tfallback: 'plaintext',\n\t\t\troutes: {\n\t\t\t\tinclude: ['/*'],\n\t\t\t\texclude: ['\u003Call>']\n\t\t\t}\n\t\t})\n\t}\n};\n\nexport default config;\n```\n\n## Configuration Options\n\n- **config**: Path to Wrangler configuration file (wrangler.jsonc, wrangler.json, or wrangler.toml)\n- **platformProxy**: Preferences for emulated `platform.env` local bindings\n- **fallback**: `'plaintext'` for null-body 404 or `'spa'` for rendered SPA fallback page\n- **routes** (Cloudflare Pages only): Customize `_routes.json` with `include` and `exclude` arrays. Special values: `\u003Cbuild>`, `\u003Cfiles>`, `\u003Cprerendered>`, `\u003Call>`. Max 100 combined rules.\n\n## Cloudflare Workers Setup\n\nCreate `wrangler.jsonc`:\n\n```jsonc\n{\n\t\"name\": \"\u003Cany-name>\",\n\t\"main\": \".svelte-kit/cloudflare/_worker.js\",\n\t\"compatibility_date\": \"2025-01-01\",\n\t\"assets\": {\n\t\t\"binding\": \"ASSETS\",\n\t\t\"directory\": \".svelte-kit/cloudflare\"\n\t}\n}\n```\n\n## Cloudflare Pages Setup\n\nBuild settings:\n- Framework preset: SvelteKit\n- Build command: `npm run build` or `vite build`\n- Build output directory: `.svelte-kit/cloudflare`\n\nFunctions in `/functions` directory are not deployed. Use SvelteKit server endpoints instead, which compile to `_worker.js`.\n\n## Runtime APIs\n\nAccess Cloudflare bindings via `platform.env`:\n\n```js\ndeclare global {\n\tnamespace App {\n\t\tinterface Platform {\n\t\t\tenv: {\n\t\t\t\tYOUR_KV_NAMESPACE: KVNamespace;\n\t\t\t\tYOUR_DURABLE_OBJECT_NAMESPACE: DurableObjectNamespace;\n\t\t\t};\n\t\t}\n\t}\n}\n```\n\nUse in endpoints/hooks:\n\n```js\nexport async function POST({ request, platform }) {\n\tconst x = platform?.env.YOUR_DURABLE_OBJECT_NAMESPACE.idFromName('x');\n}\n```\n\nInstall `@cloudflare/workers-types` for type definitions.\n\n## Local Testing\n\nCloudflare values are emulated in dev/preview modes using Wrangler configuration. Test builds with Wrangler 4:\n- Workers: `wrangler dev .svelte-kit/cloudflare`\n- Pages: `wrangler pages dev .svelte-kit/cloudflare`\n\n## Headers and Redirects\n\nUse `_headers` and `_redirects` files in project root for static assets only. For dynamic responses, use server endpoints or the `handle` hook.\n\n## Troubleshooting\n\n- **Node.js compatibility**: Add `\"compatibility_flags\": [\"nodejs_compat\"]` to wrangler.jsonc\n- **Worker size limits**: Import large libraries client-side only\n- **File system access**: Use `read()` from `$app/server` or prerender routes instead of `fs`\n\n## Migration from Workers Sites\n\nReplace `@sveltejs/adapter-cloudflare-workers` with `@sveltejs/adapter-cloudflare`. Remove `site` config and add `assets.directory` and `assets.binding` to Wrangler configuration.","## Installation\n\n```js\nimport adapter from '@sveltejs/adapter-cloudflare';\n\nconst config = {\n\tkit: { adapter: adapter() }\n};\n```\n\n## Key Options\n\n- **fallback**: `'plaintext'` or `'spa'` for 404 handling\n- **routes**: Customize `_routes.json` with `include`/`exclude` (max 100 rules)\n\n## Cloudflare Workers\n\n```jsonc\n{\n\t\"main\": \".svelte-kit/cloudflare/_worker.js\",\n\t\"compatibility_date\": \"2025-01-01\",\n\t\"assets\": {\n\t\t\"binding\": \"ASSETS\",\n\t\t\"directory\": \".svelte-kit/cloudflare\"\n\t}\n}\n```\n\n## Cloudflare Pages\n\nBuild settings: SvelteKit preset, `npm run build`, output `.svelte-kit/cloudflare`. Use server endpoints instead of `/functions` directory.\n\n## Runtime APIs\n\n```js\nexport async function POST({ platform }) {\n\tconst x = platform?.env.YOUR_DURABLE_OBJECT_NAMESPACE.idFromName('x');\n}\n```\n\nInstall `@cloudflare/workers-types` for types.\n\n## Local Testing\n\n`wrangler dev .svelte-kit/cloudflare` (Workers) or `wrangler pages dev .svelte-kit/cloudflare` (Pages)","Deploy SvelteKit apps to Cloudflare Workers or Pages using adapter-cloudflare with configuration options, runtime API access, and local testing setup.","cloudflare-workers-deployment",{"name":410,"path":412,"children":413,"data":414},"build-and-deploy/cloudflare-workers-deployment",["Map"],{"type":22,"path":415,"relevant":44,"token_counts":416,"usage":419,"markdown":422},"25-build-and-deploy/70-adapter-cloudflare-workers.md",{"fulltext":417,"digest":297,"short_digest":418},1861,98,{"input":420,"output":421,"details":32},2912,682,{"fulltext":423,"digest":424,"short_digest":425,"essence":426},"---\ntitle: Cloudflare Workers\n---\n\n> [!NOTE] `adapter-cloudflare-workers` has been deprecated in favour of [`adapter-cloudflare`](adapter-cloudflare). We recommend using `adapter-cloudflare` to deploy to Cloudflare Workers with [Static Assets](https://developers.cloudflare.com/workers/static-assets/) since Cloudflare Workers Sites will be deprecated in favour of it.\n\nTo deploy to [Cloudflare Workers](https://workers.cloudflare.com/) with [Workers Sites](https://developers.cloudflare.com/workers/configuration/sites/), use `adapter-cloudflare-workers`.\n\n## Usage\n\nInstall with `npm i -D @sveltejs/adapter-cloudflare-workers`, then add the adapter to your `svelte.config.js`:\n\n```js\n// @errors: 2307\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-cloudflare-workers';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// see below for options that can be set here\n\t\t})\n\t}\n};\n\nexport default config;\n```\n\n## Options\n\n### config\n\nPath to your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/configuration/). If you would like to use a Wrangler configuration filename other than `wrangler.jsonc`, `wrangler.json`, or `wrangler.toml` you can specify it using this option.\n\n### platformProxy\n\nPreferences for the emulated `platform.env` local bindings. See the [getPlatformProxy](https://developers.cloudflare.com/workers/wrangler/api/#parameters-1) Wrangler API documentation for a full list of options.\n\n## Basic Configuration\n\nThis adapter expects to find a [Wrangler configuration file](https://developers.cloudflare.com/workers/configuration/sites/configuration/) in the project root. It should look something like this:\n\n```jsonc\n/// file: wrangler.jsonc\n{\n\t\"name\": \"\u003Cyour-service-name>\",\n\t\"account_id\": \"\u003Cyour-account-id>\",\n\t\"main\": \"./.cloudflare/worker.js\",\n\t\"site\": {\n\t\t\"bucket\": \"./.cloudflare/public\"\n\t},\n\t\"build\": {\n\t\t\"command\": \"npm run build\"\n\t},\n\t\"compatibility_date\": \"2021-11-12\"\n}\n```\n\n`\u003Cyour-service-name>` can be anything. `\u003Cyour-account-id>` can be found by running `wrangler whoami` using the Wrangler CLI tool or by logging into your [Cloudflare dashboard](https://dash.cloudflare.com) and grabbing it from the end of the URL:\n\n```\nhttps://dash.cloudflare.com/\u003Cyour-account-id>/home\n```\n\n> [!NOTE] You should add the `.cloudflare` directory (or whichever directories you specified for `main` and `site.bucket`) and the `.wrangler` directory to your `.gitignore`.\n\nYou will need to install [Wrangler](https://developers.cloudflare.com/workers/wrangler/install-and-update/) and log in, if you haven't already:\n\n```sh\nnpm i -D wrangler\nwrangler login\n```\n\nThen, you can build your app and deploy it:\n\n```sh\nwrangler deploy\n```\n\n## Runtime APIs\n\nThe [`env`](https://developers.cloudflare.com/workers/runtime-apis/fetch-event#parameters) object contains your project's [bindings](https://developers.cloudflare.com/workers/runtime-apis/bindings/), which consist of KV/DO namespaces, etc. It is passed to SvelteKit via the `platform` property, along with [`ctx`](https://developers.cloudflare.com/workers/runtime-apis/context/), [`caches`](https://developers.cloudflare.com/workers/runtime-apis/cache/), and [`cf`](https://developers.cloudflare.com/workers/runtime-apis/request/#incomingrequestcfproperties), meaning that you can access it in hooks and endpoints:\n\n```js\n// @filename: ambient.d.ts\nimport { DurableObjectNamespace } from '@cloudflare/workers-types';\n\ndeclare global {\n\tnamespace App {\n\t\tinterface Platform {\n\t\t\tenv: {\n\t\t\t\tYOUR_DURABLE_OBJECT_NAMESPACE: DurableObjectNamespace;\n\t\t\t};\n\t\t}\n\t}\n}\n// @filename: +server.js\n// ---cut---\n// @errors: 2355 2322\n/// file: +server.js\n/** @type {import('./$types').RequestHandler} */\nexport async function POST({ request, platform }) {\n\tconst x = platform?.env.YOUR_DURABLE_OBJECT_NAMESPACE.idFromName('x');\n}\n```\n\n> [!NOTE] SvelteKit's built-in [`$env` module]($env-static-private) should be preferred for environment variables.\n\nTo make these types available to your app, install [`@cloudflare/workers-types`](https://www.npmjs.com/package/@cloudflare/workers-types) and reference them in your `src/app.d.ts`:\n\n```ts\n/// file: src/app.d.ts\n+++import { KVNamespace, DurableObjectNamespace } from '@cloudflare/workers-types';+++\n\ndeclare global {\n\tnamespace App {\n\t\tinterface Platform {\n+++\t\t\tenv?: {\n\t\t\t\tYOUR_KV_NAMESPACE: KVNamespace;\n\t\t\t\tYOUR_DURABLE_OBJECT_NAMESPACE: DurableObjectNamespace;\n\t\t\t};+++\n\t\t}\n\t}\n}\n\nexport {};\n```\n\n### Testing Locally\n\nCloudflare Workers specific values in the `platform` property are emulated during dev and preview modes. Local [bindings](https://developers.cloudflare.com/workers/wrangler/configuration/#bindings) are created based on your [Wrangler configuration file](https://developers.cloudflare.com/workers/wrangler/) and are used to populate `platform.env` during development and preview. Use the adapter config [`platformProxy` option](#Options-platformProxy) to change your preferences for the bindings.\n\nFor testing the build, you should use [Wrangler](https://developers.cloudflare.com/workers/wrangler/) version 4. Once you have built your site, run `wrangler dev`.\n\n## Troubleshooting\n\n### Node.js compatibility\n\nIf you would like to enable [Node.js compatibility](https://developers.cloudflare.com/workers/runtime-apis/nodejs/), you can add the `nodejs_compat` compatibility flag to your Wrangler configuration file:\n\n```jsonc\n/// file: wrangler.jsonc\n{\n\t\"compatibility_flags\": [\"nodejs_compat\"]\n}\n```\n\n### Worker size limits\n\nWhen deploying your application, the server generated by SvelteKit is bundled into a single file. Wrangler will fail to publish your worker if it exceeds [the size limits](https://developers.cloudflare.com/workers/platform/limits/#worker-size) after minification. You're unlikely to hit this limit usually, but some large libraries can cause this to happen. In that case, you can try to reduce the size of your worker by only importing such libraries on the client side. See [the FAQ](./faq#How-do-I-use-a-client-side-library-accessing-document-or-window) for more information.\n\n### Accessing the file system\n\nYou can't use `fs` in Cloudflare Workers — you must [prerender](page-options#prerender) the routes in question.\n","**Deprecation Notice**: `adapter-cloudflare-workers` is deprecated in favor of `adapter-cloudflare` with Static Assets.\n\n**Installation & Setup**:\n```js\nimport adapter from '@sveltejs/adapter-cloudflare-workers';\nexport default {\n  kit: { adapter: adapter() }\n};\n```\n\n**Wrangler Configuration** (`wrangler.jsonc`):\n```jsonc\n{\n  \"name\": \"\u003Cservice-name>\",\n  \"account_id\": \"\u003Caccount-id>\",\n  \"main\": \"./.cloudflare/worker.js\",\n  \"site\": { \"bucket\": \"./.cloudflare/public\" },\n  \"build\": { \"command\": \"npm run build\" },\n  \"compatibility_date\": \"2021-11-12\"\n}\n```\n\n**Adapter Options**:\n- `config`: Path to Wrangler configuration file (if not using default names)\n- `platformProxy`: Preferences for emulated `platform.env` local bindings\n\n**Runtime APIs**: Access Cloudflare bindings (KV, Durable Objects) via `platform.env` in hooks and endpoints:\n```js\nexport async function POST({ platform }) {\n  const x = platform?.env.YOUR_DURABLE_OBJECT_NAMESPACE.idFromName('x');\n}\n```\n\nType bindings in `src/app.d.ts` using `@cloudflare/workers-types`.\n\n**Local Testing**: Bindings are emulated in dev/preview modes based on Wrangler config. Use Wrangler 4+ to test builds with `wrangler dev`.\n\n**Troubleshooting**:\n- Enable Node.js compatibility with `\"compatibility_flags\": [\"nodejs_compat\"]`\n- Worker size limits: reduce by importing large libraries client-side only\n- File system access: use prerendering instead of `fs`","**Deprecated** in favor of `adapter-cloudflare`. Install `@sveltejs/adapter-cloudflare-workers` and configure Wrangler. Access Cloudflare bindings via `platform.env`. Type with `@cloudflare/workers-types`. Test locally with Wrangler 4+. Reduce worker size by client-side imports; use prerendering instead of `fs`.","Deploy SvelteKit to Cloudflare Workers using the deprecated adapter-cloudflare-workers (use adapter-cloudflare instead), configure Wrangler, and access runtime bindings through platform.env.","netlify",{"name":427,"path":429,"children":430,"data":431},"build-and-deploy/netlify",["Map"],{"type":22,"path":432,"relevant":44,"token_counts":433,"usage":437,"markdown":440},"25-build-and-deploy/80-adapter-netlify.md",{"fulltext":434,"digest":435,"short_digest":436},1892,502,126,{"input":438,"output":439,"details":32},2940,757,{"fulltext":441,"digest":442,"short_digest":443,"essence":444},"---\ntitle: Netlify\n---\n\nTo deploy to Netlify, use [`adapter-netlify`](https://github.com/sveltejs/kit/tree/main/packages/adapter-netlify).\n\nThis adapter will be installed by default when you use [`adapter-auto`](adapter-auto), but adding it to your project allows you to specify Netlify-specific options.\n\n## Usage\n\nInstall with `npm i -D @sveltejs/adapter-netlify`, then add the adapter to your `svelte.config.js`:\n\n```js\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-netlify';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\t// default options are shown\n\t\tadapter: adapter({\n\t\t\t// if true, will create a Netlify Edge Function rather\n\t\t\t// than using standard Node-based functions\n\t\t\tedge: false,\n\n\t\t\t// if true, will split your app into multiple functions\n\t\t\t// instead of creating a single one for the entire app.\n\t\t\t// if `edge` is true, this option cannot be used\n\t\t\tsplit: false\n\t\t})\n\t}\n};\n\nexport default config;\n```\n\nThen, make sure you have a [netlify.toml](https://docs.netlify.com/configure-builds/file-based-configuration) file in the project root. This will determine where to write static assets based on the `build.publish` settings, as per this sample configuration:\n\n```toml\n[build]\n\tcommand = \"npm run build\"\n\tpublish = \"build\"\n```\n\nIf the `netlify.toml` file or the `build.publish` value is missing, a default value of `\"build\"` will be used. Note that if you have set the publish directory in the Netlify UI to something else then you will need to set it in `netlify.toml` too, or use the default value of `\"build\"`.\n\n### Node version\n\nNew projects will use the current Node LTS version by default. However, if you're upgrading a project you created a while ago it may be stuck on an older version. See [the Netlify docs](https://docs.netlify.com/configure-builds/manage-dependencies/#node-js-and-javascript) for details on manually specifying a current Node version.\n\n## Netlify Edge Functions\n\nSvelteKit supports [Netlify Edge Functions](https://docs.netlify.com/build/edge-functions/overview/). If you pass the option `edge: true` to the `adapter` function, server-side rendering will happen in a Deno-based edge function that's deployed close to the site visitor. If set to `false` (the default), the site will deploy to Node-based Netlify Functions.\n\n```js\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-netlify';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// will create a Netlify Edge Function using Deno-based\n\t\t\t// rather than using standard Node-based functions\n\t\t\tedge: true\n\t\t})\n\t}\n};\n\nexport default config;\n```\n\n## Netlify alternatives to SvelteKit functionality\n\nYou may build your app using functionality provided directly by SvelteKit without relying on any Netlify functionality. Using the SvelteKit versions of these features will allow them to be used in dev mode, tested with integration tests, and to work with other adapters should you ever decide to switch away from Netlify. However, in some scenarios you may find it beneficial to use the Netlify versions of these features. One example would be if you're migrating an app that's already hosted on Netlify to SvelteKit.\n\n### `_headers` and `_redirects`\n\nThe [`_headers`](https://docs.netlify.com/routing/headers/#syntax-for-the-headers-file) and [`_redirects`](https://docs.netlify.com/routing/redirects/redirect-options/) files specific to Netlify can be used for static asset responses (like images) by putting them into the project root folder.\n\n### Redirect rules\n\nDuring compilation, redirect rules are automatically appended to your `_redirects` file. (If it doesn't exist yet, it will be created.) That means:\n\n- `[[redirects]]` in `netlify.toml` will never match as `_redirects` has a [higher priority](https://docs.netlify.com/routing/redirects/#rule-processing-order). So always put your rules in the [`_redirects` file](https://docs.netlify.com/routing/redirects/#syntax-for-the-redirects-file).\n- `_redirects` shouldn't have any custom \"catch all\" rules such as `/* /foobar/:splat`. Otherwise the automatically appended rule will never be applied as Netlify is only processing [the first matching rule](https://docs.netlify.com/routing/redirects/#rule-processing-order).\n\n### Netlify Forms\n\n1. Create your Netlify HTML form as described [here](https://docs.netlify.com/forms/setup/#html-forms), e.g. as `/routes/contact/+page.svelte`. (Don't forget to add the hidden `form-name` input element!)\n2. Netlify's build bot parses your HTML files at deploy time, which means your form must be [prerendered](page-options#prerender) as HTML. You can either add `export const prerender = true` to your `contact.svelte` to prerender just that page or set the `kit.prerender.force: true` option to prerender all pages.\n3. If your Netlify form has a [custom success message](https://docs.netlify.com/forms/setup/#success-messages) like `\u003Cform netlify ... action=\"/success\">` then ensure the corresponding `/routes/success/+page.svelte` exists and is prerendered.\n\n### Netlify Functions\n\nWith this adapter, SvelteKit endpoints are hosted as [Netlify Functions](https://docs.netlify.com/functions/overview/). Netlify function handlers have additional context, including [Netlify Identity](https://docs.netlify.com/visitor-access/identity/) information. You can access this context via the `event.platform.context` field inside your hooks and `+page.server` or `+layout.server` endpoints. These are [serverless functions](https://docs.netlify.com/functions/overview/) when the `edge` property is `false` in the adapter config or [edge functions](https://docs.netlify.com/edge-functions/overview/#app) when it is `true`.\n\n```js\n// @errors: 2339\n// @filename: ambient.d.ts\n/// \u003Creference types=\"@sveltejs/adapter-netlify\" />\n// @filename: +page.server.js\n// ---cut---\n/// file: +page.server.js\n/** @type {import('./$types').PageServerLoad} */\nexport const load = async (event) => {\n\tconst context = event.platform?.context;\n\tconsole.log(context); // shows up in your functions log in the Netlify app\n};\n```\n\nAdditionally, you can add your own Netlify functions by creating a directory for them and adding the configuration to your `netlify.toml` file. For example:\n\n```toml\n[build]\n\tcommand = \"npm run build\"\n\tpublish = \"build\"\n\n[functions]\n\tdirectory = \"functions\"\n```\n\n## Troubleshooting\n\n### Accessing the file system\n\nYou can't use `fs` in edge deployments.\n\nYou _can_ use it in serverless deployments, but it won't work as expected, since files are not copied from your project into your deployment. Instead, use the [`read`]($app-server#read) function from `$app/server` to access your files. It also works inside edge deployments by fetching the file from the deployed public assets location.\n\nAlternatively, you can [prerender](page-options#prerender) the routes in question.\n","## Installation and Setup\n\nInstall `@sveltejs/adapter-netlify` and add to `svelte.config.js`:\n\n```js\nimport adapter from '@sveltejs/adapter-netlify';\n\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\tedge: false,      // Use Netlify Edge Functions (Deno-based)\n\t\t\tsplit: false      // Split app into multiple functions\n\t\t})\n\t}\n};\nexport default config;\n```\n\nCreate `netlify.toml` in project root:\n```toml\n[build]\n\tcommand = \"npm run build\"\n\tpublish = \"build\"\n```\n\n## Netlify Edge Functions\n\nSet `edge: true` to deploy server-side rendering to Deno-based edge functions deployed near visitors, instead of Node-based Netlify Functions.\n\n## Netlify-Specific Features\n\n**`_headers` and `_redirects` files**: Place in project root for static asset responses. Redirect rules are automatically appended to `_redirects` during compilation—don't use `[[redirects]]` in `netlify.toml` as `_redirects` has higher priority.\n\n**Netlify Forms**: Create HTML form in route (e.g., `/routes/contact/+page.svelte`), add hidden `form-name` input, and prerender the page with `export const prerender = true` or `kit.prerender.force: true`.\n\n**Netlify Functions**: SvelteKit endpoints become Netlify Functions. Access Netlify context via `event.platform.context` in hooks and server endpoints:\n\n```js\nexport const load = async (event) => {\n\tconst context = event.platform?.context;\n\tconsole.log(context);\n};\n```\n\nAdd custom functions by creating a directory and configuring in `netlify.toml`:\n```toml\n[functions]\n\tdirectory = \"functions\"\n```\n\n## Troubleshooting\n\n**File system access**: Can't use `fs` in edge deployments. In serverless deployments, use `read()` from `$app/server` instead, which works in both environments. Alternatively, prerender routes.","Install `@sveltejs/adapter-netlify` and configure `svelte.config.js` with `edge` and `split` options. Create `netlify.toml` with build command and publish directory. Use `edge: true` for Deno-based edge functions. Access Netlify context via `event.platform?.context`. Use `_redirects` file for redirects (higher priority than `netlify.toml`). For file system access, use `read()` from `$app/server` instead of `fs`.","Deploy SvelteKit to Netlify using adapter-netlify with options for edge functions and function splitting, with access to Netlify-specific features like context, forms, and custom functions.","vercel-deployment",{"name":445,"path":447,"children":448,"data":449},"build-and-deploy/vercel-deployment",["Map"],{"type":22,"path":450,"relevant":44,"token_counts":451,"usage":455,"markdown":458},"25-build-and-deploy/90-adapter-vercel.md",{"fulltext":452,"digest":453,"short_digest":454},2844,995,342,{"input":456,"output":457,"details":32},3892,1462,{"fulltext":459,"digest":460,"short_digest":461,"essence":462},"---\ntitle: Vercel\n---\n\nTo deploy to Vercel, use [`adapter-vercel`](https://github.com/sveltejs/kit/tree/main/packages/adapter-vercel).\n\nThis adapter will be installed by default when you use [`adapter-auto`](adapter-auto), but adding it to your project allows you to specify Vercel-specific options.\n\n## Usage\n\nInstall with `npm i -D @sveltejs/adapter-vercel`, then add the adapter to your `svelte.config.js`:\n\n```js\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-vercel';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// see below for options that can be set here\n\t\t})\n\t}\n};\n\nexport default config;\n```\n\n## Deployment configuration\n\nTo control how your routes are deployed to Vercel as functions, you can specify deployment configuration, either through the option shown above or with [`export const config`](page-options#config) inside `+server.js`, `+page(.server).js` and `+layout(.server).js` files.\n\nFor example you could deploy one specific route as an individual serverless function, separate from the rest of your app:\n\n```js\n/// file: about/+page.js\n/** @type {import('@sveltejs/adapter-vercel').Config} */\nexport const config = {\n\tsplit: true\n};\n```\n\nThe following options apply to all functions:\n\n- `runtime`: `'edge'`, `'nodejs20.x'` or `'nodejs22.x'`. By default, the adapter will select the `'nodejs\u003Cversion>.x'` corresponding to the Node version your project is configured to use on the Vercel dashboard\n  > [!NOTE] This option is deprecated and will be removed in a future version, at which point all your functions will use whichever Node version is specified in the project configuration on Vercel\n- `regions`: an array of [edge network regions](https://vercel.com/docs/concepts/edge-network/regions) (defaulting to `[\"iad1\"]` for serverless functions) or `'all'` if `runtime` is `edge` (its default). Note that multiple regions for serverless functions are only supported on Enterprise plans\n- `split`: if `true`, causes a route to be deployed as an individual function. If `split` is set to `true` at the adapter level, all routes will be deployed as individual functions\n\nAdditionally, the following option applies to edge functions:\n- `external`: an array of dependencies that esbuild should treat as external when bundling functions. This should only be used to exclude optional dependencies that will not run outside Node\n\nAnd the following option apply to serverless functions:\n- `memory`: the amount of memory available to the function. Defaults to `1024` Mb, and can be decreased to `128` Mb or [increased](https://vercel.com/docs/concepts/limits/overview#serverless-function-memory) in 64Mb increments up to `3008` Mb on Pro or Enterprise accounts\n- `maxDuration`: [maximum execution duration](https://vercel.com/docs/functions/runtimes#max-duration) of the function. Defaults to `10` seconds for Hobby accounts, `15` for Pro and `900` for Enterprise\n- `isr`: configuration Incremental Static Regeneration, described below\n\nConfiguration set in a layout applies to all the routes beneath that layout, unless overridden at a more granular level.\n\nIf your functions need to access data in a specific region, it's recommended that they be deployed in the same region (or close to it) for optimal performance.\n\n## Image Optimization\n\nYou may set the `images` config to control how Vercel builds your images. See the [image configuration reference](https://vercel.com/docs/build-output-api/v3/configuration#images) for full details. As an example, you may set:\n\n```js\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-vercel';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\timages: {\n\t\t\t\tsizes: [640, 828, 1200, 1920, 3840],\n\t\t\t\tformats: ['image/avif', 'image/webp'],\n\t\t\t\tminimumCacheTTL: 300,\n\t\t\t\tdomains: ['example-app.vercel.app'],\n\t\t\t}\n\t\t})\n\t}\n};\n\nexport default config;\n```\n\n## Incremental Static Regeneration\n\nVercel supports [Incremental Static Regeneration](https://vercel.com/docs/incremental-static-regeneration) (ISR), which provides the performance and cost advantages of prerendered content with the flexibility of dynamically rendered content.\n\n> [!NOTE] Use ISR only on routes where every visitor should see the same content (much like when you prerender). If there's anything user-specific happening (like session cookies), they should happen on the client via JavaScript only to not leak sensitive information across visits\n\nTo add ISR to a route, include the `isr` property in your `config` object:\n\n```js\nimport { BYPASS_TOKEN } from '$env/static/private';\n\n/** @type {import('@sveltejs/adapter-vercel').Config} */\nexport const config = {\n\tisr: {\n\t\texpiration: 60,\n\t\tbypassToken: BYPASS_TOKEN,\n\t\tallowQuery: ['search']\n\t}\n};\n```\n\n> [!NOTE] Using ISR on a route with `export const prerender = true` will have no effect, since the route is prerendered at build time\n\nThe `expiration` property is required; all others are optional. The properties are discussed in more detail below.\n\n### expiration\n\nThe expiration time (in seconds) before the cached asset will be re-generated by invoking the Serverless Function. Setting the value to `false` means it will never expire. In that case, you likely want to define a bypass token to re-generate on demand.\n\n### bypassToken\n\nA random token that can be provided in the URL to bypass the cached version of the asset, by requesting the asset with a `__prerender_bypass=\u003Ctoken>` cookie.\n\nMaking a `GET` or `HEAD` request with `x-prerender-revalidate: \u003Ctoken>` will force the asset to be re-validated.\n\nNote that the `BYPASS_TOKEN` string must be at least 32 characters long. You could generate one using the JavaScript console like so:\n\n```js\ncrypto.randomUUID();\n```\n\nSet this string as an environment variable on Vercel by logging in and going to your project then Settings > Environment Variables. For \"Key\" put `BYPASS_TOKEN` and for \"value\" use the string generated above, then hit \"Save\".\n\nTo get this key known about for local development, you can use the [Vercel CLI](https://vercel.com/docs/cli/env) by running the `vercel env pull` command locally like so:\n\n```sh\nvercel env pull .env.development.local\n```\n\n### allowQuery\n\nA list of valid query parameters that contribute to the cache key. Other parameters (such as utm tracking codes) will be ignored, ensuring that they do not result in content being re-generated unnecessarily. By default, query parameters are ignored.\n\n> [!NOTE] Pages that are  [prerendered](page-options#prerender) will ignore ISR configuration.\n\n## Environment variables\n\nVercel makes a set of [deployment-specific environment variables](https://vercel.com/docs/concepts/projects/environment-variables#system-environment-variables) available. Like other environment variables, these are accessible from `$env/static/private` and `$env/dynamic/private` (sometimes — more on that later), and inaccessible from their public counterparts. To access one of these variables from the client:\n\n```js\n/// file: +layout.server.js\nimport { VERCEL_COMMIT_REF } from '$env/static/private';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport function load() {\n\treturn {\n\t\tdeploymentGitBranch: VERCEL_COMMIT_REF\n\t};\n}\n```\n\n```svelte\n\u003C!--- file: +layout.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').LayoutProps} */\n\tlet { data } = $props();\n\u003C/script>\n\n\u003Cp>This staging environment was deployed from {data.deploymentGitBranch}.\u003C/p>\n```\n\nSince all of these variables are unchanged between build time and run time when building on Vercel, we recommend using `$env/static/private` — which will statically replace the variables, enabling optimisations like dead code elimination — rather than `$env/dynamic/private`.\n\n## Skew protection\n\nWhen a new version of your app is deployed, assets belonging to the previous version may no longer be accessible. If a user is actively using your app when this happens, it can cause errors when they navigate — this is known as _version skew_. SvelteKit mitigates this by detecting errors resulting from version skew and causing a hard reload to get the latest version of the app, but this will cause any client-side state to be lost. (You can also proactively mitigate it by observing [`updated.current`]($app-state#updated) from `$app/state`, which tells clients when a new version has been deployed.)\n\n[Skew protection](https://vercel.com/docs/deployments/skew-protection) is a Vercel feature that routes client requests to their original deployment. When a user visits your app, a cookie is set with the deployment ID, and any subsequent requests will be routed to that deployment for as long as skew protection is active. When they reload the page, they will get the newest deployment. (`updated.current` is exempted from this behaviour, and so will continue to report new deployments.) To enable it, visit the Advanced section of your project settings on Vercel.\n\nCookie-based skew protection comes with one caveat: if a user has multiple versions of your app open in multiple tabs, requests from older versions will be routed to the newer one, meaning they will fall back to SvelteKit's built-in skew protection.\n\n## Notes\n\n### Vercel functions\n\nIf you have Vercel functions contained in the `api` directory at the project's root, any requests for `/api/*` will _not_ be handled by SvelteKit. You should implement these as [API routes](routing#server) in your SvelteKit app instead, unless you need to use a non-JavaScript language in which case you will need to ensure that you don't have any `/api/*` routes in your SvelteKit app.\n\n### Node version\n\nProjects created before a certain date may default to using an older Node version than what SvelteKit currently requires. You can [change the Node version in your project settings](https://vercel.com/docs/concepts/functions/serverless-functions/runtimes/node-js#node.js-version).\n\n## Troubleshooting\n\n### Accessing the file system\n\nYou can't use `fs` in edge functions.\n\nYou _can_ use it in serverless functions, but it won't work as expected, since files are not copied from your project into your deployment. Instead, use the [`read`]($app-server#read) function from `$app/server` to access your files. It also works inside routes deployed as edge functions by fetching the file from the deployed public assets location.\n\nAlternatively, you can [prerender](page-options#prerender) the routes in question.\n\n### Deployment protection\n\nIf using [`read`]($app-server#read) in an edge function, SvelteKit will `fetch` the file in question from your deployment. If you are using [Deployment Protection](https://vercel.com/docs/deployment-protection), you must also enable [Protection Bypass for Automation](https://vercel.com/docs/deployment-protection/methods-to-bypass-deployment-protection/protection-bypass-automation) so that the request does not result in a [401 Unauthorized](https://http.dog/401) response.\n","## Installation and Setup\n\nInstall `@sveltejs/adapter-vercel` and configure it in `svelte.config.js`:\n\n```js\nimport adapter from '@sveltejs/adapter-vercel';\n\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// options here\n\t\t})\n\t}\n};\n\nexport default config;\n```\n\n## Deployment Configuration\n\nControl route deployment via `export const config` in `+server.js`, `+page(.server).js`, or `+layout(.server).js`:\n\n```js\nexport const config = {\n\tsplit: true,\n\truntime: 'nodejs20.x',\n\tregions: ['iad1'],\n\tmemory: 1024,\n\tmaxDuration: 15\n};\n```\n\n**Options:**\n- `runtime`: `'edge'`, `'nodejs20.x'`, or `'nodejs22.x'` (deprecated, will use project config)\n- `regions`: array of edge regions or `'all'` for edge functions (default `[\"iad1\"]` for serverless)\n- `split`: deploy route as individual function if `true`\n- `memory`: 128-3008 MB (default 1024)\n- `maxDuration`: max execution time in seconds (default 10/15/900 depending on plan)\n- `external`: array of dependencies to exclude from edge function bundling\n\n## Image Optimization\n\nConfigure image handling in adapter options:\n\n```js\nadapter({\n\timages: {\n\t\tsizes: [640, 828, 1200, 1920, 3840],\n\t\tformats: ['image/avif', 'image/webp'],\n\t\tminimumCacheTTL: 300,\n\t\tdomains: ['example-app.vercel.app']\n\t}\n})\n```\n\n## Incremental Static Regeneration (ISR)\n\nEnable ISR for routes with cached content that regenerates on expiration:\n\n```js\nexport const config = {\n\tisr: {\n\t\texpiration: 60,\n\t\tbypassToken: BYPASS_TOKEN,\n\t\tallowQuery: ['search']\n\t}\n};\n```\n\n- `expiration`: seconds before cache regenerates (required; `false` = never expire)\n- `bypassToken`: token to bypass cache via `__prerender_bypass=\u003Ctoken>` cookie or `x-prerender-revalidate` header (must be 32+ chars)\n- `allowQuery`: query parameters that contribute to cache key; others ignored\n\nGenerate token: `crypto.randomUUID()`. Set as environment variable `BYPASS_TOKEN` in Vercel project settings. Pull locally with `vercel env pull .env.development.local`.\n\n## Environment Variables\n\nAccess Vercel deployment variables via `$env/static/private` or `$env/dynamic/private`:\n\n```js\n// +layout.server.js\nimport { VERCEL_COMMIT_REF } from '$env/static/private';\n\nexport function load() {\n\treturn { deploymentGitBranch: VERCEL_COMMIT_REF };\n}\n```\n\nUse `$env/static/private` for static replacement and dead code elimination.\n\n## Skew Protection\n\nEnable in Vercel project Advanced settings. Routes client requests to their original deployment via cookie with deployment ID. When user reloads, they get newest deployment. `updated.current` always reports new deployments.\n\nCaveat: multiple tabs with different versions will route older tabs to newer deployment, triggering SvelteKit's built-in skew protection.\n\n## Troubleshooting\n\n**File system access:** Can't use `fs` in edge functions. In serverless functions, use `read()` from `$app/server` instead (works in edge functions too by fetching from public assets). Alternatively, prerender routes.\n\n**Deployment Protection:** If using `read()` in edge functions with Deployment Protection enabled, enable \"Protection Bypass for Automation\" to avoid 401 errors.\n\n**Vercel `/api` directory:** Requests to `/api/*` won't be handled by SvelteKit if you have Vercel functions in the `api` directory. Implement as SvelteKit API routes instead, unless using non-JavaScript languages.\n\n**Node version:** Older projects may use outdated Node versions. Update in project settings.","## Setup\n\nInstall `@sveltejs/adapter-vercel` and add to `svelte.config.js`.\n\n## Configuration\n\nSet options via `export const config` in route files:\n- `runtime`: `'edge'` or `'nodejs20.x'`/`'nodejs22.x'`\n- `regions`: array of edge regions\n- `split`: deploy as individual function\n- `memory`: 128-3008 MB\n- `maxDuration`: execution time limit\n- `external`: exclude dependencies from edge bundling\n\n## ISR (Incremental Static Regeneration)\n\n```js\nexport const config = {\n\tisr: {\n\t\texpiration: 60,\n\t\tbypassToken: BYPASS_TOKEN,\n\t\tallowQuery: ['search']\n\t}\n};\n```\n\nBypass cache with `__prerender_bypass=\u003Ctoken>` cookie or `x-prerender-revalidate` header.\n\n## Images\n\nConfigure in adapter options with `sizes`, `formats`, `minimumCacheTTL`, `domains`.\n\n## Environment Variables\n\nAccess via `$env/static/private` (preferred for static replacement).\n\n## Troubleshooting\n\n- Edge functions: can't use `fs`, use `read()` from `$app/server`\n- Serverless: `fs` won't work as expected, use `read()` instead\n- Deployment Protection: enable \"Protection Bypass for Automation\" for edge functions using `read()`","Configure and deploy SvelteKit apps to Vercel with adapter-vercel, supporting serverless/edge functions, ISR, image optimization, and environment variables.","writing-adapters",{"name":463,"path":465,"children":466,"data":467},"build-and-deploy/writing-adapters",["Map"],{"type":22,"path":468,"relevant":44,"token_counts":469,"usage":473,"markdown":476},"25-build-and-deploy/99-writing-adapters.md",{"fulltext":470,"digest":471,"short_digest":472},795,390,140,{"input":474,"output":475,"details":32},1843,652,{"fulltext":477,"digest":478,"short_digest":479,"essence":480},"---\ntitle: Writing adapters\n---\n\nIf an adapter for your preferred environment doesn't yet exist, you can build your own. We recommend [looking at the source for an adapter](https://github.com/sveltejs/kit/tree/main/packages) to a platform similar to yours and copying it as a starting point.\n\nAdapter packages implement the following API, which creates an `Adapter`:\n\n```js\n// @errors: 2322\n// @filename: ambient.d.ts\ntype AdapterSpecificOptions = any;\n\n// @filename: index.js\n// ---cut---\n/** @param {AdapterSpecificOptions} options */\nexport default function (options) {\n\t/** @type {import('@sveltejs/kit').Adapter} */\n\tconst adapter = {\n\t\tname: 'adapter-package-name',\n\t\tasync adapt(builder) {\n\t\t\t// adapter implementation\n\t\t},\n\t\tasync emulate() {\n\t\t\treturn {\n\t\t\t\tasync platform({ config, prerender }) {\n\t\t\t\t\t// the returned object becomes `event.platform` during dev, build and\n\t\t\t\t\t// preview. Its shape is that of `App.Platform`\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tsupports: {\n\t\t\tread: ({ config, route }) => {\n\t\t\t\t// Return `true` if the route with the given `config` can use `read`\n\t\t\t\t// from `$app/server` in production, return `false` if it can't.\n\t\t\t\t// Or throw a descriptive error describing how to configure the deployment\n\t\t\t},\n\t\t\ttracing: () => {\n\t\t\t\t// Return `true` if this adapter supports loading `tracing.server.js`.\n\t\t\t\t// Return `false if it can't, or throw a descriptive error.\n\t\t\t}\n\t\t}\n\t};\n\n\treturn adapter;\n}\n```\n\nOf these, `name` and `adapt` are required. `emulate` and `supports` are optional.\n\nWithin the `adapt` method, there are a number of things that an adapter should do:\n\n- Clear out the build directory\n- Write SvelteKit output with `builder.writeClient`, `builder.writeServer`, and `builder.writePrerendered`\n- Output code that:\n\t- Imports `Server` from `${builder.getServerDirectory()}/index.js`\n\t- Instantiates the app with a manifest generated with `builder.generateManifest({ relativePath })`\n\t- Listens for requests from the platform, converts them to a standard [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) if necessary, calls the `server.respond(request, { getClientAddress })` function to generate a [`Response`](https://developer.mozilla.org/en-US/docs/Web/API/Response) and responds with it\n\t- expose any platform-specific information to SvelteKit via the `platform` option passed to `server.respond`\n\t- Globally shims `fetch` to work on the target platform, if necessary. SvelteKit provides a `@sveltejs/kit/node/polyfills` helper for platforms that can use `undici`\n- Bundle the output to avoid needing to install dependencies on the target platform, if necessary\n- Put the user's static files and the generated JS/CSS in the correct location for the target platform\n\nWhere possible, we recommend putting the adapter output under the `build/` directory with any intermediate output placed under `.svelte-kit/[adapter-name]`.\n","## Adapter API\n\nAdapter packages must export a default function that returns an `Adapter` object with:\n\n**Required properties:**\n- `name`: string identifier for the adapter\n- `adapt(builder)`: async function implementing the adapter\n\n**Optional properties:**\n- `emulate()`: returns platform-specific object that becomes `event.platform` during dev/build/preview\n- `supports`: object with methods to declare feature support:\n  - `read({ config, route })`: returns boolean if route can use `read` from `$app/server` in production\n  - `tracing()`: returns boolean if adapter supports loading `tracing.server.js`\n\n## Adapt Method Requirements\n\nThe `adapt` method must:\n- Clear the build directory\n- Write output using `builder.writeClient()`, `builder.writeServer()`, `builder.writePrerendered()`\n- Generate code that:\n  - Imports `Server` from `${builder.getServerDirectory()}/index.js`\n  - Instantiates app with manifest from `builder.generateManifest({ relativePath })`\n  - Listens for platform requests, converts to standard `Request`, calls `server.respond(request, { getClientAddress })` to get `Response`\n  - Exposes platform info via `platform` option to `server.respond`\n  - Shims `fetch` globally if needed (use `@sveltejs/kit/node/polyfills` for Node-compatible platforms)\n- Bundle output to avoid runtime dependency installation if necessary\n- Place static files and generated JS/CSS in platform-appropriate location\n\nStore adapter output under `build/` with intermediate files under `.svelte-kit/[adapter-name]`.","## Adapter API\n\nExport default function returning `Adapter` with required `name` and `adapt(builder)`, optional `emulate()` and `supports`.\n\n## Adapt Method\n\nMust clear build dir, write output via `builder.writeClient/Server/Prerendered()`, generate code that imports `Server`, instantiates with `builder.generateManifest()`, listens for requests, converts to `Request`, calls `server.respond(request, { getClientAddress })`, exposes platform via `platform` option, shims `fetch` if needed, bundles output, and places files correctly.","Implement the Adapter API by exporting a function that returns an object with name and adapt method, where adapt handles build output, request handling, and platform integration.",{"name":282,"path":482,"children":483,"data":484},"build-and-deploy/build-and-deploy",["Map"],{"type":22,"path":485,"relevant":44,"token_counts":486,"usage":490,"markdown":493},"25-build-and-deploy/index.md",{"fulltext":487,"digest":488,"short_digest":489},16,43,21,{"input":491,"output":492,"details":32},1059,163,{"fulltext":494,"digest":495,"short_digest":496,"essence":497},"---\ntitle: Build and deploy\n---\n","This page serves as an introduction to building and deploying SvelteKit applications. It covers the process of preparing your application for production and deploying it to various hosting platforms.","Overview of building and deploying SvelteKit applications to production.","Introduction to building and deploying SvelteKit applications.",{"type":129,"path":499,"relevant":44,"token_counts":500,"usage":503,"markdown":506},"25-build-and-deploy",{"fulltext":501,"digest":502,"short_digest":315},2281,967,{"input":504,"output":505,"details":32},3469,1530,{"fulltext":507,"digest":508,"short_digest":509,"essence":510},"\n\n## Pages\n\n### building-your-app\nHow to build a SvelteKit app and prevent code from running during the build process.\n\nSvelteKit builds in two stages: Vite optimizes your code, then an adapter tunes it for your target environment. Prevent code execution during build by checking `building` from `$app/environment`. Preview your build with `vite preview`, though it won't perfectly match your deployed app.\n\n### adapters\nAdapters are deployment plugins configured in svelte.config.js that prepare SvelteKit apps for specific platforms.\n\nAdapters transform built SvelteKit apps for deployment. Official adapters exist for Cloudflare, Netlify, Node, static sites, and Vercel. Configure in `svelte.config.js` with `kit.adapter`. Platform-specific context is available via `RequestEvent.platform`.\n\n### zero-config-deployments\nadapter-auto automatically detects and uses the correct deployment adapter for supported hosting platforms, with option to install specific adapters for configuration and performance.\n\n**adapter-auto** automatically selects the correct deployment adapter based on your environment (Cloudflare Pages, Netlify, Vercel, Azure Static Web Apps, AWS SST, or Google Cloud Run).\n\nInstall the specific adapter to devDependencies for environment-specific configuration options and better CI performance. adapter-auto itself takes no options.\n\n### node-servers\nDeploy SvelteKit apps as standalone Node servers using adapter-node with environment variable configuration for proxies, ports, and graceful shutdown.\n\n## Setup\n\nInstall `@sveltejs/adapter-node` and add to `svelte.config.js`. Build with `npm run build`, deploy `build/`, `package.json`, and `node_modules/`. Start with `node build`.\n\n## Environment Variables\n\n- `PORT` (3000), `HOST` (0.0.0.0), `SOCKET_PATH`\n- `ORIGIN` - deployment URL\n- `PROTOCOL_HEADER`, `HOST_HEADER`, `PORT_HEADER` - reverse proxy headers\n- `ADDRESS_HEADER`, `XFF_DEPTH` - client IP detection\n- `BODY_SIZE_LIMIT` (512kb), `SHUTDOWN_TIMEOUT` (30s), `IDLE_TIMEOUT`\n\n## Adapter Options\n\n```js\nadapter({ out: 'build', precompress: true, envPrefix: '' })\n```\n\n## Custom Server\n\nImport `handler.js` for Express/Connect/Polka:\n\n```js\nimport { handler } from './build/handler.js';\nimport express from 'express';\napp.use(handler);\n```\n\n## Graceful Shutdown & systemd\n\nListen to `sveltekit:shutdown` event. Supports systemd socket activation with `LISTEN_PID`/`LISTEN_FDS`.\n\n### static-site-generation\nConfigure SvelteKit to prerender your entire site as static files using adapter-static with options for output directories, SPA fallback, compression, and GitHub Pages deployment.\n\nInstall `@sveltejs/adapter-static` and set `prerender = true` in root layout. Configure adapter options: `pages`, `assets`, `fallback` (for SPA), `precompress`, `strict`. Set `trailingSlash: 'always'` if needed. For GitHub Pages, update `paths.base` to repo name and generate `404.html` fallback.\n\n### single-page-apps\nConfigure SvelteKit as a client-rendered single-page app using adapter-static with a fallback page, with options to prerender individual pages.\n\n## Single-Page App Setup\n\nDisable SSR globally and use `adapter-static` with a fallback page:\n\n```js\n// src/routes/+layout.js\nexport const ssr = false;\n\n// svelte.config.js\nimport adapter from '@sveltejs/adapter-static';\nconst config = {\n\tkit: { adapter: adapter({ fallback: '200.html' }) }\n};\n```\n\nPrerender specific pages by enabling SSR and prerender for those routes:\n\n```js\nexport const prerender = true;\nexport const ssr = true;\n```\n\nFor Apache, add `.htaccess` to route unmatched requests to the fallback page.\n\n**Warning:** SPAs have poor performance, SEO, and accessibility. Prerender as many pages as possible or use static site generation instead.\n\n### cloudflare-deployment\nDeploy SvelteKit apps to Cloudflare Workers or Pages using adapter-cloudflare with configuration options, runtime API access, and local testing setup.\n\n## Installation\n\n```js\nimport adapter from '@sveltejs/adapter-cloudflare';\n\nconst config = {\n\tkit: { adapter: adapter() }\n};\n```\n\n## Key Options\n\n- **fallback**: `'plaintext'` or `'spa'` for 404 handling\n- **routes**: Customize `_routes.json` with `include`/`exclude` (max 100 rules)\n\n## Cloudflare Workers\n\n```jsonc\n{\n\t\"main\": \".svelte-kit/cloudflare/_worker.js\",\n\t\"compatibility_date\": \"2025-01-01\",\n\t\"assets\": {\n\t\t\"binding\": \"ASSETS\",\n\t\t\"directory\": \".svelte-kit/cloudflare\"\n\t}\n}\n```\n\n## Cloudflare Pages\n\nBuild settings: SvelteKit preset, `npm run build`, output `.svelte-kit/cloudflare`. Use server endpoints instead of `/functions` directory.\n\n## Runtime APIs\n\n```js\nexport async function POST({ platform }) {\n\tconst x = platform?.env.YOUR_DURABLE_OBJECT_NAMESPACE.idFromName('x');\n}\n```\n\nInstall `@cloudflare/workers-types` for types.\n\n## Local Testing\n\n`wrangler dev .svelte-kit/cloudflare` (Workers) or `wrangler pages dev .svelte-kit/cloudflare` (Pages)\n\n### cloudflare-workers-deployment\nDeploy SvelteKit to Cloudflare Workers using the deprecated adapter-cloudflare-workers (use adapter-cloudflare instead), configure Wrangler, and access runtime bindings through platform.env.\n\n**Deprecated** in favor of `adapter-cloudflare`. Install `@sveltejs/adapter-cloudflare-workers` and configure Wrangler. Access Cloudflare bindings via `platform.env`. Type with `@cloudflare/workers-types`. Test locally with Wrangler 4+. Reduce worker size by client-side imports; use prerendering instead of `fs`.\n\n### netlify\nDeploy SvelteKit to Netlify using adapter-netlify with options for edge functions and function splitting, with access to Netlify-specific features like context, forms, and custom functions.\n\nInstall `@sveltejs/adapter-netlify` and configure `svelte.config.js` with `edge` and `split` options. Create `netlify.toml` with build command and publish directory. Use `edge: true` for Deno-based edge functions. Access Netlify context via `event.platform?.context`. Use `_redirects` file for redirects (higher priority than `netlify.toml`). For file system access, use `read()` from `$app/server` instead of `fs`.\n\n### vercel-deployment\nConfigure and deploy SvelteKit apps to Vercel with adapter-vercel, supporting serverless/edge functions, ISR, image optimization, and environment variables.\n\n## Setup\n\nInstall `@sveltejs/adapter-vercel` and add to `svelte.config.js`.\n\n## Configuration\n\nSet options via `export const config` in route files:\n- `runtime`: `'edge'` or `'nodejs20.x'`/`'nodejs22.x'`\n- `regions`: array of edge regions\n- `split`: deploy as individual function\n- `memory`: 128-3008 MB\n- `maxDuration`: execution time limit\n- `external`: exclude dependencies from edge bundling\n\n## ISR (Incremental Static Regeneration)\n\n```js\nexport const config = {\n\tisr: {\n\t\texpiration: 60,\n\t\tbypassToken: BYPASS_TOKEN,\n\t\tallowQuery: ['search']\n\t}\n};\n```\n\nBypass cache with `__prerender_bypass=\u003Ctoken>` cookie or `x-prerender-revalidate` header.\n\n## Images\n\nConfigure in adapter options with `sizes`, `formats`, `minimumCacheTTL`, `domains`.\n\n## Environment Variables\n\nAccess via `$env/static/private` (preferred for static replacement).\n\n## Troubleshooting\n\n- Edge functions: can't use `fs`, use `read()` from `$app/server`\n- Serverless: `fs` won't work as expected, use `read()` instead\n- Deployment Protection: enable \"Protection Bypass for Automation\" for edge functions using `read()`\n\n### writing-adapters\nImplement the Adapter API by exporting a function that returns an object with name and adapt method, where adapt handles build output, request handling, and platform integration.\n\n## Adapter API\n\nExport default function returning `Adapter` with required `name` and `adapt(builder)`, optional `emulate()` and `supports`.\n\n## Adapt Method\n\nMust clear build dir, write output via `builder.writeClient/Server/Prerendered()`, generate code that imports `Server`, instantiates with `builder.generateManifest()`, listens for requests, converts to `Request`, calls `server.respond(request, { getClientAddress })`, exposes platform via `platform` option, shims `fetch` if needed, bundles output, and places files correctly.\n\n### build-and-deploy\nIntroduction to building and deploying SvelteKit applications.\n\nOverview of building and deploying SvelteKit applications to production.\n\n","## Building\n\nSvelteKit builds in two stages: Vite optimizes code, then an adapter tunes it for the target environment. Prevent code execution during build by checking `building` from `$app/environment`. Preview builds with `vite preview`.\n\n## Adapters\n\nAdapters are deployment plugins configured in `svelte.config.js` that transform built apps for specific platforms. Official adapters exist for Cloudflare, Netlify, Node, static sites, and Vercel. Access platform-specific context via `RequestEvent.platform`.\n\n## Deployment Options\n\n**adapter-auto** automatically detects and uses the correct adapter (Cloudflare Pages, Netlify, Vercel, Azure Static Web Apps, AWS SST, Google Cloud Run). Install the specific adapter to devDependencies for environment-specific configuration.\n\n**Node servers** (`adapter-node`): Build with `npm run build`, deploy `build/`, `package.json`, `node_modules/`. Start with `node build`. Configure via environment variables: `PORT` (3000), `HOST` (0.0.0.0), `ORIGIN`, reverse proxy headers (`PROTOCOL_HEADER`, `HOST_HEADER`, `PORT_HEADER`), client IP detection (`ADDRESS_HEADER`, `XFF_DEPTH`), `BODY_SIZE_LIMIT` (512kb), `SHUTDOWN_TIMEOUT` (30s). Supports graceful shutdown via `sveltekit:shutdown` event and systemd socket activation.\n\n**Static sites** (`adapter-static`): Set `prerender = true` in root layout. Configure `pages`, `assets`, `fallback` (for SPA), `precompress`, `strict`. For GitHub Pages, set `paths.base` to repo name and generate `404.html` fallback.\n\n**Single-page apps** (`adapter-static`): Disable SSR globally with `export const ssr = false` in root layout, use fallback page. Prerender specific pages by enabling SSR and `export const prerender = true` for those routes. Add `.htaccess` for Apache routing. Warning: SPAs have poor performance, SEO, and accessibility.\n\n**Cloudflare** (`adapter-cloudflare`): Configure fallback (`'plaintext'` or `'spa'`), customize `_routes.json` with `include`/`exclude` (max 100 rules). Access runtime APIs via `platform?.env`. Test locally with `wrangler dev .svelte-kit/cloudflare` (Workers) or `wrangler pages dev .svelte-kit/cloudflare` (Pages).\n\n**Netlify** (`adapter-netlify`): Use `edge: true` for Deno-based edge functions, `split: true` for function splitting. Access Netlify context via `event.platform?.context`. Use `_redirects` file for redirects. Use `read()` from `$app/server` instead of `fs` for file access.\n\n**Vercel** (`adapter-vercel`): Set options via `export const config` in route files: `runtime` (`'edge'` or `'nodejs20.x'`/`'nodejs22.x'`), `regions`, `split`, `memory` (128-3008 MB), `maxDuration`. ISR configuration: `expiration`, `bypassToken`, `allowQuery`. Bypass cache with `__prerender_bypass=\u003Ctoken>` cookie or `x-prerender-revalidate` header. Configure image optimization with `sizes`, `formats`, `minimumCacheTTL`, `domains`. Use `read()` from `$app/server` instead of `fs`.\n\n## Custom Adapters\n\nImplement the Adapter API by exporting a function returning an object with `name` and `adapt(builder)` methods. The `adapt` method must clear the build directory, write output via `builder.writeClient/Server/Prerendered()`, generate code that imports `Server`, instantiate with `builder.generateManifest()`, listen for requests, convert to `Request`, call `server.respond(request, { getClientAddress })`, expose platform via `platform` option, shim `fetch` if needed, bundle output, and place files correctly.","## Building & Adapters\n\nSvelteKit builds in two stages: Vite optimizes code, then an adapter tunes it for the target environment. Prevent build-time execution with `building` from `$app/environment`.\n\nAdapters are deployment plugins configured in `svelte.config.js`. **adapter-auto** automatically detects the correct adapter. Official adapters: Node, static sites, Cloudflare, Netlify, Vercel.\n\n## Key Deployment Patterns\n\n**Node**: `npm run build`, deploy `build/`, `package.json`, `node_modules/`. Start with `node build`. Configure via `PORT`, `HOST`, `ORIGIN`, reverse proxy headers, `BODY_SIZE_LIMIT` (512kb), `SHUTDOWN_TIMEOUT` (30s).\n\n**Static**: Set `prerender = true` in root layout. Configure `pages`, `assets`, `fallback`, `precompress`.\n\n**SPA**: Disable SSR globally with `export const ssr = false`, use fallback page. Prerender specific pages with `export const prerender = true`.\n\n**Cloudflare**: Configure fallback, `_routes.json` rules (max 100). Access runtime APIs via `platform?.env`. Test with `wrangler dev .svelte-kit/cloudflare`.\n\n**Netlify**: Use `edge: true` for edge functions, `split: true` for function splitting. Access context via `event.platform?.context`. Use `read()` from `$app/server` instead of `fs`.\n\n**Vercel**: Set `runtime` (`'edge'` or `'nodejs20.x'`), `regions`, `split`, `memory`, `maxDuration` via `export const config`. ISR: `expiration`, `bypassToken`, `allowQuery`. Bypass cache with `__prerender_bypass=\u003Ctoken>` cookie.","Build and deploy SvelteKit apps using adapters for various platforms (Node, static, Cloudflare, Netlify, Vercel) with platform-specific configuration and runtime APIs.","advanced-techniques",{"name":511,"path":511,"children":513,"data":710},["Map",514,515,532,533,550,551,568,569,586,587,604,605,621,622,639,640,657,658,675,676,693,694],"advanced-routing",{"name":514,"path":516,"children":517,"data":518},"advanced-techniques/advanced-routing",["Map"],{"type":22,"path":519,"relevant":44,"token_counts":520,"usage":524,"markdown":527},"30-advanced/10-advanced-routing.md",{"fulltext":521,"digest":522,"short_digest":523},3636,609,282,{"input":525,"output":526,"details":32},4679,1002,{"fulltext":528,"digest":529,"short_digest":530,"essence":531},"---\ntitle: Advanced routing\n---\n\n## Rest parameters\n\nIf the number of route segments is unknown, you can use rest syntax — for example you might implement GitHub's file viewer like so...\n\n```sh\n/[org]/[repo]/tree/[branch]/[...file]\n```\n\n...in which case a request for `/sveltejs/kit/tree/main/documentation/docs/04-advanced-routing.md` would result in the following parameters being available to the page:\n\n```js\n// @noErrors\n{\n\torg: 'sveltejs',\n\trepo: 'kit',\n\tbranch: 'main',\n\tfile: 'documentation/docs/04-advanced-routing.md'\n}\n```\n\n> [!NOTE] `src/routes/a/[...rest]/z/+page.svelte` will match `/a/z` (i.e. there's no parameter at all) as well as `/a/b/z` and `/a/b/c/z` and so on. Make sure you check that the value of the rest parameter is valid, for example using a [matcher](#Matching).\n\n### 404 pages\n\nRest parameters also allow you to render custom 404s. Given these routes...\n\n```tree\nsrc/routes/\n├ marx-brothers/\n│ ├ chico/\n│ ├ harpo/\n│ ├ groucho/\n│ └ +error.svelte\n└ +error.svelte\n```\n\n...the `marx-brothers/+error.svelte` file will _not_ be rendered if you visit `/marx-brothers/karl`, because no route was matched. If you want to render the nested error page, you should create a route that matches any `/marx-brothers/*` request, and return a 404 from it:\n\n```tree\nsrc/routes/\n├ marx-brothers/\n+++| ├ [...path]/+++\n│ ├ chico/\n│ ├ harpo/\n│ ├ groucho/\n│ └ +error.svelte\n└ +error.svelte\n```\n\n```js\n/// file: src/routes/marx-brothers/[...path]/+page.js\nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').PageLoad} */\nexport function load(event) {\n\terror(404, 'Not Found');\n}\n```\n\n> [!NOTE] If you don't handle 404 cases, they will appear in [`handleError`](hooks#Shared-hooks-handleError)\n\n## Optional parameters\n\nA route like `[lang]/home` contains a parameter named `lang` which is required. Sometimes it's beneficial to make these parameters optional, so that in this example both `home` and `en/home` point to the same page. You can do that by wrapping the parameter in another bracket pair: `[[lang]]/home`\n\nNote that an optional route parameter cannot follow a rest parameter (`[...rest]/[[optional]]`), since parameters are matched 'greedily' and the optional parameter would always be unused.\n\n## Matching\n\nA route like `src/routes/fruits/[page]` would match `/fruits/apple`, but it would also match `/fruits/rocketship`. We don't want that. You can ensure that route parameters are well-formed by adding a _matcher_ — which takes the parameter string (`\"apple\"` or `\"rocketship\"`) and returns `true` if it is valid — to your [`params`](configuration#files) directory...\n\n```js\n/// file: src/params/fruit.js\n/**\n * @param {string} param\n * @return {param is ('apple' | 'orange')}\n * @satisfies {import('@sveltejs/kit').ParamMatcher}\n */\nexport function match(param) {\n\treturn param === 'apple' || param === 'orange';\n}\n```\n\n...and augmenting your routes:\n\n```\nsrc/routes/fruits/[page+++=fruit+++]\n```\n\nIf the pathname doesn't match, SvelteKit will try to match other routes (using the sort order specified below), before eventually returning a 404.\n\nEach module in the `params` directory corresponds to a matcher, with the exception of `*.test.js` and `*.spec.js` files which may be used to unit test your matchers.\n\n> [!NOTE] Matchers run both on the server and in the browser.\n\n## Sorting\n\nIt's possible for multiple routes to match a given path. For example each of these routes would match `/foo-abc`:\n\n```sh\nsrc/routes/[...catchall]/+page.svelte\nsrc/routes/[[a=x]]/+page.svelte\nsrc/routes/[b]/+page.svelte\nsrc/routes/foo-[c]/+page.svelte\nsrc/routes/foo-abc/+page.svelte\n```\n\nSvelteKit needs to know which route is being requested. To do so, it sorts them according to the following rules...\n\n- More specific routes are higher priority (e.g. a route with no parameters is more specific than a route with one dynamic parameter, and so on)\n- Parameters with [matchers](#Matching) (`[name=type]`) are higher priority than those without (`[name]`)\n- `[[optional]]` and `[...rest]` parameters are ignored unless they are the final part of the route, in which case they are treated with lowest priority. In other words `x/[[y]]/z` is treated equivalently to `x/z` for the purposes of sorting\n- Ties are resolved alphabetically\n\n...resulting in this ordering, meaning that `/foo-abc` will invoke `src/routes/foo-abc/+page.svelte`, and `/foo-def` will invoke `src/routes/foo-[c]/+page.svelte` rather than less specific routes:\n\n```sh\nsrc/routes/foo-abc/+page.svelte\nsrc/routes/foo-[c]/+page.svelte\nsrc/routes/[[a=x]]/+page.svelte\nsrc/routes/[b]/+page.svelte\nsrc/routes/[...catchall]/+page.svelte\n```\n\n## Encoding\n\nSome characters can't be used on the filesystem — `/` on Linux and Mac, `\\ / : * ? \" \u003C > |` on Windows. The `#` and `%` characters have special meaning in URLs, and the `[ ] ( )` characters have special meaning to SvelteKit, so these also can't be used directly as part of your route.\n\nTo use these characters in your routes, you can use hexadecimal escape sequences, which have the format `[x+nn]` where `nn` is a hexadecimal character code:\n\n- `\\` — `[x+5c]`\n- `/` — `[x+2f]`\n- `:` — `[x+3a]`\n- `*` — `[x+2a]`\n- `?` — `[x+3f]`\n- `\"` — `[x+22]`\n- `\u003C` — `[x+3c]`\n- `>` — `[x+3e]`\n- `|` — `[x+7c]`\n- `#` — `[x+23]`\n- `%` — `[x+25]`\n- `[` — `[x+5b]`\n- `]` — `[x+5d]`\n- `(` — `[x+28]`\n- `)` — `[x+29]`\n\nFor example, to create a `/smileys/:-)` route, you would create a `src/routes/smileys/[x+3a]-[x+29]/+page.svelte` file.\n\nYou can determine the hexadecimal code for a character with JavaScript:\n\n```js\n':'.charCodeAt(0).toString(16); // '3a', hence '[x+3a]'\n```\n\nYou can also use Unicode escape sequences. Generally you won't need to as you can use the unencoded character directly, but if — for some reason — you can't have a filename with an emoji in it, for example, then you can use the escaped characters. In other words, these are equivalent:\n\n```\nsrc/routes/[u+d83e][u+dd2a]/+page.svelte\nsrc/routes/🤪/+page.svelte\n```\n\nThe format for a Unicode escape sequence is `[u+nnnn]` where `nnnn` is a valid value between `0000` and `10ffff`. (Unlike JavaScript string escaping, there's no need to use surrogate pairs to represent code points above `ffff`.) To learn more about Unicode encodings, consult [Programming with Unicode](https://unicodebook.readthedocs.io/unicode_encodings.html).\n\n> [!NOTE] Since TypeScript [struggles](https://github.com/microsoft/TypeScript/issues/13399) with directories with a leading `.` character, you may find it useful to encode these characters when creating e.g. [`.well-known`](https://en.wikipedia.org/wiki/Well-known_URI) routes: `src/routes/[x+2e]well-known/...`\n\n## Advanced layouts\n\nBy default, the _layout hierarchy_ mirrors the _route hierarchy_. In some cases, that might not be what you want.\n\n### (group)\n\nPerhaps you have some routes that are 'app' routes that should have one layout (e.g. `/dashboard` or `/item`), and others that are 'marketing' routes that should have a different layout (`/about` or `/testimonials`). We can group these routes with a directory whose name is wrapped in parentheses — unlike normal directories, `(app)` and `(marketing)` do not affect the URL pathname of the routes inside them:\n\n```tree\nsrc/routes/\n+++│ (app)/+++\n│ ├ dashboard/\n│ ├ item/\n│ └ +layout.svelte\n+++│ (marketing)/+++\n│ ├ about/\n│ ├ testimonials/\n│ └ +layout.svelte\n├ admin/\n└ +layout.svelte\n```\n\nYou can also put a `+page` directly inside a `(group)`, for example if `/` should be an `(app)` or a `(marketing)` page.\n\n### Breaking out of layouts\n\nThe root layout applies to every page of your app — if omitted, it defaults to `{@render children()}`. If you want some pages to have a different layout hierarchy than the rest, then you can put your entire app inside one or more groups _except_ the routes that should not inherit the common layouts.\n\nIn the example above, the `/admin` route does not inherit either the `(app)` or `(marketing)` layouts.\n\n### +page@\n\nPages can break out of the current layout hierarchy on a route-by-route basis. Suppose we have an `/item/[id]/embed` route inside the `(app)` group from the previous example:\n\n```tree\nsrc/routes/\n├ (app)/\n│ ├ item/\n│ │ ├ [id]/\n│ │ │ ├ embed/\n+++│ │ │ │ └ +page.svelte+++\n│ │ │ └ +layout.svelte\n│ │ └ +layout.svelte\n│ └ +layout.svelte\n└ +layout.svelte\n```\n\nOrdinarily, this would inherit the root layout, the `(app)` layout, the `item` layout and the `[id]` layout. We can reset to one of those layouts by appending `@` followed by the segment name — or, for the root layout, the empty string. In this example, we can choose from the following options:\n\n- `+page@[id].svelte` - inherits from `src/routes/(app)/item/[id]/+layout.svelte`\n- `+page@item.svelte` - inherits from `src/routes/(app)/item/+layout.svelte`\n- `+page@(app).svelte` - inherits from `src/routes/(app)/+layout.svelte`\n- `+page@.svelte` - inherits from `src/routes/+layout.svelte`\n\n```tree\nsrc/routes/\n├ (app)/\n│ ├ item/\n│ │ ├ [id]/\n│ │ │ ├ embed/\n+++│ │ │ │ └ +page@(app).svelte+++\n│ │ │ └ +layout.svelte\n│ │ └ +layout.svelte\n│ └ +layout.svelte\n└ +layout.svelte\n```\n\n### +layout@\n\nLike pages, layouts can _themselves_ break out of their parent layout hierarchy, using the same technique. For example, a `+layout@.svelte` component would reset the hierarchy for all its child routes.\n\n```\nsrc/routes/\n├ (app)/\n│ ├ item/\n│ │ ├ [id]/\n│ │ │ ├ embed/\n│ │ │ │ └ +page.svelte  // uses (app)/item/[id]/+layout.svelte\n│ │ │ ├ +layout.svelte  // inherits from (app)/item/+layout@.svelte\n│ │ │ └ +page.svelte    // uses (app)/item/+layout@.svelte\n│ │ └ +layout@.svelte   // inherits from root layout, skipping (app)/+layout.svelte\n│ └ +layout.svelte\n└ +layout.svelte\n```\n\n### When to use layout groups\n\nNot all use cases are suited for layout grouping, nor should you feel compelled to use them. It might be that your use case would result in complex `(group)` nesting, or that you don't want to introduce a `(group)` for a single outlier. It's perfectly fine to use other means such as composition (reusable `load` functions or Svelte components) or if-statements to achieve what you want. The following example shows a layout that rewinds to the root layout and reuses components and functions that other layouts can also use:\n\n```svelte\n\u003C!--- file: src/routes/nested/route/+layout@.svelte --->\n\u003Cscript>\n\timport ReusableLayout from '$lib/ReusableLayout.svelte';\n\tlet { data, children } = $props();\n\u003C/script>\n\n\u003CReusableLayout {data}>\n\t{@render children()}\n\u003C/ReusableLayout>\n```\n\n```js\n/// file: src/routes/nested/route/+layout.js\n// @filename: ambient.d.ts\ndeclare module \"$lib/reusable-load-function\" {\n\texport function reusableLoad(event: import('@sveltejs/kit').LoadEvent): Promise\u003CRecord\u003Cstring, any>>;\n}\n// @filename: index.js\n// ---cut---\nimport { reusableLoad } from '$lib/reusable-load-function';\n\n/** @type {import('./$types').PageLoad} */\nexport function load(event) {\n\t// Add additional logic here, if needed\n\treturn reusableLoad(event);\n}\n```\n\n## Further reading\n\n- [Tutorial: Advanced Routing](/tutorial/kit/optional-params)\n","## Rest Parameters\nUse `[...file]` syntax to match variable number of segments. Example: `/[org]/[repo]/tree/[branch]/[...file]` matches `/sveltejs/kit/tree/main/documentation/docs/04-advanced-routing.md` with `file: 'documentation/docs/04-advanced-routing.md'`. Rest parameters match zero or more segments, so `[...rest]` matches both `/a/z` and `/a/b/c/z`.\n\n## 404 Pages\nCreate a catch-all route with rest parameters to render custom 404s. Create `src/routes/marx-brothers/[...path]/+page.js` that calls `error(404, 'Not Found')` to handle unmatched paths within a directory.\n\n## Optional Parameters\nWrap parameters in double brackets to make them optional: `[[lang]]/home` matches both `home` and `en/home`. Optional parameters cannot follow rest parameters.\n\n## Matching\nUse matchers to validate route parameters. Create `src/params/fruit.js` with a `match(param)` function returning boolean, then use `[page=fruit]` in routes. Matchers run on both server and browser.\n\n## Sorting\nWhen multiple routes match a path, SvelteKit prioritizes by: (1) specificity (no parameters > dynamic parameters), (2) matchers (`[name=type]` > `[name]`), (3) optional/rest parameters lowest priority unless final, (4) alphabetical ties. Example: `/foo-abc` matches `foo-abc/+page.svelte` before `foo-[c]/+page.svelte`.\n\n## Encoding\nUse hexadecimal escape sequences `[x+nn]` for special characters: `[x+3a]` for `:`, `[x+2f]` for `/`, `[x+23]` for `#`, etc. Use Unicode sequences `[u+nnnn]` for emoji: `[u+d83e][u+dd2a]` or just `🤪`. Example: `/smileys/:-)` becomes `src/routes/smileys/[x+3a]-[x+29]/+page.svelte`.\n\n## Layout Groups\nUse `(group)` directories to organize routes without affecting URLs. Routes in `(app)` and `(marketing)` groups have separate layouts. Break out of layout hierarchy with `+page@segment` or `+layout@segment` syntax. `+page@.svelte` inherits only root layout, `+page@(app).svelte` inherits from `(app)` layout.","## Rest Parameters\n`[...file]` matches variable segments: `/[org]/[repo]/tree/[branch]/[...file]` with `/sveltejs/kit/tree/main/docs/file.md` gives `file: 'docs/file.md'`.\n\n## Optional Parameters\n`[[lang]]/home` matches both `home` and `en/home`.\n\n## Matching\nCreate `src/params/fruit.js` with `match(param)` function, use `[page=fruit]` in routes.\n\n## Sorting\nSpecificity > matchers > optional/rest > alphabetical. `/foo-abc` matches `foo-abc/+page.svelte` before `foo-[c]/+page.svelte`.\n\n## Encoding\n`[x+3a]` for `:`, `[x+2f]` for `/`. `/smileys/:-)` becomes `src/routes/smileys/[x+3a]-[x+29]/+page.svelte`.\n\n## Layout Groups\n`(app)` and `(marketing)` organize routes without URL changes. Use `+page@(app).svelte` to inherit from `(app)` layout only.","Advanced routing techniques including rest parameters, optional parameters, matchers, route sorting, character encoding, and layout grouping.","hooks",{"name":532,"path":534,"children":535,"data":536},"advanced-techniques/hooks",["Map"],{"type":22,"path":537,"relevant":44,"token_counts":538,"usage":542,"markdown":545},"30-advanced/20-hooks.md",{"fulltext":539,"digest":540,"short_digest":541},4502,803,196,{"input":543,"output":544,"details":32},5543,1114,{"fulltext":546,"digest":547,"short_digest":548,"essence":549},"---\ntitle: Hooks\n---\n\n'Hooks' are app-wide functions you declare that SvelteKit will call in response to specific events, giving you fine-grained control over the framework's behaviour.\n\nThere are three hooks files, all optional:\n\n- `src/hooks.server.js` — your app's server hooks\n- `src/hooks.client.js` — your app's client hooks\n- `src/hooks.js` — your app's hooks that run on both the client and server\n\nCode in these modules will run when the application starts up, making them useful for initializing database clients and so on.\n\n> [!NOTE] You can configure the location of these files with [`config.kit.files.hooks`](configuration#files).\n\n## Server hooks\n\nThe following hooks can be added to `src/hooks.server.js`:\n\n### handle\n\nThis function runs every time the SvelteKit server receives a [request](web-standards#Fetch-APIs-Request) — whether that happens while the app is running, or during [prerendering](page-options#prerender) — and determines the [response](web-standards#Fetch-APIs-Response). It receives an `event` object representing the request and a function called `resolve`, which renders the route and generates a `Response`. This allows you to modify response headers or bodies, or bypass SvelteKit entirely (for implementing routes programmatically, for example).\n\n```js\n/// file: src/hooks.server.js\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tif (event.url.pathname.startsWith('/custom')) {\n\t\treturn new Response('custom response');\n\t}\n\n\tconst response = await resolve(event);\n\treturn response;\n}\n```\n\n> [!NOTE] Requests for static assets — which includes pages that were already prerendered — are _not_ handled by SvelteKit.\n\nIf unimplemented, defaults to `({ event, resolve }) => resolve(event)`.\n\nDuring prerendering, SvelteKit crawls your pages for links and renders each route it finds. Rendering the route invokes the `handle` function (and all other route dependencies, like `load`). If you need to exclude some code from running during this phase, check that the app is not [`building`]($app-environment#building) beforehand.\n\n### locals\n\nTo add custom data to the request, which is passed to handlers in `+server.js` and server `load` functions, populate the `event.locals` object, as shown below.\n\n```js\n/// file: src/hooks.server.js\n// @filename: ambient.d.ts\ntype User = {\n\tname: string;\n}\n\ndeclare namespace App {\n\tinterface Locals {\n\t\tuser: User;\n\t}\n}\n\nconst getUserInformation: (cookie: string | void) => Promise\u003CUser>;\n\n// @filename: index.js\n// ---cut---\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tevent.locals.user = await getUserInformation(event.cookies.get('sessionid'));\n\n\tconst response = await resolve(event);\n\n\t// Note that modifying response headers isn't always safe.\n\t// Response objects can have immutable headers\n\t// (e.g. Response.redirect() returned from an endpoint).\n\t// Modifying immutable headers throws a TypeError.\n\t// In that case, clone the response or avoid creating a\n\t// response object with immutable headers.\n\tresponse.headers.set('x-custom-header', 'potato');\n\n\treturn response;\n}\n```\n\nYou can define multiple `handle` functions and execute them with [the `sequence` helper function](@sveltejs-kit-hooks).\n\n`resolve` also supports a second, optional parameter that gives you more control over how the response will be rendered. That parameter is an object that can have the following fields:\n\n- `transformPageChunk(opts: { html: string, done: boolean }): MaybePromise\u003Cstring | undefined>` — applies custom transforms to HTML. If `done` is true, it's the final chunk. Chunks are not guaranteed to be well-formed HTML (they could include an element's opening tag but not its closing tag, for example) but they will always be split at sensible boundaries such as `%sveltekit.head%` or layout/page components.\n- `filterSerializedResponseHeaders(name: string, value: string): boolean` — determines which headers should be included in serialized responses when a `load` function loads a resource with `fetch`. By default, none will be included.\n- `preload(input: { type: 'js' | 'css' | 'font' | 'asset', path: string }): boolean` — determines what files should be added to the `\u003Chead>` tag to preload it. The method is called with each file that was found at build time while constructing the code chunks — so if you for example have `import './styles.css` in your `+page.svelte`, `preload` will be called with the resolved path to that CSS file when visiting that page. Note that in dev mode `preload` is _not_ called, since it depends on analysis that happens at build time. Preloading can improve performance by downloading assets sooner, but it can also hurt if too much is downloaded unnecessarily. By default, `js` and `css` files will be preloaded. `asset` files are not preloaded at all currently, but we may add this later after evaluating feedback.\n\n```js\n/// file: src/hooks.server.js\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tconst response = await resolve(event, {\n\t\ttransformPageChunk: ({ html }) => html.replace('old', 'new'),\n\t\tfilterSerializedResponseHeaders: (name) => name.startsWith('x-'),\n\t\tpreload: ({ type, path }) => type === 'js' || path.includes('/important/')\n\t});\n\n\treturn response;\n}\n```\n\nNote that `resolve(...)` will never throw an error, it will always return a `Promise\u003CResponse>` with the appropriate status code. If an error is thrown elsewhere during `handle`, it is treated as fatal, and SvelteKit will respond with a JSON representation of the error or a fallback error page — which can be customised via `src/error.html` — depending on the `Accept` header. You can read more about error handling [here](errors).\n\n### handleFetch\n\nThis function allows you to modify (or replace) the result of an [`event.fetch`](load#Making-fetch-requests) call that runs on the server (or during prerendering) inside an endpoint, `load`, `action`, `handle`, `handleError` or `reroute`.\n\nFor example, your `load` function might make a request to a public URL like `https://api.yourapp.com` when the user performs a client-side navigation to the respective page, but during SSR it might make sense to hit the API directly (bypassing whatever proxies and load balancers sit between it and the public internet).\n\n```js\n/// file: src/hooks.server.js\n/** @type {import('@sveltejs/kit').HandleFetch} */\nexport async function handleFetch({ request, fetch }) {\n\tif (request.url.startsWith('https://api.yourapp.com/')) {\n\t\t// clone the original request, but change the URL\n\t\trequest = new Request(\n\t\t\trequest.url.replace('https://api.yourapp.com/', 'http://localhost:9999/'),\n\t\t\trequest\n\t\t);\n\t}\n\n\treturn fetch(request);\n}\n```\n\nRequests made with `event.fetch` follow the browser's credentials model — for same-origin requests, `cookie` and `authorization` headers are forwarded unless the `credentials` option is set to `\"omit\"`. For cross-origin requests, `cookie` will be included if the request URL belongs to a subdomain of the app — for example if your app is on `my-domain.com`, and your API is on `api.my-domain.com`, cookies will be included in the request.\n\nThere is one caveat: if your app and your API are on sibling subdomains — `www.my-domain.com` and `api.my-domain.com` for example — then a cookie belonging to a common parent domain like `my-domain.com` will _not_ be included, because SvelteKit has no way to know which domain the cookie belongs to. In these cases you will need to manually include the cookie using `handleFetch`:\n\n```js\n/// file: src/hooks.server.js\n// @errors: 2345\n/** @type {import('@sveltejs/kit').HandleFetch} */\nexport async function handleFetch({ event, request, fetch }) {\n\tif (request.url.startsWith('https://api.my-domain.com/')) {\n\t\trequest.headers.set('cookie', event.request.headers.get('cookie'));\n\t}\n\n\treturn fetch(request);\n}\n```\n\n### handleValidationError\n\nThis hook is called when a remote function is called with an argument that does not match the provided [Standard Schema](https://standardschema.dev/). It must return an object matching the shape of [`App.Error`](types#Error).\n\nSay you have a remote function that expects a string as its argument ...\n\n```js\n/// file: todos.remote.js\nimport * as v from 'valibot';\nimport { query } from '$app/server';\n\nexport const getTodo = query(v.string(), (id) => {\n\t// implementation...\n});\n```\n\n...but it is called with something that doesn't match the schema — such as a number (e.g `await getTodos(1)`) — then validation will fail, the server will respond with a [400 status code](https://http.dog/400), and the function will throw with the message 'Bad Request'.\n\nTo customise this message and add additional properties to the error object, implement `handleValidationError`:\n\n```js\n/// file: src/hooks.server.js\n/** @type {import('@sveltejs/kit').HandleValidationError} */\nexport function handleValidationError({ issues }) {\n\treturn {\n\t\tmessage: 'No thank you'\n\t};\n}\n```\n\nBe thoughtful about what information you expose here, as the most likely reason for validation to fail is that someone is sending malicious requests to your server.\n\n## Shared hooks\n\nThe following can be added to `src/hooks.server.js` _and_ `src/hooks.client.js`:\n\n### handleError\n\nIf an [unexpected error](errors#Unexpected-errors) is thrown during loading, rendering, or from an endpoint, this function will be called with the `error`, `event`, `status` code and `message`. This allows for two things:\n\n- you can log the error\n- you can generate a custom representation of the error that is safe to show to users, omitting sensitive details like messages and stack traces. The returned value, which defaults to `{ message }`, becomes the value of `$page.error`.\n\nFor errors thrown from your code (or library code called by your code) the status will be 500 and the message will be \"Internal Error\". While `error.message` may contain sensitive information that should not be exposed to users, `message` is safe (albeit meaningless to the average user).\n\nTo add more information to the `$page.error` object in a type-safe way, you can customize the expected shape by declaring an `App.Error` interface (which must include `message: string`, to guarantee sensible fallback behavior). This allows you to — for example — append a tracking ID for users to quote in correspondence with your technical support staff:\n\n```ts\n/// file: src/app.d.ts\ndeclare global {\n\tnamespace App {\n\t\tinterface Error {\n\t\t\tmessage: string;\n\t\t\terrorId: string;\n\t\t}\n\t}\n}\n\nexport {};\n```\n\n```js\n/// file: src/hooks.server.js\n// @errors: 2322 2353\n// @filename: ambient.d.ts\ndeclare module '@sentry/sveltekit' {\n\texport const init: (opts: any) => void;\n\texport const captureException: (error: any, opts: any) => void;\n}\n\n// @filename: index.js\n// ---cut---\nimport * as Sentry from '@sentry/sveltekit';\n\nSentry.init({/*...*/})\n\n/** @type {import('@sveltejs/kit').HandleServerError} */\nexport async function handleError({ error, event, status, message }) {\n\tconst errorId = crypto.randomUUID();\n\n\t// example integration with https://sentry.io/\n\tSentry.captureException(error, {\n\t\textra: { event, errorId, status }\n\t});\n\n\treturn {\n\t\tmessage: 'Whoops!',\n\t\terrorId\n\t};\n}\n```\n\n```js\n/// file: src/hooks.client.js\n// @errors: 2322 2353\n// @filename: ambient.d.ts\ndeclare module '@sentry/sveltekit' {\n\texport const init: (opts: any) => void;\n\texport const captureException: (error: any, opts: any) => void;\n}\n\n// @filename: index.js\n// ---cut---\nimport * as Sentry from '@sentry/sveltekit';\n\nSentry.init({/*...*/})\n\n/** @type {import('@sveltejs/kit').HandleClientError} */\nexport async function handleError({ error, event, status, message }) {\n\tconst errorId = crypto.randomUUID();\n\n\t// example integration with https://sentry.io/\n\tSentry.captureException(error, {\n\t\textra: { event, errorId, status }\n\t});\n\n\treturn {\n\t\tmessage: 'Whoops!',\n\t\terrorId\n\t};\n}\n```\n\n> [!NOTE] In `src/hooks.client.js`, the type of `handleError` is `HandleClientError` instead of `HandleServerError`, and `event` is a `NavigationEvent` rather than a `RequestEvent`.\n\nThis function is not called for _expected_ errors (those thrown with the [`error`](@sveltejs-kit#error) function imported from `@sveltejs/kit`).\n\nDuring development, if an error occurs because of a syntax error in your Svelte code, the passed in error has a `frame` property appended highlighting the location of the error.\n\n> [!NOTE] Make sure that `handleError` _never_ throws an error\n\n### init\n\nThis function runs once, when the server is created or the app starts in the browser, and is a useful place to do asynchronous work such as initializing a database connection.\n\n> [!NOTE] If your environment supports top-level await, the `init` function is really no different from writing your initialisation logic at the top level of the module, but some environments — most notably, Safari — don't.\n\n```js\n// @errors: 2307\n/// file: src/hooks.server.js\nimport * as db from '$lib/server/database';\n\n/** @type {import('@sveltejs/kit').ServerInit} */\nexport async function init() {\n\tawait db.connect();\n}\n```\n\n> [!NOTE]\n> In the browser, asynchronous work in `init` will delay hydration, so be mindful of what you put in there.\n\n## Universal hooks\n\nThe following can be added to `src/hooks.js`. Universal hooks run on both server and client (not to be confused with shared hooks, which are environment-specific).\n\n### reroute\n\nThis function runs before `handle` and allows you to change how URLs are translated into routes. The returned pathname (which defaults to `url.pathname`) is used to select the route and its parameters.\n\nFor example, you might have a `src/routes/[[lang]]/about/+page.svelte` page, which should be accessible as `/en/about` or `/de/ueber-uns` or `/fr/a-propos`. You could implement this with `reroute`:\n\n```js\n// @errors: 2345 2304\n/// file: src/hooks.js\n\n/** @type {Record\u003Cstring, string>} */\nconst translated = {\n\t'/en/about': '/en/about',\n\t'/de/ueber-uns': '/de/about',\n\t'/fr/a-propos': '/fr/about',\n};\n\n/** @type {import('@sveltejs/kit').Reroute} */\nexport function reroute({ url }) {\n\tif (url.pathname in translated) {\n\t\treturn translated[url.pathname];\n\t}\n}\n```\n\nThe `lang` parameter will be correctly derived from the returned pathname.\n\nUsing `reroute` will _not_ change the contents of the browser's address bar, or the value of `event.url`.\n\nSince version 2.18, the `reroute` hook can be asynchronous, allowing it to (for example) fetch data from your backend to decide where to reroute to. Use this carefully and make sure it's fast, as it will delay navigation otherwise. If you need to fetch data, use the `fetch` provided as an argument. It has the [same benefits](load#Making-fetch-requests) as the `fetch` provided to `load` functions, with the caveat that `params` and `id` are unavailable to [`handleFetch`](#Server-hooks-handleFetch) because the route is not yet known.\n\n```js\n// @errors: 2345 2304\n/// file: src/hooks.js\n\n/** @type {import('@sveltejs/kit').Reroute} */\nexport async function reroute({ url, fetch }) {\n\t// Ask a special endpoint within your app about the destination\n\tif (url.pathname === '/api/reroute') return;\n\n\tconst api = new URL('/api/reroute', url);\n\tapi.searchParams.set('pathname', url.pathname);\n\n\tconst result = await fetch(api).then(r => r.json());\n\treturn result.pathname;\n}\n```\n\n\n> [!NOTE] `reroute` is considered a pure, idempotent function. As such, it must always return the same output for the same input and not have side effects. Under these assumptions, SvelteKit caches the result of `reroute` on the client so it is only called once per unique URL.\n\n### transport\n\nThis is a collection of _transporters_, which allow you to pass custom types — returned from `load` and form actions — across the server/client boundary. Each transporter contains an `encode` function, which encodes values on the server (or returns a falsy value for anything that isn't an instance of the type) and a corresponding `decode` function:\n\n```js\n// @errors: 2307\n/// file: src/hooks.js\nimport { Vector } from '$lib/math';\n\n/** @type {import('@sveltejs/kit').Transport} */\nexport const transport = {\n\tVector: {\n\t\tencode: (value) => value instanceof Vector && [value.x, value.y],\n\t\tdecode: ([x, y]) => new Vector(x, y)\n\t}\n};\n```\n\n\n## Further reading\n\n- [Tutorial: Hooks](/tutorial/kit/handle)\n","## Server Hooks\n\n**handle** — Runs on every request (including prerendering). Receives `event` and `resolve` function. Allows modifying response headers/bodies or bypassing SvelteKit entirely.\n\n```js\nexport async function handle({ event, resolve }) {\n\tif (event.url.pathname.startsWith('/custom')) {\n\t\treturn new Response('custom response');\n\t}\n\tconst response = await resolve(event);\n\tresponse.headers.set('x-custom-header', 'value');\n\treturn response;\n}\n```\n\n`resolve` accepts optional second parameter with:\n- `transformPageChunk(opts)` — Transform HTML chunks\n- `filterSerializedResponseHeaders(name, value)` — Control which headers serialize in `load` fetch responses\n- `preload(input)` — Determine which files preload in `\u003Chead>`\n\n**handleFetch** — Modifies/replaces `event.fetch` calls on server or during prerendering. Useful for redirecting API calls to localhost during SSR or manually forwarding cookies for sibling subdomains.\n\n```js\nexport async function handleFetch({ request, fetch }) {\n\tif (request.url.startsWith('https://api.yourapp.com/')) {\n\t\trequest = new Request(\n\t\t\trequest.url.replace('https://api.yourapp.com/', 'http://localhost:9999/'),\n\t\t\trequest\n\t\t);\n\t}\n\treturn fetch(request);\n}\n```\n\n**handleValidationError** — Called when remote function receives invalid argument against Standard Schema. Must return object matching `App.Error` shape.\n\n## Shared Hooks (server and client)\n\n**handleError** — Called for unexpected errors during loading, rendering, or endpoints. Receives `error`, `event`, `status`, `message`. Allows logging and returning safe error representation for `$page.error`. Customize error shape via `App.Error` interface.\n\n```js\nexport async function handleError({ error, event, status, message }) {\n\tconst errorId = crypto.randomUUID();\n\tSentry.captureException(error, { extra: { event, errorId, status } });\n\treturn { message: 'Whoops!', errorId };\n}\n```\n\n**init** — Runs once when server starts or app loads in browser. Useful for async initialization like database connections. Note: async work delays browser hydration.\n\n## Universal Hooks (src/hooks.js)\n\n**reroute** — Runs before `handle`. Changes URL-to-route translation by returning modified pathname. Can be async (since v2.18) to fetch data for routing decisions.\n\n```js\nconst translated = {\n\t'/de/ueber-uns': '/de/about',\n\t'/fr/a-propos': '/fr/about',\n};\nexport function reroute({ url }) {\n\treturn translated[url.pathname];\n}\n```\n\n**transport** — Collection of transporters for passing custom types across server/client boundary. Each has `encode` (server) and `decode` (client) functions.\n\n```js\nexport const transport = {\n\tVector: {\n\t\tencode: (value) => value instanceof Vector && [value.x, value.y],\n\t\tdecode: ([x, y]) => new Vector(x, y)\n\t}\n};\n```\n\nFiles: `src/hooks.server.js`, `src/hooks.client.js`, `src/hooks.js` (all optional).","## Server Hooks\n\n**handle** — Intercepts every request. Modify response or bypass SvelteKit. Supports `transformPageChunk`, `filterSerializedResponseHeaders`, `preload` options.\n\n**handleFetch** — Intercepts `event.fetch` calls. Redirect API URLs or forward cookies.\n\n**handleValidationError** — Customize validation error responses.\n\n## Shared Hooks\n\n**handleError** — Log errors and return safe representation for `$page.error`.\n\n**init** — Async initialization on startup.\n\n## Universal Hooks\n\n**reroute** — Translate URLs to routes (can be async).\n\n**transport** — Encode/decode custom types across server/client boundary.\n\nFiles: `src/hooks.server.js`, `src/hooks.client.js`, `src/hooks.js`","App-wide functions that hook into SvelteKit lifecycle events for request handling, error management, routing, and type serialization.","errors",{"name":550,"path":552,"children":553,"data":554},"advanced-techniques/errors",["Map"],{"type":22,"path":555,"relevant":44,"token_counts":556,"usage":560,"markdown":563},"30-advanced/25-errors.md",{"fulltext":557,"digest":558,"short_digest":559},1497,543,268,{"input":561,"output":562,"details":32},2538,920,{"fulltext":564,"digest":565,"short_digest":566,"essence":567},"---\ntitle: Errors\n---\n\nErrors are an inevitable fact of software development. SvelteKit handles errors differently depending on where they occur, what kind of errors they are, and the nature of the incoming request.\n\n## Error objects\n\nSvelteKit distinguishes between expected and unexpected errors, both of which are represented as simple `{ message: string }` objects by default.\n\nYou can add additional properties, like a `code` or a tracking `id`, as shown in the examples below. (When using TypeScript this requires you to redefine the `Error` type as described in  [type safety](errors#Type-safety)).\n\n## Expected errors\n\nAn _expected_ error is one created with the [`error`](@sveltejs-kit#error) helper imported from `@sveltejs/kit`:\n\n```js\n/// file: src/routes/blog/[slug]/+page.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function getPost(slug: string): Promise\u003C{ title: string, content: string } | undefined>\n}\n\n// @filename: index.js\n// ---cut---\nimport { error } from '@sveltejs/kit';\nimport * as db from '$lib/server/database';\n\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\tconst post = await db.getPost(params.slug);\n\n\tif (!post) {\n\t\terror(404, {\n\t\t\tmessage: 'Not found'\n\t\t});\n\t}\n\n\treturn { post };\n}\n```\n\nThis throws an exception that SvelteKit catches, causing it to set the response status code to 404 and render an [`+error.svelte`](routing#error) component, where `page.error` is the object provided as the second argument to `error(...)`.\n\n```svelte\n\u003C!--- file: src/routes/+error.svelte --->\n\u003Cscript>\n\timport { page } from '$app/state';\n\u003C/script>\n\n\u003Ch1>{page.error.message}\u003C/h1>\n```\n\n> [!LEGACY]\n> `$app/state` was added in SvelteKit 2.12. If you're using an earlier version or are using Svelte 4, use `$app/stores` instead.\n\nYou can add extra properties to the error object if needed...\n\n```js\n// @filename: ambient.d.ts\ndeclare global {\n\tnamespace App {\n\t\tinterface Error {\n\t\t\tmessage: string;\n\t\t\tcode: string;\n\t\t}\n\t}\n}\nexport {}\n\n// @filename: index.js\nimport { error } from '@sveltejs/kit';\n// ---cut---\nerror(404, {\n\tmessage: 'Not found',\n\t+++code: 'NOT_FOUND'+++\n});\n```\n\n...otherwise, for convenience, you can pass a string as the second argument:\n\n```js\nimport { error } from '@sveltejs/kit';\n// ---cut---\n---error(404, { message: 'Not found' });---\n+++error(404, 'Not found');+++\n```\n\n> [!NOTE] [In SvelteKit 1.x](migrating-to-sveltekit-2#redirect-and-error-are-no-longer-thrown-by-you) you had to `throw` the `error` yourself\n\n## Unexpected errors\n\nAn _unexpected_ error is any other exception that occurs while handling a request. Since these can contain sensitive information, unexpected error messages and stack traces are not exposed to users.\n\nBy default, unexpected errors are printed to the console (or, in production, your server logs), while the error that is exposed to the user has a generic shape:\n\n```json\n{ \"message\": \"Internal Error\" }\n```\n\nUnexpected errors will go through the [`handleError`](hooks#Shared-hooks-handleError) hook, where you can add your own error handling — for example, sending errors to a reporting service, or returning a custom error object which becomes `$page.error`.\n\n## Responses\n\nIf an error occurs inside `handle` or inside a [`+server.js`](routing#server) request handler, SvelteKit will respond with either a fallback error page or a JSON representation of the error object, depending on the request's `Accept` headers.\n\nYou can customise the fallback error page by adding a `src/error.html` file:\n\n```html\n\u003C!DOCTYPE html>\n\u003Chtml lang=\"en\">\n\t\u003Chead>\n\t\t\u003Cmeta charset=\"utf-8\" />\n\t\t\u003Ctitle>%sveltekit.error.message%\u003C/title>\n\t\u003C/head>\n\t\u003Cbody>\n\t\t\u003Ch1>My custom error page\u003C/h1>\n\t\t\u003Cp>Status: %sveltekit.status%\u003C/p>\n\t\t\u003Cp>Message: %sveltekit.error.message%\u003C/p>\n\t\u003C/body>\n\u003C/html>\n```\n\nSvelteKit will replace `%sveltekit.status%` and `%sveltekit.error.message%` with their corresponding values.\n\nIf the error instead occurs inside a `load` function while rendering a page, SvelteKit will render the [`+error.svelte`](routing#error) component nearest to where the error occurred. If the error occurs inside a `load` function in `+layout(.server).js`, the closest error boundary in the tree is an `+error.svelte` file _above_ that layout (not next to it).\n\nThe exception is when the error occurs inside the root `+layout.js` or `+layout.server.js`, since the root layout would ordinarily _contain_ the `+error.svelte` component. In this case, SvelteKit uses the fallback error page.\n\n## Type safety\n\nIf you're using TypeScript and need to customize the shape of errors, you can do so by declaring an `App.Error` interface in your app (by convention, in `src/app.d.ts`, though it can live anywhere that TypeScript can 'see'):\n\n```ts\n/// file: src/app.d.ts\ndeclare global {\n\tnamespace App {\n\t\tinterface Error {\n+++\t\t\tcode: string;\n\t\t\tid: string;+++\n\t\t}\n\t}\n}\n\nexport {};\n```\n\nThis interface always includes a `message: string` property.\n\n## Further reading\n\n- [Tutorial: Errors and redirects](/tutorial/kit/error-basics)\n- [Tutorial: Hooks](/tutorial/kit/handle)\n","## Expected vs Unexpected Errors\n\nSvelteKit distinguishes between two error types:\n\n**Expected errors** are created with the `error()` helper from `@sveltejs/kit`. They throw an exception that SvelteKit catches, setting the response status code and rendering the nearest `+error.svelte` component with `page.error` containing the error object.\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport async function load({ params }) {\n\tconst post = await db.getPost(params.slug);\n\tif (!post) {\n\t\terror(404, 'Not found');\n\t}\n\treturn { post };\n}\n```\n\nYou can pass a string as the second argument or an object with custom properties:\n\n```js\nerror(404, { message: 'Not found', code: 'NOT_FOUND' });\n```\n\n**Unexpected errors** are any other exceptions. They're not exposed to users (to avoid leaking sensitive info) and instead show a generic `{ message: \"Internal Error\" }`. They pass through the `handleError` hook where you can add custom handling like error reporting.\n\n## Error Objects & Type Safety\n\nError objects are `{ message: string }` by default. Add custom properties by declaring an `App.Error` interface in `src/app.d.ts`:\n\n```ts\ndeclare global {\n\tnamespace App {\n\t\tinterface Error {\n\t\t\tcode: string;\n\t\t\tid: string;\n\t\t}\n\t}\n}\n```\n\n## Error Responses\n\nIf an error occurs in `handle` or `+server.js`, SvelteKit responds with either a fallback error page or JSON based on `Accept` headers.\n\nCustomize the fallback error page with `src/error.html`:\n\n```html\n\u003Chtml>\n\t\u003Ctitle>%sveltekit.error.message%\u003C/title>\n\t\u003Cbody>\n\t\t\u003Cp>Status: %sveltekit.status%\u003C/p>\n\t\t\u003Cp>Message: %sveltekit.error.message%\u003C/p>\n\t\u003C/body>\n\u003C/html>\n```\n\nFor errors in `load` functions during page rendering, SvelteKit renders the nearest `+error.svelte` component. Exception: errors in root `+layout.js/+layout.server.js` use the fallback error page since the root layout contains the error component.","## Expected vs Unexpected Errors\n\n**Expected errors** use the `error()` helper to throw exceptions that SvelteKit catches and renders with `+error.svelte`:\n\n```js\nimport { error } from '@sveltejs/kit';\nerror(404, 'Not found');\n// or with custom properties:\nerror(404, { message: 'Not found', code: 'NOT_FOUND' });\n```\n\n**Unexpected errors** are other exceptions. They show a generic message to users and pass through the `handleError` hook for custom handling.\n\n## Type Safety\n\nDeclare custom error properties in `src/app.d.ts`:\n\n```ts\ndeclare global {\n\tnamespace App {\n\t\tinterface Error {\n\t\t\tcode: string;\n\t\t\tid: string;\n\t\t}\n\t}\n}\n```\n\n## Error Responses\n\nCustomize the fallback error page with `src/error.html` using `%sveltekit.status%` and `%sveltekit.error.message%` placeholders. Errors in `load` functions render the nearest `+error.svelte`, except in root layouts which use the fallback page.","How to handle expected and unexpected errors in SvelteKit, customize error objects, and control error page rendering.","link-options",{"name":568,"path":570,"children":571,"data":572},"advanced-techniques/link-options",["Map"],{"type":22,"path":573,"relevant":44,"token_counts":574,"usage":578,"markdown":581},"30-advanced/30-link-options.md",{"fulltext":575,"digest":576,"short_digest":577},1890,641,211,{"input":579,"output":580,"details":32},2933,974,{"fulltext":582,"digest":583,"short_digest":584,"essence":585},"---\ntitle: Link options\n---\n\nIn SvelteKit, `\u003Ca>` elements (rather than framework-specific `\u003CLink>` components) are used to navigate between the routes of your app. If the user clicks on a link whose `href` is 'owned' by the app (as opposed to, say, a link to an external site) then SvelteKit will navigate to the new page by importing its code and then calling any `load` functions it needs to fetch data.\n\nYou can customise the behaviour of links with `data-sveltekit-*` attributes. These can be applied to the `\u003Ca>` itself, or to a parent element.\n\nThese options also apply to `\u003Cform>` elements with [`method=\"GET\"`](form-actions#GET-vs-POST).\n\n## data-sveltekit-preload-data\n\nBefore the browser registers that the user has clicked on a link, we can detect that they've hovered the mouse over it (on desktop) or that a `touchstart` or `mousedown` event was triggered. In both cases, we can make an educated guess that a `click` event is coming.\n\nSvelteKit can use this information to get a head start on importing the code and fetching the page's data, which can give us an extra couple of hundred milliseconds — the difference between a user interface that feels laggy and one that feels snappy.\n\nWe can control this behaviour with the `data-sveltekit-preload-data` attribute, which can have one of two values:\n\n- `\"hover\"` means that preloading will start if the mouse comes to a rest over a link. On mobile, preloading begins on `touchstart`\n- `\"tap\"` means that preloading will start as soon as a `touchstart` or `mousedown` event is registered\n\nThe default project template has a `data-sveltekit-preload-data=\"hover\"` attribute applied to the `\u003Cbody>` element in `src/app.html`, meaning that every link is preloaded on hover by default:\n\n```html\n\u003Cbody data-sveltekit-preload-data=\"hover\">\n\t\u003Cdiv style=\"display: contents\">%sveltekit.body%\u003C/div>\n\u003C/body>\n```\n\nSometimes, calling `load` when the user hovers over a link might be undesirable, either because it's likely to result in false positives (a click needn't follow a hover) or because data is updating very quickly and a delay could mean staleness.\n\nIn these cases, you can specify the `\"tap\"` value, which causes SvelteKit to call `load` only when the user taps or clicks on a link:\n\n```html\n\u003Ca data-sveltekit-preload-data=\"tap\" href=\"/stonks\">\n\tGet current stonk values\n\u003C/a>\n```\n\n> [!NOTE] You can also programmatically invoke `preloadData` from `$app/navigation`.\n\nData will never be preloaded if the user has chosen reduced data usage, meaning [`navigator.connection.saveData`](https://developer.mozilla.org/en-US/docs/Web/API/NetworkInformation/saveData) is `true`.\n\n## data-sveltekit-preload-code\n\nEven in cases where you don't want to preload _data_ for a link, it can be beneficial to preload the _code_. The `data-sveltekit-preload-code` attribute works similarly to `data-sveltekit-preload-data`, except that it can take one of four values, in decreasing 'eagerness':\n\n- `\"eager\"` means that links will be preloaded straight away\n- `\"viewport\"` means that links will be preloaded once they enter the viewport\n- `\"hover\"` - as above, except that only code is preloaded\n- `\"tap\"` - as above, except that only code is preloaded\n\nNote that `viewport` and `eager` only apply to links that are present in the DOM immediately following navigation — if a link is added later (in an `{#if ...}` block, for example) it will not be preloaded until triggered by `hover` or `tap`. This is to avoid performance pitfalls resulting from aggressively observing the DOM for changes.\n\n> [!NOTE] Since preloading code is a prerequisite for preloading data, this attribute will only have an effect if it specifies a more eager value than any `data-sveltekit-preload-data` attribute that is present.\n\nAs with `data-sveltekit-preload-data`, this attribute will be ignored if the user has chosen reduced data usage.\n\n## data-sveltekit-reload\n\nOccasionally, we need to tell SvelteKit not to handle a link, but allow the browser to handle it. Adding a `data-sveltekit-reload` attribute to a link...\n\n```html\n\u003Ca data-sveltekit-reload href=\"/path\">Path\u003C/a>\n```\n\n...will cause a full-page navigation when the link is clicked.\n\nLinks with a `rel=\"external\"` attribute will receive the same treatment. In addition, they will be ignored during [prerendering](page-options#prerender).\n\n## data-sveltekit-replacestate\n\nSometimes you don't want navigation to create a new entry in the browser's session history. Adding a `data-sveltekit-replacestate` attribute to a link...\n\n```html\n\u003Ca data-sveltekit-replacestate href=\"/path\">Path\u003C/a>\n```\n\n...will replace the current `history` entry rather than creating a new one with `pushState` when the link is clicked.\n\n## data-sveltekit-keepfocus\n\nSometimes you don't want [focus to be reset](accessibility#Focus-management) after navigation. For example, maybe you have a search form that submits as the user is typing, and you want to keep focus on the text input.  Adding a `data-sveltekit-keepfocus` attribute to it...\n\n```html\n\u003Cform data-sveltekit-keepfocus>\n\t\u003Cinput type=\"text\" name=\"query\">\n\u003C/form>\n```\n\n...will cause the currently focused element to retain focus after navigation. In general, avoid using this attribute on links, since the focused element would be the `\u003Ca>` tag (and not a previously focused element) and screen reader and other assistive technology users often expect focus to be moved after a navigation. You should also only use this attribute on elements that still exist after navigation. If the element no longer exists, the user's focus will be lost, making for a confusing experience for assistive technology users.\n\n## data-sveltekit-noscroll\n\nWhen navigating to internal links, SvelteKit mirrors the browser's default navigation behaviour: it will change the scroll position to 0,0 so that the user is at the very top left of the page (unless the link includes a `#hash`, in which case it will scroll to the element with a matching ID).\n\nIn certain cases, you may wish to disable this behaviour. Adding a `data-sveltekit-noscroll` attribute to a link...\n\n```html\n\u003Ca href=\"path\" data-sveltekit-noscroll>Path\u003C/a>\n```\n\n...will prevent scrolling after the link is clicked.\n\n## Disabling options\n\nTo disable any of these options inside an element where they have been enabled, use the `\"false\"` value:\n\n```html\n\u003Cdiv data-sveltekit-preload-data>\n\t\u003C!-- these links will be preloaded -->\n\t\u003Ca href=\"/a\">a\u003C/a>\n\t\u003Ca href=\"/b\">b\u003C/a>\n\t\u003Ca href=\"/c\">c\u003C/a>\n\n\t\u003Cdiv data-sveltekit-preload-data=\"false\">\n\t\t\u003C!-- these links will NOT be preloaded -->\n\t\t\u003Ca href=\"/d\">d\u003C/a>\n\t\t\u003Ca href=\"/e\">e\u003C/a>\n\t\t\u003Ca href=\"/f\">f\u003C/a>\n\t\u003C/div>\n\u003C/div>\n```\n\nTo apply an attribute to an element conditionally, do this:\n\n```svelte\n\u003Cdiv data-sveltekit-preload-data={condition ? 'hover' : false}>\n```\n","## Link Navigation Attributes\n\nSvelteKit uses standard `\u003Ca>` elements for navigation. Customize behavior with `data-sveltekit-*` attributes applied to links or parent elements. These also apply to `\u003Cform method=\"GET\">`.\n\n### data-sveltekit-preload-data\nControls when page data is preloaded:\n- `\"hover\"` (default): preload on mouse hover or touchstart\n- `\"tap\"`: preload only on click/tap\n\nRespects `navigator.connection.saveData` for reduced data usage.\n\n```html\n\u003Ca data-sveltekit-preload-data=\"tap\" href=\"/stonks\">Get values\u003C/a>\n```\n\n### data-sveltekit-preload-code\nControls when page code is preloaded (prerequisite for data preloading):\n- `\"eager\"`: preload immediately\n- `\"viewport\"`: preload when link enters viewport\n- `\"hover\"`: preload code on hover\n- `\"tap\"`: preload code on tap\n\nOnly applies to links in DOM immediately after navigation. Ignored if user has reduced data usage enabled.\n\n### data-sveltekit-reload\nForces full-page browser navigation instead of SvelteKit handling:\n```html\n\u003Ca data-sveltekit-reload href=\"/path\">Path\u003C/a>\n```\n\nLinks with `rel=\"external\"` behave the same way and are ignored during prerendering.\n\n### data-sveltekit-replacestate\nReplaces current history entry instead of creating new one:\n```html\n\u003Ca data-sveltekit-replacestate href=\"/path\">Path\u003C/a>\n```\n\n### data-sveltekit-keepfocus\nRetains focus on currently focused element after navigation:\n```html\n\u003Cform data-sveltekit-keepfocus>\n\t\u003Cinput type=\"text\" name=\"query\">\n\u003C/form>\n```\n\nAvoid on links; use only on elements that persist after navigation.\n\n### data-sveltekit-noscroll\nPrevents automatic scroll to top (or hash target) after navigation:\n```html\n\u003Ca href=\"path\" data-sveltekit-noscroll>Path\u003C/a>\n```\n\n### Disabling Options\nSet attribute to `\"false\"` to disable within a scoped element:\n```html\n\u003Cdiv data-sveltekit-preload-data>\n\t\u003Ca href=\"/a\">preloaded\u003C/a>\n\t\u003Cdiv data-sveltekit-preload-data=\"false\">\n\t\t\u003Ca href=\"/b\">not preloaded\u003C/a>\n\t\u003C/div>\n\u003C/div>\n```\n\nUse conditional syntax: `data-sveltekit-preload-data={condition ? 'hover' : false}`","## Link Navigation Attributes\n\nControl SvelteKit link behavior with `data-sveltekit-*` attributes:\n\n- **data-sveltekit-preload-data**: `\"hover\"` (default) or `\"tap\"` — when to preload page data\n- **data-sveltekit-preload-code**: `\"eager\"`, `\"viewport\"`, `\"hover\"`, or `\"tap\"` — when to preload code\n- **data-sveltekit-reload**: force full-page browser navigation\n- **data-sveltekit-replacestate**: replace history entry instead of pushing new one\n- **data-sveltekit-keepfocus**: retain focus after navigation\n- **data-sveltekit-noscroll**: prevent scroll to top after navigation\n\nDisable with `\"false\"` value. Respects `navigator.connection.saveData`.","Customize SvelteKit link navigation behavior using data-sveltekit-* attributes for preloading, history management, focus, and scroll control.","service-workers",{"name":586,"path":588,"children":589,"data":590},"advanced-techniques/service-workers",["Map"],{"type":22,"path":591,"relevant":44,"token_counts":592,"usage":596,"markdown":599},"30-advanced/40-service-workers.md",{"fulltext":593,"digest":594,"short_digest":595},1543,587,101,{"input":597,"output":598,"details":32},2586,793,{"fulltext":600,"digest":601,"short_digest":602,"essence":603},"---\ntitle: Service workers\n---\n\nService workers act as proxy servers that handle network requests inside your app. This makes it possible to make your app work offline, but even if you don't need offline support (or can't realistically implement it because of the type of app you're building), it's often worth using service workers to speed up navigation by precaching your built JS and CSS.\n\nIn SvelteKit, if you have a `src/service-worker.js` file (or `src/service-worker/index.js`) it will be bundled and automatically registered. You can change the [location of your service worker](configuration#files) if you need to.\n\nYou can [disable automatic registration](configuration#serviceWorker) if you need to register the service worker with your own logic or use another solution. The default registration looks something like this:\n\n```js\nif ('serviceWorker' in navigator) {\n\taddEventListener('load', function () {\n\t\tnavigator.serviceWorker.register('./path/to/service-worker.js');\n\t});\n}\n```\n\n## Inside the service worker\n\nInside the service worker you have access to the [`$service-worker` module]($service-worker), which provides you with the paths to all static assets, build files and prerendered pages. You're also provided with an app version string, which you can use for creating a unique cache name, and the deployment's `base` path. If your Vite config specifies `define` (used for global variable replacements), this will be applied to service workers as well as your server/client builds.\n\nThe following example caches the built app and any files in `static` eagerly, and caches all other requests as they happen. This would make each page work offline once visited.\n\n```js\n/// file: src/service-worker.js\n// Disables access to DOM typings like `HTMLElement` which are not available\n// inside a service worker and instantiates the correct globals\n/// \u003Creference no-default-lib=\"true\"/>\n/// \u003Creference lib=\"esnext\" />\n/// \u003Creference lib=\"webworker\" />\n\n// Ensures that the `$service-worker` import has proper type definitions\n/// \u003Creference types=\"@sveltejs/kit\" />\n\n// Only necessary if you have an import from `$env/static/public`\n/// \u003Creference types=\"../.svelte-kit/ambient.d.ts\" />\n\nimport { build, files, version } from '$service-worker';\n\n// This gives `self` the correct types\nconst self = /** @type {ServiceWorkerGlobalScope} */ (/** @type {unknown} */ (globalThis.self));\n\n// Create a unique cache name for this deployment\nconst CACHE = `cache-${version}`;\n\nconst ASSETS = [\n\t...build, // the app itself\n\t...files  // everything in `static`\n];\n\nself.addEventListener('install', (event) => {\n\t// Create a new cache and add all files to it\n\tasync function addFilesToCache() {\n\t\tconst cache = await caches.open(CACHE);\n\t\tawait cache.addAll(ASSETS);\n\t}\n\n\tevent.waitUntil(addFilesToCache());\n});\n\nself.addEventListener('activate', (event) => {\n\t// Remove previous cached data from disk\n\tasync function deleteOldCaches() {\n\t\tfor (const key of await caches.keys()) {\n\t\t\tif (key !== CACHE) await caches.delete(key);\n\t\t}\n\t}\n\n\tevent.waitUntil(deleteOldCaches());\n});\n\nself.addEventListener('fetch', (event) => {\n\t// ignore POST requests etc\n\tif (event.request.method !== 'GET') return;\n\n\tasync function respond() {\n\t\tconst url = new URL(event.request.url);\n\t\tconst cache = await caches.open(CACHE);\n\n\t\t// `build`/`files` can always be served from the cache\n\t\tif (ASSETS.includes(url.pathname)) {\n\t\t\tconst response = await cache.match(url.pathname);\n\n\t\t\tif (response) {\n\t\t\t\treturn response;\n\t\t\t}\n\t\t}\n\n\t\t// for everything else, try the network first, but\n\t\t// fall back to the cache if we're offline\n\t\ttry {\n\t\t\tconst response = await fetch(event.request);\n\n\t\t\t// if we're offline, fetch can return a value that is not a Response\n\t\t\t// instead of throwing - and we can't pass this non-Response to respondWith\n\t\t\tif (!(response instanceof Response)) {\n\t\t\t\tthrow new Error('invalid response from fetch');\n\t\t\t}\n\n\t\t\tif (response.status === 200) {\n\t\t\t\tcache.put(event.request, response.clone());\n\t\t\t}\n\n\t\t\treturn response;\n\t\t} catch (err) {\n\t\t\tconst response = await cache.match(event.request);\n\n\t\t\tif (response) {\n\t\t\t\treturn response;\n\t\t\t}\n\n\t\t\t// if there's no cache, then just error out\n\t\t\t// as there is nothing we can do to respond to this request\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\tevent.respondWith(respond());\n});\n```\n\n> [!NOTE] Be careful when caching! In some cases, stale data might be worse than data that's unavailable while offline. Since browsers will empty caches if they get too full, you should also be careful about caching large assets like video files.\n\n## During development\n\nThe service worker is bundled for production, but not during development. For that reason, only browsers that support [modules in service workers](https://web.dev/es-modules-in-sw) will be able to use them at dev time. If you are manually registering your service worker, you will need to pass the `{ type: 'module' }` option in development:\n\n```js\nimport { dev } from '$app/environment';\n\nnavigator.serviceWorker.register('/service-worker.js', {\n\ttype: dev ? 'module' : 'classic'\n});\n```\n\n> [!NOTE] `build` and `prerendered` are empty arrays during development\n\n## Other solutions\n\nSvelteKit's service worker implementation is designed to be easy to work with and is probably a good solution for most users. However, outside of SvelteKit, many PWA applications leverage the [Workbox](https://web.dev/learn/pwa/workbox) library. If you're used to using Workbox you may prefer [Vite PWA plugin](https://vite-pwa-org.netlify.app/frameworks/sveltekit.html).\n\n## References\n\nFor more general information on service workers, we recommend [the MDN web docs](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers).\n","Service workers act as proxy servers for network requests, enabling offline support and performance optimization through precaching. SvelteKit automatically bundles and registers a service worker if `src/service-worker.js` (or `src/service-worker/index.js`) exists.\n\nInside the service worker, access the `$service-worker` module to get paths to static assets, build files, prerendered pages, app version, and base path. Use the version string to create unique cache names.\n\nExample service worker implementation:\n```js\n/// \u003Creference no-default-lib=\"true\"/>\n/// \u003Creference lib=\"esnext\" />\n/// \u003Creference lib=\"webworker\" />\n/// \u003Creference types=\"@sveltejs/kit\" />\n\nimport { build, files, version } from '$service-worker';\nconst self = /** @type {ServiceWorkerGlobalScope} */ (globalThis.self);\nconst CACHE = `cache-${version}`;\nconst ASSETS = [...build, ...files];\n\nself.addEventListener('install', (event) => {\n\tevent.waitUntil((async () => {\n\t\tconst cache = await caches.open(CACHE);\n\t\tawait cache.addAll(ASSETS);\n\t})());\n});\n\nself.addEventListener('activate', (event) => {\n\tevent.waitUntil((async () => {\n\t\tfor (const key of await caches.keys()) {\n\t\t\tif (key !== CACHE) await caches.delete(key);\n\t\t}\n\t})());\n});\n\nself.addEventListener('fetch', (event) => {\n\tif (event.request.method !== 'GET') return;\n\tevent.respondWith((async () => {\n\t\tconst url = new URL(event.request.url);\n\t\tconst cache = await caches.open(CACHE);\n\t\tif (ASSETS.includes(url.pathname)) {\n\t\t\treturn await cache.match(url.pathname);\n\t\t}\n\t\ttry {\n\t\t\tconst response = await fetch(event.request);\n\t\t\tif (response instanceof Response && response.status === 200) {\n\t\t\t\tcache.put(event.request, response.clone());\n\t\t\t}\n\t\t\treturn response;\n\t\t} catch {\n\t\t\treturn await cache.match(event.request);\n\t\t}\n\t})());\n});\n```\n\nDisable automatic registration via configuration if you need custom logic. During development, only browsers supporting ES modules in service workers work; manually register with `{ type: dev ? 'module' : 'classic' }`. Vite PWA plugin and Workbox are alternative solutions.","SvelteKit automatically registers `src/service-worker.js` for offline support and performance. Access `$service-worker` module for build files, static assets, version, and base path. Implement install/activate/fetch handlers to cache assets and handle offline requests. Use version string for unique cache names. Disable auto-registration via config if needed. In dev, use `{ type: 'module' }` for manual registration.","How to implement and configure service workers in SvelteKit for offline support and performance optimization.","server-only-modules",{"name":604,"path":606,"children":607,"data":608},"advanced-techniques/server-only-modules",["Map"],{"type":22,"path":609,"relevant":44,"token_counts":610,"usage":613,"markdown":616},"30-advanced/50-server-only-modules.md",{"fulltext":611,"digest":612,"short_digest":259},721,362,{"input":614,"output":615,"details":32},1766,546,{"fulltext":617,"digest":618,"short_digest":619,"essence":620},"---\ntitle: Server-only modules\n---\n\nLike a good friend, SvelteKit keeps your secrets. When writing your backend and frontend in the same repository, it can be easy to accidentally import sensitive data into your front-end code (environment variables containing API keys, for example). SvelteKit provides a way to prevent this entirely: server-only modules.\n\n## Private environment variables\n\nThe [`$env/static/private`]($env-static-private) and [`$env/dynamic/private`]($env-dynamic-private) modules can only be imported into modules that only run on the server, such as [`hooks.server.js`](hooks#Server-hooks) or [`+page.server.js`](routing#page-page.server.js).\n\n## Server-only utilities\n\nThe [`$app/server`]($app-server) module, which contains a [`read`]($app-server#read) function for reading assets from the filesystem, can likewise only be imported by code that runs on the server.\n\n## Your modules\n\nYou can make your own modules server-only in two ways:\n\n- adding `.server` to the filename, e.g. `secrets.server.js`\n- placing them in `$lib/server`, e.g. `$lib/server/secrets.js`\n\n## How it works\n\nAny time you have public-facing code that imports server-only code (whether directly or indirectly)...\n\n```js\n// @errors: 7005\n/// file: $lib/server/secrets.js\nexport const atlantisCoordinates = [/* redacted */];\n```\n\n```js\n// @errors: 2307 7006 7005\n/// file: src/routes/utils.js\nexport { atlantisCoordinates } from '$lib/server/secrets.js';\n\nexport const add = (a, b) => a + b;\n```\n\n```html\n/// file: src/routes/+page.svelte\n\u003Cscript>\n\timport { add } from './utils.js';\n\u003C/script>\n```\n\n...SvelteKit will error:\n\n```\nCannot import $lib/server/secrets.ts into code that runs in the browser, as this could leak sensitive information.\n\n src/routes/+page.svelte imports\n  src/routes/utils.js imports\n   $lib/server/secrets.ts\n\nIf you're only using the import as a type, change it to `import type`.\n```\n\nEven though the public-facing code — `src/routes/+page.svelte` — only uses the `add` export and not the secret `atlantisCoordinates` export, the secret code could end up in JavaScript that the browser downloads, and so the import chain is considered unsafe.\n\nThis feature also works with dynamic imports, even interpolated ones like ``await import(`./${foo}.js`)``.\n\n> [!NOTE] Unit testing frameworks like Vitest do not distinguish between server-only and public-facing code. For this reason, illegal import detection is disabled when running tests, as determined by `process.env.TEST === 'true'`.\n\n## Further reading\n\n- [Tutorial: Environment variables](/tutorial/kit/env-static-private)\n","## Server-only modules\n\nPrevent accidental exposure of sensitive data (API keys, private environment variables) to the browser by marking code as server-only.\n\n### Private environment variables\n\nImport `$env/static/private` and `$env/dynamic/private` only in server-side files like `hooks.server.js` or `+page.server.js`.\n\n### Server utilities\n\nThe `$app/server` module (containing `read()` for filesystem access) can only be imported by server-side code.\n\n### Creating server-only modules\n\nTwo ways to mark your own modules as server-only:\n1. Add `.server` to filename: `secrets.server.js`\n2. Place in `$lib/server/`: `$lib/server/secrets.js`\n\n### How it works\n\nSvelteKit prevents any import chain from public-facing code (like `+page.svelte`) to server-only code, even if only unused exports are imported:\n\n```js\n// $lib/server/secrets.js\nexport const apiKey = 'secret';\n\n// src/routes/utils.js\nexport { apiKey } from '$lib/server/secrets.js';\nexport const add = (a, b) => a + b;\n\n// src/routes/+page.svelte\nimport { add } from './utils.js'; // ERROR: import chain includes server-only code\n```\n\nThis also works with dynamic imports like `` await import(`./${foo}.js`) ``.\n\n**Note:** Unit testing frameworks disable this check when `process.env.TEST === 'true'`.","Mark modules as server-only using `.server` filename suffix or `$lib/server/` directory to prevent sensitive data leaking to the browser. SvelteKit errors if any import chain from client code reaches server-only modules, even indirectly or through unused exports.","Prevent accidental exposure of sensitive data to the browser by marking modules as server-only using .server suffix or $lib/server/ directory.","snapshots",{"name":621,"path":623,"children":624,"data":625},"advanced-techniques/snapshots",["Map"],{"type":22,"path":626,"relevant":44,"token_counts":627,"usage":631,"markdown":634},"30-advanced/65-snapshots.md",{"fulltext":628,"digest":629,"short_digest":630},457,233,95,{"input":632,"output":633,"details":32},1499,432,{"fulltext":635,"digest":636,"short_digest":637,"essence":638},"---\ntitle: Snapshots\n---\n\nEphemeral DOM state — like scroll positions on sidebars, the content of `\u003Cinput>` elements and so on — is discarded when you navigate from one page to another.\n\nFor example, if the user fills out a form but navigates away and then back before submitting, or if the user refreshes the page, the values they filled in will be lost. In cases where it's valuable to preserve that input, you can take a _snapshot_ of DOM state, which can then be restored if the user navigates back.\n\nTo do this, export a `snapshot` object with `capture` and `restore` methods from a `+page.svelte` or `+layout.svelte`:\n\n```svelte\n\u003C!--- file: +page.svelte --->\n\u003Cscript>\n\tlet comment = $state('');\n\n\t/** @type {import('./$types').Snapshot\u003Cstring>} */\n\texport const snapshot = {\n\t\tcapture: () => comment,\n\t\trestore: (value) => comment = value\n\t};\n\u003C/script>\n\n\u003Cform method=\"POST\">\n\t\u003Clabel for=\"comment\">Comment\u003C/label>\n\t\u003Ctextarea id=\"comment\" bind:value={comment} />\n\t\u003Cbutton>Post comment\u003C/button>\n\u003C/form>\n```\n\nWhen you navigate away from this page, the `capture` function is called immediately before the page updates, and the returned value is associated with the current entry in the browser's history stack. If you navigate back, the `restore` function is called with the stored value as soon as the page is updated.\n\nThe data must be serializable as JSON so that it can be persisted to `sessionStorage`. This allows the state to be restored when the page is reloaded, or when the user navigates back from a different site.\n\n> [!NOTE] Avoid returning very large objects from `capture` — once captured, objects will be retained in memory for the duration of the session, and in extreme cases may be too large to persist to `sessionStorage`.\n","## Snapshots\n\nPreserve ephemeral DOM state (scroll positions, form input values, etc.) across navigation by exporting a `snapshot` object from `+page.svelte` or `+layout.svelte`.\n\nThe snapshot object must have two methods:\n- `capture()`: Called before navigation, returns the state to preserve\n- `restore(value)`: Called when navigating back, receives the captured state\n\nThe captured data must be JSON-serializable to persist in `sessionStorage`, allowing restoration on page reload or back navigation from external sites.\n\nExample:\n```svelte\n\u003Cscript>\n\tlet comment = $state('');\n\n\t/** @type {import('./$types').Snapshot\u003Cstring>} */\n\texport const snapshot = {\n\t\tcapture: () => comment,\n\t\trestore: (value) => comment = value\n\t};\n\u003C/script>\n\n\u003Ctextarea bind:value={comment} />\n```\n\nAvoid capturing large objects as they remain in memory for the session duration and may exceed `sessionStorage` limits.","Export a `snapshot` object with `capture()` and `restore()` methods from `+page.svelte` or `+layout.svelte` to preserve DOM state across navigation. Data must be JSON-serializable and is stored in `sessionStorage`.\n\n```svelte\nexport const snapshot = {\n\tcapture: () => state,\n\trestore: (value) => state = value\n};\n```","Preserve ephemeral DOM state across navigation using snapshot capture and restore methods.","shallow-routing",{"name":639,"path":641,"children":642,"data":643},"advanced-techniques/shallow-routing",["Map"],{"type":22,"path":644,"relevant":44,"token_counts":645,"usage":649,"markdown":652},"30-advanced/67-shallow-routing.md",{"fulltext":646,"digest":647,"short_digest":648},1335,634,169,{"input":650,"output":651,"details":32},2378,914,{"fulltext":653,"digest":654,"short_digest":655,"essence":656},"---\ntitle: Shallow routing\n---\n\nAs you navigate around a SvelteKit app, you create _history entries_. Clicking the back and forward buttons traverses through this list of entries, re-running any `load` functions and replacing page components as necessary.\n\nSometimes, it's useful to create history entries _without_ navigating. For example, you might want to show a modal dialog that the user can dismiss by navigating back. This is particularly valuable on mobile devices, where swipe gestures are often more natural than interacting directly with the UI. In these cases, a modal that is _not_ associated with a history entry can be a source of frustration, as a user may swipe backwards in an attempt to dismiss it and find themselves on the wrong page.\n\nSvelteKit makes this possible with the [`pushState`]($app-navigation#pushState) and [`replaceState`]($app-navigation#replaceState) functions, which allow you to associate state with a history entry without navigating. For example, to implement a history-driven modal:\n\n```svelte\n\u003C!--- file: +page.svelte --->\n\u003Cscript>\n\timport { pushState } from '$app/navigation';\n\timport { page } from '$app/state';\n\timport Modal from './Modal.svelte';\n\n\tfunction showModal() {\n\t\tpushState('', {\n\t\t\tshowModal: true\n\t\t});\n\t}\n\u003C/script>\n\n{#if page.state.showModal}\n\t\u003CModal close={() => history.back()} />\n{/if}\n```\n\nThe modal can be dismissed by navigating back (unsetting `page.state.showModal`) or by interacting with it in a way that causes the `close` callback to run, which will navigate back programmatically.\n\n## API\n\nThe first argument to `pushState` is the URL, relative to the current URL. To stay on the current URL, use `''`.\n\nThe second argument is the new page state, which can be accessed via the [page object]($app-state#page) as `page.state`. You can make page state type-safe by declaring an [`App.PageState`](types#PageState) interface (usually in `src/app.d.ts`).\n\nTo set page state without creating a new history entry, use `replaceState` instead of `pushState`.\n\n> [!LEGACY]\n> `page.state` from `$app/state` was added in SvelteKit 2.12. If you're using an earlier version or are using Svelte 4, use `$page.state` from `$app/stores` instead.\n\n## Loading data for a route\n\nWhen shallow routing, you may want to render another `+page.svelte` inside the current page. For example, clicking on a photo thumbnail could pop up the detail view without navigating to the photo page.\n\nFor this to work, you need to load the data that the `+page.svelte` expects. A convenient way to do this is to use [`preloadData`]($app-navigation#preloadData) inside the `click` handler of an `\u003Ca>` element. If the element (or a parent) uses [`data-sveltekit-preload-data`](link-options#data-sveltekit-preload-data), the data will have already been requested, and `preloadData` will reuse that request.\n\n```svelte\n\u003C!--- file: src/routes/photos/+page.svelte --->\n\u003Cscript>\n\timport { preloadData, pushState, goto } from '$app/navigation';\n\timport { page } from '$app/state';\n\timport Modal from './Modal.svelte';\n\timport PhotoPage from './[id]/+page.svelte';\n\n\tlet { data } = $props();\n\u003C/script>\n\n{#each data.thumbnails as thumbnail}\n\t\u003Ca\n\t\thref=\"/photos/{thumbnail.id}\"\n\t\tonclick={async (e) => {\n\t\t\tif (innerWidth \u003C 640        // bail if the screen is too small\n\t\t\t\t|| e.shiftKey             // or the link is opened in a new window\n\t\t\t\t|| e.metaKey || e.ctrlKey // or a new tab (mac: metaKey, win/linux: ctrlKey)\n\t\t\t\t// should also consider clicking with a mouse scroll wheel\n\t\t\t) return;\n\n\t\t\t// prevent navigation\n\t\t\te.preventDefault();\n\n\t\t\tconst { href } = e.currentTarget;\n\n\t\t\t// run `load` functions (or rather, get the result of the `load` functions\n\t\t\t// that are already running because of `data-sveltekit-preload-data`)\n\t\t\tconst result = await preloadData(href);\n\n\t\t\tif (result.type === 'loaded' && result.status === 200) {\n\t\t\t\tpushState(href, { selected: result.data });\n\t\t\t} else {\n\t\t\t\t// something bad happened! try navigating\n\t\t\t\tgoto(href);\n\t\t\t}\n\t\t}}\n\t>\n\t\t\u003Cimg alt={thumbnail.alt} src={thumbnail.src} />\n\t\u003C/a>\n{/each}\n\n{#if page.state.selected}\n\t\u003CModal onclose={() => history.back()}>\n\t\t\u003C!-- pass page data to the +page.svelte component,\n\t\t     just like SvelteKit would on navigation -->\n\t\t\u003CPhotoPage data={page.state.selected} />\n\t\u003C/Modal>\n{/if}\n```\n\n## Caveats\n\nDuring server-side rendering, `page.state` is always an empty object. The same is true for the first page the user lands on — if the user reloads the page (or returns from another document), state will _not_ be applied until they navigate.\n\nShallow routing is a feature that requires JavaScript to work. Be mindful when using it and try to think of sensible fallback behavior in case JavaScript isn't available.\n","## Shallow Routing\n\nCreate history entries without navigating using `pushState()` and `replaceState()` from `$app/navigation`. This enables patterns like history-driven modals that can be dismissed by navigating back.\n\n### Basic Usage\n\n```svelte\n\u003Cscript>\n\timport { pushState } from '$app/navigation';\n\timport { page } from '$app/state';\n\n\tfunction showModal() {\n\t\tpushState('', { showModal: true });\n\t}\n\u003C/script>\n\n{#if page.state.showModal}\n\t\u003CModal close={() => history.back()} />\n{/if}\n```\n\nThe first argument to `pushState` is a relative URL (use `''` to stay on current URL). The second argument is the new page state, accessible via `page.state`. Use `replaceState` instead to set state without creating a new history entry.\n\n### Loading Data for Routes\n\nWhen rendering another `+page.svelte` inside the current page via shallow routing, preload its data using `preloadData()`:\n\n```svelte\n\u003Cscript>\n\timport { preloadData, pushState, goto } from '$app/navigation';\n\timport { page } from '$app/state';\n\n\tlet { data } = $props();\n\u003C/script>\n\n{#each data.thumbnails as thumbnail}\n\t\u003Ca\n\t\thref=\"/photos/{thumbnail.id}\"\n\t\tonclick={async (e) => {\n\t\t\tif (innerWidth \u003C 640 || e.shiftKey || e.metaKey || e.ctrlKey) return;\n\t\t\te.preventDefault();\n\n\t\t\tconst result = await preloadData(e.currentTarget.href);\n\t\t\tif (result.type === 'loaded' && result.status === 200) {\n\t\t\t\tpushState(e.currentTarget.href, { selected: result.data });\n\t\t\t} else {\n\t\t\t\tgoto(e.currentTarget.href);\n\t\t\t}\n\t\t}}\n\t>\n\t\t\u003Cimg alt={thumbnail.alt} src={thumbnail.src} />\n\t\u003C/a>\n{/each}\n\n{#if page.state.selected}\n\t\u003CModal onclose={() => history.back()}>\n\t\t\u003CPhotoPage data={page.state.selected} />\n\t\u003C/Modal>\n{/if}\n```\n\nIf the link element uses `data-sveltekit-preload-data`, the data will already be requested and `preloadData` will reuse that request.\n\n### Important Notes\n\n- `page.state` is always empty during server-side rendering and on initial page load\n- Shallow routing requires JavaScript; provide fallback behavior for when it's unavailable\n- Make page state type-safe by declaring an `App.PageState` interface in `src/app.d.ts`","## Shallow Routing\n\nUse `pushState()` and `replaceState()` from `$app/navigation` to create history entries without navigating. Access state via `page.state`.\n\n```svelte\npushState('', { showModal: true });\n```\n\nFor rendering nested pages, preload data with `preloadData()` before calling `pushState()`:\n\n```svelte\nconst result = await preloadData(href);\nif (result.type === 'loaded' && result.status === 200) {\n\tpushState(href, { selected: result.data });\n}\n```\n\n**Caveats:** `page.state` is empty during SSR and on initial page load. Requires JavaScript.","Create history entries without navigating using pushState/replaceState to enable patterns like history-driven modals.","observability",{"name":657,"path":659,"children":660,"data":661},"advanced-techniques/observability",["Map"],{"type":22,"path":662,"relevant":44,"token_counts":663,"usage":667,"markdown":670},"30-advanced/68-observability.md",{"fulltext":664,"digest":665,"short_digest":666},1394,651,224,{"input":668,"output":669,"details":32},2436,1006,{"fulltext":671,"digest":672,"short_digest":673,"essence":674},"---\ntitle: Observability\n---\n\n\u003Cblockquote class=\"since note\">\n\t\u003Cp>Available since 2.31\u003C/p>\n\u003C/blockquote>\n\nSometimes, you may need to observe how your application is behaving in order to improve performance or find the root cause of a pesky bug. To help with this, SvelteKit can emit server-side [OpenTelemetry](https://opentelemetry.io) spans for the following:\n\n- The [`handle`](hooks#Server-hooks-handle) hook and `handle` functions running in a [`sequence`](@sveltejs-kit-hooks#sequence) (these will show up as children of each other and the root `handle` hook)\n- Server [`load`](load) functions and universal `load` functions when they're run on the server\n- [Form actions](form-actions)\n- [Remote functions](remote-functions)\n\nJust telling SvelteKit to emit spans won't get you far, though — you need to actually collect them somewhere to be able to view them. SvelteKit provides `src/instrumentation.server.ts` as a place to write your tracing setup and instrumentation code. It's guaranteed to be run prior to your application code being imported, providing your deployment platform supports it and your adapter is aware of it.\n\nBoth of these features are currently experimental, meaning they are likely to contain bugs and are subject to change without notice. You must opt in by adding the `kit.experimental.tracing.server` and `kit.experimental.instrumentation.server` option in your `svelte.config.js`:\n\n```js\n/// file: svelte.config.js\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\texperimental: {\n\t\t\t+++tracing: {\n\t\t\t\tserver: true\n\t\t\t},\n\t\t\tinstrumentation: {\n\t\t\t\tserver: true\n\t\t\t}+++\n\t\t}\n\t}\n};\n\nexport default config;\n```\n\n> [!NOTE] Tracing — and more significantly, observability instrumentation — can have a nontrivial overhead. Before you go all-in on tracing, consider whether or not you really need it, or if it might be more appropriate to turn it on in development and preview environments only.\n\n## Augmenting the built-in tracing\n\nSvelteKit provides access to the `root` span and the `current` span on the request event. The root span is the one associated with your root `handle` function, and the current span could be associated with `handle`, `load`, a form action, or a remote function, depending on the context. You can annotate these spans with any attributes you wish to record:\n\n```js\n/// file: $lib/authenticate.ts\n\n// @filename: ambient.d.ts\ndeclare module '$lib/auth-core' {\n\texport function getAuthenticatedUser(): Promise\u003C{ id: string }>\n}\n\n// @filename: index.js\n// ---cut---\nimport { getRequestEvent } from '$app/server';\nimport { getAuthenticatedUser } from '$lib/auth-core';\n\nasync function authenticate() {\n\tconst user = await getAuthenticatedUser();\n\tconst event = getRequestEvent();\n\tevent.tracing.root.setAttribute('userId', user.id);\n}\n```\n\n## Development quickstart\n\nTo view your first trace, you'll need to set up a local collector. We'll use [Jaeger](https://www.jaegertracing.io/docs/getting-started/) in this example, as they provide an easy-to-use quickstart command. Once your collector is running locally:\n\n- Turn on the experimental flags mentioned earlier in your `svelte.config.js` file\n- Use your package manager to install the dependencies you'll need:\n  ```sh\n  npm i @opentelemetry/sdk-node @opentelemetry/auto-instrumentations-node @opentelemetry/exporter-trace-otlp-proto import-in-the-middle\n  ```\n- Create `src/instrumentation.server.js` with the following:\n\n```js\n/// file: src/instrumentation.server.js\nimport { NodeSDK } from '@opentelemetry/sdk-node';\nimport { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';\nimport { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-proto';\nimport { createAddHookMessageChannel } from 'import-in-the-middle';\nimport { register } from 'node:module';\n\nconst { registerOptions } = createAddHookMessageChannel();\nregister('import-in-the-middle/hook.mjs', import.meta.url, registerOptions);\n\nconst sdk = new NodeSDK({\n\tserviceName: 'test-sveltekit-tracing',\n\ttraceExporter: new OTLPTraceExporter(),\n\tinstrumentations: [getNodeAutoInstrumentations()]\n});\n\nsdk.start();\n```\n\nNow, server-side requests will begin generating traces, which you can view in Jaeger's web console at [localhost:16686](http://localhost:16686).\n\n## `@opentelemetry/api`\n\nSvelteKit uses `@opentelemetry/api` to generate its spans. This is declared as an optional peer dependency so that users not needing traces see no impact on install size or runtime performance. In most cases, if you're configuring your application to collect SvelteKit's spans, you'll end up installing a library like `@opentelemetry/sdk-node` or `@vercel/otel`, which in turn depend on `@opentelemetry/api`, which will satisfy SvelteKit's dependency as well. If you see an error from SvelteKit telling you it can't find `@opentelemetry/api`, it may just be because you haven't set up your trace collection yet. If you _have_ done that and are still seeing the error, you can install `@opentelemetry/api` yourself. \n","## Observability with OpenTelemetry\n\nSvelteKit can emit server-side OpenTelemetry spans for:\n- `handle` hooks and functions in `sequence`\n- Server and universal `load` functions\n- Form actions\n- Remote functions\n\n### Setup\n\nEnable experimental features in `svelte.config.js`:\n```js\nconst config = {\n\tkit: {\n\t\texperimental: {\n\t\t\ttracing: { server: true },\n\t\t\tinstrumentation: { server: true }\n\t\t}\n\t}\n};\n```\n\nCreate `src/instrumentation.server.ts` for tracing setup and instrumentation code. This file runs before application code is imported.\n\n### Augmenting Spans\n\nAccess the root span and current span via `event.tracing`:\n```js\nimport { getRequestEvent } from '$app/server';\n\nconst event = getRequestEvent();\nevent.tracing.root.setAttribute('userId', user.id);\n```\n\nThe root span is associated with the root `handle` function. The current span depends on context (handle, load, form action, or remote function).\n\n### Local Development with Jaeger\n\n1. Install dependencies: `npm i @opentelemetry/sdk-node @opentelemetry/auto-instrumentations-node @opentelemetry/exporter-trace-otlp-proto import-in-the-middle`\n2. Create `src/instrumentation.server.js`:\n```js\nimport { NodeSDK } from '@opentelemetry/sdk-node';\nimport { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';\nimport { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-proto';\nimport { createAddHookMessageChannel } from 'import-in-the-middle';\nimport { register } from 'node:module';\n\nconst { registerOptions } = createAddHookMessageChannel();\nregister('import-in-the-middle/hook.mjs', import.meta.url, registerOptions);\n\nconst sdk = new NodeSDK({\n\tserviceName: 'test-sveltekit-tracing',\n\ttraceExporter: new OTLPTraceExporter(),\n\tinstrumentations: [getNodeAutoInstrumentations()]\n});\n\nsdk.start();\n```\n\n3. View traces at localhost:16686\n\n### Dependencies\n\nSvelteKit uses `@opentelemetry/api` as an optional peer dependency. If you see a missing dependency error, install `@opentelemetry/api` directly or use a library like `@opentelemetry/sdk-node` or `@vercel/otel` which depend on it.\n\n**Note:** Tracing has nontrivial overhead. Consider enabling only in development and preview environments.","## Observability with OpenTelemetry\n\nEnable in `svelte.config.js`:\n```js\nkit: {\n\texperimental: {\n\t\ttracing: { server: true },\n\t\tinstrumentation: { server: true }\n\t}\n}\n```\n\nSvelteKit emits spans for `handle` hooks, `load` functions, form actions, and remote functions. Create `src/instrumentation.server.ts` for tracing setup.\n\nAccess spans via `event.tracing.root` and `event.tracing.current` to add custom attributes.\n\nFor local development with Jaeger, install `@opentelemetry/sdk-node`, `@opentelemetry/auto-instrumentations-node`, `@opentelemetry/exporter-trace-otlp-proto`, and `import-in-the-middle`, then configure the NodeSDK in `src/instrumentation.server.js` to export traces to localhost:16686.","SvelteKit can emit OpenTelemetry spans for server-side operations; enable via config, set up instrumentation in src/instrumentation.server.ts, and augment spans with custom attributes.","packaging",{"name":675,"path":677,"children":678,"data":679},"advanced-techniques/packaging",["Map"],{"type":22,"path":680,"relevant":44,"token_counts":681,"usage":685,"markdown":688},"30-advanced/70-packaging.md",{"fulltext":682,"digest":683,"short_digest":684},4062,941,383,{"input":686,"output":687,"details":32},5103,1448,{"fulltext":689,"digest":690,"short_digest":691,"essence":692},"---\ntitle: Packaging\n---\n\nYou can use SvelteKit to build apps as well as component libraries, using the `@sveltejs/package` package (`npx sv create` has an option to set this up for you).\n\nWhen you're creating an app, the contents of `src/routes` is the public-facing stuff; [`src/lib`]($lib) contains your app's internal library.\n\nA component library has the exact same structure as a SvelteKit app, except that `src/lib` is the public-facing bit, and your root `package.json` is used to publish the package. `src/routes` might be a documentation or demo site that accompanies the library, or it might just be a sandbox you use during development.\n\nRunning the `svelte-package` command from `@sveltejs/package` will take the contents of `src/lib` and generate a `dist` directory (which can be [configured](#Options)) containing the following:\n\n- All the files in `src/lib`. Svelte components will be preprocessed, TypeScript files will be transpiled to JavaScript.\n- Type definitions (`d.ts` files) which are generated for Svelte, JavaScript and TypeScript files. You need to install `typescript >= 4.0.0` for this. Type definitions are placed next to their implementation, hand-written `d.ts` files are copied over as is. You can [disable generation](#Options), but we strongly recommend against it — people using your library might use TypeScript, for which they require these type definition files.\n\n> [!NOTE] `@sveltejs/package` version 1 generated a `package.json`. This is no longer the case and it will now use the `package.json` from your project and validate that it is correct instead. If you're still on version 1, see [this PR](https://github.com/sveltejs/kit/pull/8922) for migration instructions.\n\n## Anatomy of a package.json\n\nSince you're now building a library for public use, the contents of your `package.json` will become more important. Through it, you configure the entry points of your package, which files are published to npm, and which dependencies your library has. Let's go through the most important fields one by one.\n\n### name\n\nThis is the name of your package. It will be available for others to install using that name, and visible on `https://npmjs.com/package/\u003Cname>`.\n\n```json\n{\n\t\"name\": \"your-library\"\n}\n```\n\nRead more about it [here](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#name).\n\n### license\n\nEvery package should have a license field so people know how they are allowed to use it. A very popular license which is also very permissive in terms of distribution and reuse without warranty is `MIT`.\n\n```json\n{\n\t\"license\": \"MIT\"\n}\n```\n\nRead more about it [here](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#license). Note that you should also include a `LICENSE` file in your package.\n\n### files\n\nThis tells npm which files it will pack up and upload to npm. It should contain your output folder (`dist` by default). Your `package.json` and `README` and `LICENSE` will always be included, so you don't need to specify them.\n\n```json\n{\n\t\"files\": [\"dist\"]\n}\n```\n\nTo exclude unnecessary files (such as unit tests, or modules that are only imported from `src/routes` etc) you can add them to an `.npmignore` file. This will result in smaller packages that are faster to install.\n\nRead more about it [here](https://docs.npmjs.com/cli/v9/configuring-npm/package-json#files).\n\n### exports\n\nThe `\"exports\"` field contains the package's entry points. If you set up a new library project through `npx sv create`, it's set to a single export, the package root:\n\n```json\n{\n\t\"exports\": {\n\t\t\".\": {\n\t\t\t\"types\": \"./dist/index.d.ts\",\n\t\t\t\"svelte\": \"./dist/index.js\"\n\t\t}\n\t}\n}\n```\n\nThis tells bundlers and tooling that your package only has one entry point, the root, and everything should be imported through that, like this:\n\n```js\n// @errors: 2307\nimport { Something } from 'your-library';\n```\n\nThe `types` and `svelte` keys are [export conditions](https://nodejs.org/api/packages.html#conditional-exports). They tell tooling what file to import when they look up the `your-library` import:\n\n- TypeScript sees the `types` condition and looks up the type definition file. If you don't publish type definitions, omit this condition.\n- Svelte-aware tooling sees the `svelte` condition and knows this is a Svelte component library. If you publish a library that does not export any Svelte components and that could also work in non-Svelte projects (for example a Svelte store library), you can replace this condition with `default`.\n\n> [!NOTE] Previous versions of `@sveltejs/package` also added a `package.json` export. This is no longer part of the template because all tooling can now deal with a `package.json` not being explicitly exported.\n\nYou can adjust `exports` to your liking and provide more entry points. For example, if instead of a `src/lib/index.js` file that re-exported components you wanted to expose a `src/lib/Foo.svelte` component directly, you could create the following export map...\n\n```json\n{\n\t\"exports\": {\n\t\t\"./Foo.svelte\": {\n\t\t\t\"types\": \"./dist/Foo.svelte.d.ts\",\n\t\t\t\"svelte\": \"./dist/Foo.svelte\"\n\t\t}\n\t}\n}\n```\n\n...and a consumer of your library could import the component like so:\n\n```js\n// @filename: ambient.d.ts\ndeclare module 'your-library/Foo.svelte';\n\n// @filename: index.js\n// ---cut---\nimport Foo from 'your-library/Foo.svelte';\n```\n\n> [!NOTE] Beware that doing this will need additional care if you provide type definitions. Read more about the caveat [here](#TypeScript)\n\nIn general, each key of the exports map is the path the user will have to use to import something from your package, and the value is the path to the file that will be imported or a map of export conditions which in turn contains these file paths.\n\nRead more about `exports` [here](https://nodejs.org/docs/latest-v18.x/api/packages.html#package-entry-points).\n\n### svelte\n\nThis is a legacy field that enabled tooling to recognise Svelte component libraries. It's no longer necessary when using the `svelte` [export condition](#Anatomy-of-a-package.json-exports), but for backwards compatibility with outdated tooling that doesn't yet know about export conditions it's good to keep it around. It should point towards your root entry point.\n\n```json\n{\n\t\"svelte\": \"./dist/index.js\"\n}\n```\n\n### sideEffects\n\nThe `sideEffects` field in `package.json` is used by bundlers to determine if a module may contain code that has side effects. A module is considered to have side effects if it makes changes that are observable from other scripts outside the module when it's imported. For example, side effects include modifying global variables or the prototype of built-in JavaScript objects. Because a side effect could potentially affect the behavior of other parts of the application, these files/modules will be included in the final bundle regardless of whether their exports are used in the application. It is a best practice to avoid side effects in your code.\n\nSetting the `sideEffects` field in `package.json` can help the bundler to be more aggressive in eliminating unused exports from the final bundle, a process known as tree-shaking. This results in smaller and more efficient bundles. Different bundlers handle `sideEffects` in various manners. While not necessary for Vite, we recommend that libraries state that all CSS files have side effects so that your library will be [compatible with webpack](https://webpack.js.org/guides/tree-shaking/#mark-the-file-as-side-effect-free). This is the configuration that comes with newly created projects:\n\n```json\n/// file: package.json\n{\n\t\"sideEffects\": [\"**/*.css\"]\n}\n```\n\n> [!NOTE] If the scripts in your library have side effects, ensure that you update the `sideEffects` field. All scripts are marked as side effect free by default in newly created projects. If a file with side effects is incorrectly marked as having no side effects, it can result in broken functionality.\n\nIf your package has files with side effects, you can specify them in an array:\n\n```json\n/// file: package.json\n{\n    \"sideEffects\": [\n    \t\"**/*.css\",\n    \t\"./dist/sideEffectfulFile.js\"\n    ]\n}\n```\n\nThis will treat only the specified files as having side effects.\n\n## TypeScript\n\nYou should ship type definitions for your library even if you don't use TypeScript yourself so that people who do get proper intellisense when using your library. `@sveltejs/package` makes the process of generating types mostly opaque to you. By default, when packaging your library, type definitions are auto-generated for JavaScript, TypeScript and Svelte files. All you need to ensure is that the `types` condition in the [exports](#Anatomy-of-a-package.json-exports) map points to the correct files. When initialising a library project through `npx sv create`, this is automatically setup for the root export.\n\nIf you have something else than a root export however — for example providing a `your-library/foo` import — you need to take additional care for providing type definitions. Unfortunately, TypeScript by default will _not_ resolve the `types` condition for an export like `{ \"./foo\": { \"types\": \"./dist/foo.d.ts\", ... }}`. Instead, it will search for a `foo.d.ts` relative to the root of your library (i.e. `your-library/foo.d.ts` instead of `your-library/dist/foo.d.ts`). To fix this, you have two options:\n\nThe first option is to require people using your library to set the `moduleResolution` option in their `tsconfig.json` (or `jsconfig.json`) to `bundler` (available since TypeScript 5, the best and recommended option in the future), `node16` or `nodenext`. This opts TypeScript into actually looking at the exports map and resolving the types correctly.\n\nThe second option is to (ab)use the `typesVersions` feature from TypeScript to wire up the types. This is a field inside `package.json` TypeScript uses to check for different type definitions depending on the TypeScript version, and also contains a path mapping feature for that. We leverage that path mapping feature to get what we want. For the mentioned `foo` export above, the corresponding `typesVersions` looks like this:\n\n```json\n{\n\t\"exports\": {\n\t\t\"./foo\": {\n\t\t\t\"types\": \"./dist/foo.d.ts\",\n\t\t\t\"svelte\": \"./dist/foo.js\"\n\t\t}\n\t},\n\t\"typesVersions\": {\n\t\t\">4.0\": {\n\t\t\t\"foo\": [\"./dist/foo.d.ts\"]\n\t\t}\n\t}\n}\n```\n\n`>4.0` tells TypeScript to check the inner map if the used TypeScript version is greater than 4 (which should in practice always be true). The inner map tells TypeScript that the typings for `your-library/foo` are found within `./dist/foo.d.ts`, which essentially replicates the `exports` condition. You also have `*` as a wildcard at your disposal to make many type definitions at once available without repeating yourself. Note that if you opt into `typesVersions` you have to declare all type imports through it, including the root import (which is defined as `\"index.d.ts\": [..]`).\n\nYou can read more about that feature [here](https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html#version-selection-with-typesversions).\n\n## Best practices\n\nYou should avoid using SvelteKit-specific modules like `$app/environment` in your packages unless you intend for them to only be consumable by other SvelteKit projects. E.g. rather than using `import { browser } from '$app/environment'` you could use `import { BROWSER } from 'esm-env'` ([see esm-env docs](https://github.com/benmccann/esm-env)). You may also wish to pass in things like the current URL or a navigation action as a prop rather than relying directly on `$app/state`, `$app/navigation`, etc. Writing your app in this more generic fashion will also make it easier to setup tools for testing, UI demos and so on.\n\nEnsure that you add [aliases](configuration#alias) via `svelte.config.js` (not `vite.config.js` or `tsconfig.json`), so that they are processed by `svelte-package`.\n\nYou should think carefully about whether or not the changes you make to your package are a bug fix, a new feature, or a breaking change, and update the package version accordingly. Note that if you remove any paths from `exports` or any `export` conditions inside them from your existing library, that should be regarded as a breaking change.\n\n```json\n{\n\t\"exports\": {\n\t\t\".\": {\n\t\t\t\"types\": \"./dist/index.d.ts\",\n// changing `svelte` to `default` is a breaking change:\n---\t\t\t\"svelte\": \"./dist/index.js\"---\n+++\t\t\t\"default\": \"./dist/index.js\"+++\n\t\t},\n// removing this is a breaking change:\n---\t\t\"./foo\": {\n\t\t\t\"types\": \"./dist/foo.d.ts\",\n\t\t\t\"svelte\": \"./dist/foo.js\",\n\t\t\t\"default\": \"./dist/foo.js\"\n\t\t},---\n// adding this is ok:\n+++\t\t\"./bar\": {\n\t\t\t\"types\": \"./dist/bar.d.ts\",\n\t\t\t\"svelte\": \"./dist/bar.js\",\n\t\t\t\"default\": \"./dist/bar.js\"\n\t\t}+++\n\t}\n}\n```\n\n## Source maps\n\nYou can create so-called declaration maps (`d.ts.map` files) by setting `\"declarationMap\": true` in your `tsconfig.json`. This will allow editors such as VS Code to go to the original `.ts` or `.svelte` file when using features like _Go to Definition_. This means you also need to publish your source files alongside your dist folder in a way that the relative path inside the declaration files leads to a file on disk. Assuming that you have all your library code inside `src/lib` as suggested by Svelte's CLI, this is as simple as adding `src/lib` to `files` in your `package.json`:\n\n```json\n{\n\t\"files\": [\n\t\t\"dist\",\n\t\t\"!dist/**/*.test.*\",\n\t\t\"!dist/**/*.spec.*\",\n\t\t+++\"src/lib\",\n\t\t\"!src/lib/**/*.test.*\",\n\t\t\"!src/lib/**/*.spec.*\"+++\n\t]\n}\n```\n\n## Options\n\n`svelte-package` accepts the following options:\n\n- `-w`/`--watch` — watch files in `src/lib` for changes and rebuild the package\n- `-i`/`--input` — the input directory which contains all the files of the package. Defaults to `src/lib`\n- `-o`/`--output` — the output directory where the processed files are written to. Your `package.json`'s `exports` should point to files inside there, and the `files` array should include that folder. Defaults to `dist`\n- `-p`/`--preserve-output` — prevent deletion of the output directory before packaging. Defaults to `false`, which means that the output directory will be emptied first\n- `-t`/`--types` — whether or not to create type definitions (`d.ts` files). We strongly recommend doing this as it fosters ecosystem library quality. Defaults to `true`\n- `--tsconfig` - the path to a tsconfig or jsconfig. When not provided, searches for the next upper tsconfig/jsconfig in the workspace path.\n\n## Publishing\n\nTo publish the generated package:\n\n```sh\nnpm publish\n```\n\n## Caveats\n\nAll relative file imports need to be fully specified, adhering to Node's ESM algorithm. This means that for a file like `src/lib/something/index.js`, you must include the filename with the extension:\n\n```js\n// @errors: 2307\nimport { something } from './something+++/index.js+++';\n```\n\nIf you are using TypeScript, you need to import `.ts` files the same way, but using a `.js` file ending, _not_ a `.ts` file ending. (This is a TypeScript design decision outside our control.) Setting `\"moduleResolution\": \"NodeNext\"` in your `tsconfig.json` or `jsconfig.json` will help you with this.\n\nAll files except Svelte files (preprocessed) and TypeScript files (transpiled to JavaScript) are copied across as-is.\n","## Building Component Libraries\n\nUse `@sveltejs/package` to build component libraries. Structure: `src/lib` is public-facing, `src/routes` is optional documentation/demo, `package.json` is used for publishing.\n\nRunning `svelte-package` generates a `dist` directory containing:\n- All files from `src/lib` (Svelte components preprocessed, TypeScript transpiled to JavaScript)\n- Auto-generated type definitions (`d.ts` files) for all files\n\n## package.json Configuration\n\n**name** — Package name on npm\n```json\n{ \"name\": \"your-library\" }\n```\n\n**license** — Recommended: `MIT`\n\n**files** — Which files npm publishes (should include `dist`)\n```json\n{ \"files\": [\"dist\"] }\n```\n\n**exports** — Entry points for the package\n```json\n{\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"svelte\": \"./dist/index.js\"\n    }\n  }\n}\n```\n\nThe `types` condition points to type definitions, `svelte` condition indicates Svelte component library. You can define multiple entry points:\n```json\n{\n  \"exports\": {\n    \"./Foo.svelte\": {\n      \"types\": \"./dist/Foo.svelte.d.ts\",\n      \"svelte\": \"./dist/Foo.svelte\"\n    }\n  }\n}\n```\n\n**svelte** — Legacy field for backwards compatibility, points to root entry point\n\n**sideEffects** — Helps bundlers with tree-shaking. Mark CSS files as having side effects for webpack compatibility:\n```json\n{ \"sideEffects\": [\"**/*.css\"] }\n```\n\n## TypeScript\n\nType definitions are auto-generated. For non-root exports, TypeScript won't resolve the `types` condition by default. Solutions:\n1. Require consumers to set `moduleResolution` to `bundler`, `node16`, or `nodenext` in their tsconfig\n2. Use `typesVersions` field to map types:\n```json\n{\n  \"exports\": { \"./foo\": { \"types\": \"./dist/foo.d.ts\", \"svelte\": \"./dist/foo.js\" } },\n  \"typesVersions\": { \">4.0\": { \"foo\": [\"./dist/foo.d.ts\"] } }\n}\n```\n\n## Best Practices\n\n- Avoid SvelteKit-specific modules like `$app/environment`. Use `esm-env` instead or pass values as props\n- Define aliases in `svelte.config.js`, not `vite.config.js` or `tsconfig.json`\n- Treat removal of export paths or conditions as breaking changes\n- Enable declaration maps with `\"declarationMap\": true` in tsconfig and include `src/lib` in `files` array for source navigation\n\n## Source Maps\n\nCreate declaration maps (`d.ts.map` files) for editor \"Go to Definition\" support:\n```json\n{\n  \"files\": [\"dist\", \"!dist/**/*.test.*\", \"src/lib\", \"!src/lib/**/*.test.*\"]\n}\n```\n\n## svelte-package Options\n\n- `-w`/`--watch` — Watch for changes\n- `-i`/`--input` — Input directory (default: `src/lib`)\n- `-o`/`--output` — Output directory (default: `dist`)\n- `-p`/`--preserve-output` — Don't delete output before packaging\n- `-t`/`--types` — Generate type definitions (default: `true`)\n- `--tsconfig` — Path to tsconfig/jsconfig\n\n## Publishing\n\n```sh\nnpm publish\n```\n\n## Caveats\n\n- All relative imports must be fully specified with file extensions per Node's ESM algorithm: `import { x } from './something/index.js'`\n- TypeScript imports must use `.js` extension, not `.ts`\n- Non-Svelte and non-TypeScript files are copied as-is","## Building Component Libraries\n\nUse `@sveltejs/package` to build libraries with `src/lib` as public-facing code. Generates `dist` with preprocessed components and auto-generated type definitions.\n\n## package.json Configuration\n\n**exports** — Define entry points with `types` and `svelte` conditions:\n```json\n{\n  \"exports\": {\n    \".\": { \"types\": \"./dist/index.d.ts\", \"svelte\": \"./dist/index.js\" },\n    \"./Foo.svelte\": { \"types\": \"./dist/Foo.svelte.d.ts\", \"svelte\": \"./dist/Foo.svelte\" }\n  }\n}\n```\n\n**files** — Include `dist` folder\n**license** — Recommended: `MIT`\n**sideEffects** — Mark CSS as having side effects: `[\"**/*.css\"]`\n\n## TypeScript\n\nType definitions auto-generate. For non-root exports, use `typesVersions` to map types:\n```json\n{\n  \"typesVersions\": { \">4.0\": { \"foo\": [\"./dist/foo.d.ts\"] } }\n}\n```\n\n## Best Practices\n\n- Avoid SvelteKit-specific modules; use `esm-env` or pass values as props\n- Define aliases in `svelte.config.js`\n- Removing export paths/conditions is a breaking change\n- Enable declaration maps for source navigation\n\n## Caveats\n\n- All relative imports need full paths with extensions: `import { x } from './something/index.js'`\n- TypeScript imports use `.js` extension, not `.ts`","How to build and publish component libraries with SvelteKit using @sveltejs/package, configuring package.json exports, handling TypeScript definitions, and best practices.","advanced",{"name":693,"path":695,"children":696,"data":697},"advanced-techniques/advanced",["Map"],{"type":22,"path":698,"relevant":24,"token_counts":699,"usage":703,"markdown":705},"30-advanced/index.md",{"fulltext":700,"digest":701,"short_digest":702},14,40,17,{"input":136,"output":704,"details":32},153,{"fulltext":706,"digest":707,"short_digest":708,"essence":709},"---\ntitle: Advanced\n---\n","This page serves as an index or landing page for advanced topics in SvelteKit documentation. It appears to be a section header with no substantive content provided.","Index page for advanced SvelteKit topics.","Landing page for advanced SvelteKit documentation section.",{"type":129,"path":711,"relevant":44,"token_counts":712,"usage":716,"markdown":719},"30-advanced",{"fulltext":713,"digest":714,"short_digest":715},2274,1415,508,{"input":717,"output":718,"details":32},3434,2041,{"fulltext":720,"digest":721,"short_digest":722,"essence":723},"\n\n## Pages\n\n### advanced-routing\nAdvanced routing techniques including rest parameters, optional parameters, matchers, route sorting, character encoding, and layout grouping.\n\n## Rest Parameters\n`[...file]` matches variable segments: `/[org]/[repo]/tree/[branch]/[...file]` with `/sveltejs/kit/tree/main/docs/file.md` gives `file: 'docs/file.md'`.\n\n## Optional Parameters\n`[[lang]]/home` matches both `home` and `en/home`.\n\n## Matching\nCreate `src/params/fruit.js` with `match(param)` function, use `[page=fruit]` in routes.\n\n## Sorting\nSpecificity > matchers > optional/rest > alphabetical. `/foo-abc` matches `foo-abc/+page.svelte` before `foo-[c]/+page.svelte`.\n\n## Encoding\n`[x+3a]` for `:`, `[x+2f]` for `/`. `/smileys/:-)` becomes `src/routes/smileys/[x+3a]-[x+29]/+page.svelte`.\n\n## Layout Groups\n`(app)` and `(marketing)` organize routes without URL changes. Use `+page@(app).svelte` to inherit from `(app)` layout only.\n\n### hooks\nApp-wide functions that hook into SvelteKit lifecycle events for request handling, error management, routing, and type serialization.\n\n## Server Hooks\n\n**handle** — Intercepts every request. Modify response or bypass SvelteKit. Supports `transformPageChunk`, `filterSerializedResponseHeaders`, `preload` options.\n\n**handleFetch** — Intercepts `event.fetch` calls. Redirect API URLs or forward cookies.\n\n**handleValidationError** — Customize validation error responses.\n\n## Shared Hooks\n\n**handleError** — Log errors and return safe representation for `$page.error`.\n\n**init** — Async initialization on startup.\n\n## Universal Hooks\n\n**reroute** — Translate URLs to routes (can be async).\n\n**transport** — Encode/decode custom types across server/client boundary.\n\nFiles: `src/hooks.server.js`, `src/hooks.client.js`, `src/hooks.js`\n\n### errors\nHow to handle expected and unexpected errors in SvelteKit, customize error objects, and control error page rendering.\n\n## Expected vs Unexpected Errors\n\n**Expected errors** use the `error()` helper to throw exceptions that SvelteKit catches and renders with `+error.svelte`:\n\n```js\nimport { error } from '@sveltejs/kit';\nerror(404, 'Not found');\n// or with custom properties:\nerror(404, { message: 'Not found', code: 'NOT_FOUND' });\n```\n\n**Unexpected errors** are other exceptions. They show a generic message to users and pass through the `handleError` hook for custom handling.\n\n## Type Safety\n\nDeclare custom error properties in `src/app.d.ts`:\n\n```ts\ndeclare global {\n\tnamespace App {\n\t\tinterface Error {\n\t\t\tcode: string;\n\t\t\tid: string;\n\t\t}\n\t}\n}\n```\n\n## Error Responses\n\nCustomize the fallback error page with `src/error.html` using `%sveltekit.status%` and `%sveltekit.error.message%` placeholders. Errors in `load` functions render the nearest `+error.svelte`, except in root layouts which use the fallback page.\n\n### link-options\nCustomize SvelteKit link navigation behavior using data-sveltekit-* attributes for preloading, history management, focus, and scroll control.\n\n## Link Navigation Attributes\n\nControl SvelteKit link behavior with `data-sveltekit-*` attributes:\n\n- **data-sveltekit-preload-data**: `\"hover\"` (default) or `\"tap\"` — when to preload page data\n- **data-sveltekit-preload-code**: `\"eager\"`, `\"viewport\"`, `\"hover\"`, or `\"tap\"` — when to preload code\n- **data-sveltekit-reload**: force full-page browser navigation\n- **data-sveltekit-replacestate**: replace history entry instead of pushing new one\n- **data-sveltekit-keepfocus**: retain focus after navigation\n- **data-sveltekit-noscroll**: prevent scroll to top after navigation\n\nDisable with `\"false\"` value. Respects `navigator.connection.saveData`.\n\n### service-workers\nHow to implement and configure service workers in SvelteKit for offline support and performance optimization.\n\nSvelteKit automatically registers `src/service-worker.js` for offline support and performance. Access `$service-worker` module for build files, static assets, version, and base path. Implement install/activate/fetch handlers to cache assets and handle offline requests. Use version string for unique cache names. Disable auto-registration via config if needed. In dev, use `{ type: 'module' }` for manual registration.\n\n### server-only-modules\nPrevent accidental exposure of sensitive data to the browser by marking modules as server-only using .server suffix or $lib/server/ directory.\n\nMark modules as server-only using `.server` filename suffix or `$lib/server/` directory to prevent sensitive data leaking to the browser. SvelteKit errors if any import chain from client code reaches server-only modules, even indirectly or through unused exports.\n\n### snapshots\nPreserve ephemeral DOM state across navigation using snapshot capture and restore methods.\n\nExport a `snapshot` object with `capture()` and `restore()` methods from `+page.svelte` or `+layout.svelte` to preserve DOM state across navigation. Data must be JSON-serializable and is stored in `sessionStorage`.\n\n```svelte\nexport const snapshot = {\n\tcapture: () => state,\n\trestore: (value) => state = value\n};\n```\n\n### shallow-routing\nCreate history entries without navigating using pushState/replaceState to enable patterns like history-driven modals.\n\n## Shallow Routing\n\nUse `pushState()` and `replaceState()` from `$app/navigation` to create history entries without navigating. Access state via `page.state`.\n\n```svelte\npushState('', { showModal: true });\n```\n\nFor rendering nested pages, preload data with `preloadData()` before calling `pushState()`:\n\n```svelte\nconst result = await preloadData(href);\nif (result.type === 'loaded' && result.status === 200) {\n\tpushState(href, { selected: result.data });\n}\n```\n\n**Caveats:** `page.state` is empty during SSR and on initial page load. Requires JavaScript.\n\n### observability\nSvelteKit can emit OpenTelemetry spans for server-side operations; enable via config, set up instrumentation in src/instrumentation.server.ts, and augment spans with custom attributes.\n\n## Observability with OpenTelemetry\n\nEnable in `svelte.config.js`:\n```js\nkit: {\n\texperimental: {\n\t\ttracing: { server: true },\n\t\tinstrumentation: { server: true }\n\t}\n}\n```\n\nSvelteKit emits spans for `handle` hooks, `load` functions, form actions, and remote functions. Create `src/instrumentation.server.ts` for tracing setup.\n\nAccess spans via `event.tracing.root` and `event.tracing.current` to add custom attributes.\n\nFor local development with Jaeger, install `@opentelemetry/sdk-node`, `@opentelemetry/auto-instrumentations-node`, `@opentelemetry/exporter-trace-otlp-proto`, and `import-in-the-middle`, then configure the NodeSDK in `src/instrumentation.server.js` to export traces to localhost:16686.\n\n### packaging\nHow to build and publish component libraries with SvelteKit using @sveltejs/package, configuring package.json exports, handling TypeScript definitions, and best practices.\n\n## Building Component Libraries\n\nUse `@sveltejs/package` to build libraries with `src/lib` as public-facing code. Generates `dist` with preprocessed components and auto-generated type definitions.\n\n## package.json Configuration\n\n**exports** — Define entry points with `types` and `svelte` conditions:\n```json\n{\n  \"exports\": {\n    \".\": { \"types\": \"./dist/index.d.ts\", \"svelte\": \"./dist/index.js\" },\n    \"./Foo.svelte\": { \"types\": \"./dist/Foo.svelte.d.ts\", \"svelte\": \"./dist/Foo.svelte\" }\n  }\n}\n```\n\n**files** — Include `dist` folder\n**license** — Recommended: `MIT`\n**sideEffects** — Mark CSS as having side effects: `[\"**/*.css\"]`\n\n## TypeScript\n\nType definitions auto-generate. For non-root exports, use `typesVersions` to map types:\n```json\n{\n  \"typesVersions\": { \">4.0\": { \"foo\": [\"./dist/foo.d.ts\"] } }\n}\n```\n\n## Best Practices\n\n- Avoid SvelteKit-specific modules; use `esm-env` or pass values as props\n- Define aliases in `svelte.config.js`\n- Removing export paths/conditions is a breaking change\n- Enable declaration maps for source navigation\n\n## Caveats\n\n- All relative imports need full paths with extensions: `import { x } from './something/index.js'`\n- TypeScript imports use `.js` extension, not `.ts`\n\n","## Routing\n\n**Rest Parameters** — `[...file]` captures variable segments: `/[org]/[repo]/tree/[branch]/[...file]` matches `/sveltejs/kit/tree/main/docs/file.md` with `file: 'docs/file.md'`.\n\n**Optional Parameters** — `[[lang]]/home` matches both `home` and `en/home`.\n\n**Matchers** — Create `src/params/fruit.js` with `match(param)` function, use `[page=fruit]` in routes.\n\n**Route Sorting** — Specificity > matchers > optional/rest > alphabetical.\n\n**Encoding** — Use `[x+3a]` for `:`, `[x+2f]` for `/`. `/smileys/:-)` becomes `src/routes/smileys/[x+3a]-[x+29]/+page.svelte`.\n\n**Layout Groups** — `(app)` and `(marketing)` organize routes without URL changes. Use `+page@(app).svelte` to inherit from specific layout.\n\n## Hooks\n\n**Server Hooks** — `handle` intercepts every request; `handleFetch` intercepts `event.fetch` calls; `handleValidationError` customizes validation errors.\n\n**Shared Hooks** — `handleError` logs errors and returns safe representation for `$page.error`.\n\n**Universal Hooks** — `reroute` translates URLs to routes; `transport` encodes/decodes custom types across server/client.\n\nFiles: `src/hooks.server.js`, `src/hooks.client.js`, `src/hooks.js`\n\n## Error Handling\n\n**Expected Errors** — Use `error(404, 'Not found')` or `error(404, { message: 'Not found', code: 'NOT_FOUND' })` to throw exceptions SvelteKit catches and renders with `+error.svelte`.\n\n**Unexpected Errors** — Other exceptions show generic message to users and pass through `handleError` hook.\n\n**Type Safety** — Declare custom error properties in `src/app.d.ts`:\n```ts\ndeclare global {\n\tnamespace App {\n\t\tinterface Error {\n\t\t\tcode: string;\n\t\t\tid: string;\n\t\t}\n\t}\n}\n```\n\n**Fallback Page** — Customize with `src/error.html` using `%sveltekit.status%` and `%sveltekit.error.message%` placeholders.\n\n## Link Navigation\n\nControl behavior with `data-sveltekit-*` attributes:\n- `data-sveltekit-preload-data`: `\"hover\"` or `\"tap\"`\n- `data-sveltekit-preload-code`: `\"eager\"`, `\"viewport\"`, `\"hover\"`, or `\"tap\"`\n- `data-sveltekit-reload`: force full-page navigation\n- `data-sveltekit-replacestate`: replace history entry\n- `data-sveltekit-keepfocus`: retain focus after navigation\n- `data-sveltekit-noscroll`: prevent scroll to top\n\nDisable with `\"false\"` value.\n\n## Service Workers\n\nSvelteKit automatically registers `src/service-worker.js`. Access `$service-worker` module for build files, static assets, version, and base path. Implement install/activate/fetch handlers to cache assets and handle offline requests. Use version string for unique cache names. Disable auto-registration via config if needed.\n\n## Server-Only Modules\n\nMark modules as server-only using `.server` filename suffix or `$lib/server/` directory to prevent sensitive data leaking to browser. SvelteKit errors if any import chain from client code reaches server-only modules.\n\n## Snapshots\n\nExport `snapshot` object with `capture()` and `restore()` methods from `+page.svelte` or `+layout.svelte` to preserve DOM state across navigation:\n```svelte\nexport const snapshot = {\n\tcapture: () => state,\n\trestore: (value) => state = value\n};\n```\n\n## Shallow Routing\n\nUse `pushState()` and `replaceState()` from `$app/navigation` to create history entries without navigating:\n```svelte\npushState('', { showModal: true });\n```\n\nPreload data before pushing state:\n```svelte\nconst result = await preloadData(href);\nif (result.type === 'loaded' && result.status === 200) {\n\tpushState(href, { selected: result.data });\n}\n```\n\n**Caveats** — `page.state` is empty during SSR and initial page load. Requires JavaScript.\n\n## Observability\n\nEnable OpenTelemetry in `svelte.config.js`:\n```js\nkit: {\n\texperimental: {\n\t\ttracing: { server: true },\n\t\tinstrumentation: { server: true }\n\t}\n}\n```\n\nCreate `src/instrumentation.server.ts` for tracing setup. SvelteKit emits spans for `handle` hooks, `load` functions, form actions, and remote functions. Access spans via `event.tracing.root` and `event.tracing.current`.\n\n## Component Libraries\n\nUse `@sveltejs/package` to build libraries with `src/lib` as public-facing code. Configure `package.json` exports with `types` and `svelte` conditions:\n```json\n{\n  \"exports\": {\n    \".\": { \"types\": \"./dist/index.d.ts\", \"svelte\": \"./dist/index.js\" },\n    \"./Foo.svelte\": { \"types\": \"./dist/Foo.svelte.d.ts\", \"svelte\": \"./dist/Foo.svelte\" }\n  }\n}\n```\n\nInclude `dist` folder in `files`. Mark CSS as having side effects: `[\"**/*.css\"]`. Type definitions auto-generate. Avoid SvelteKit-specific modules; use `esm-env` or pass values as props. All relative imports need full paths with extensions.","## Routing\n\n**Rest/Optional Parameters** — `[...file]` captures segments; `[[lang]]` makes optional.\n\n**Matchers** — Create `src/params/fruit.js` with `match()`, use `[page=fruit]` in routes.\n\n**Layout Groups** — `(app)` organizes routes without URL changes; use `+page@(app).svelte` for specific layout.\n\n**Encoding** — `[x+3a]` for `:`, `[x+2f]` for `/`.\n\n## Hooks\n\n`handle` intercepts requests; `handleFetch` intercepts `event.fetch`; `handleError` logs errors; `reroute` translates URLs; `transport` encodes/decodes custom types.\n\n## Error Handling\n\n`error(404, 'Not found')` throws expected errors rendered by `+error.svelte`. Declare custom error properties in `src/app.d.ts`. Customize fallback with `src/error.html`.\n\n## Link Navigation\n\n`data-sveltekit-preload-data`, `data-sveltekit-reload`, `data-sveltekit-replacestate`, `data-sveltekit-keepfocus`, `data-sveltekit-noscroll` control behavior.\n\n## Service Workers\n\nAuto-registers `src/service-worker.js`. Access `$service-worker` module for build files and version.\n\n## Server-Only Modules\n\nUse `.server` suffix or `$lib/server/` directory to prevent sensitive data leaking to browser.\n\n## Snapshots\n\nExport `snapshot` with `capture()` and `restore()` to preserve DOM state across navigation.\n\n## Shallow Routing\n\n`pushState('', { showModal: true })` creates history entries without navigating. Preload data with `preloadData()` first.\n\n## Observability\n\nEnable OpenTelemetry in config. Create `src/instrumentation.server.ts`. Access spans via `event.tracing.root`.\n\n## Component Libraries\n\nUse `@sveltejs/package`. Configure `package.json` exports with `types` and `svelte` conditions. Type definitions auto-generate.","Advanced SvelteKit patterns for routing, hooks, error handling, navigation, service workers, security, state preservation, observability, and library packaging.","best-practices",{"name":724,"path":724,"children":726,"data":847},["Map",727,728,744,745,762,763,780,781,798,799,815,816,724,833],"authentication-and-authorization",{"name":727,"path":729,"children":730,"data":731},"best-practices/authentication-and-authorization",["Map"],{"type":22,"path":732,"relevant":44,"token_counts":733,"usage":737,"markdown":739},"40-best-practices/03-auth.md",{"fulltext":734,"digest":735,"short_digest":736},456,179,71,{"input":632,"output":738,"details":32},364,{"fulltext":740,"digest":741,"short_digest":742,"essence":743},"---\ntitle: Auth\n---\n\nAuth refers to authentication and authorization, which are common needs when building a web application. Authentication means verifying that the user is who they say they are based on their provided credentials. Authorization means determining which actions they are allowed to take.\n\n## Sessions vs tokens\n\nAfter the user has provided their credentials such as a username and password, we want to allow them to use the application without needing to provide their credentials again for future requests. Users are commonly authenticated on subsequent requests with either a session identifier or signed token such as a JSON Web Token (JWT).\n\nSession IDs are most commonly stored in a database. They can be immediately revoked, but require a database query to be made on each request.\n\nIn contrast, JWT generally are not checked against a datastore, which means they cannot be immediately revoked. The advantage of this method is improved latency and reduced load on your datastore.\n\n## Integration points\n\nAuth [cookies](@sveltejs-kit#Cookies) can be checked inside [server hooks](hooks#Server-hooks). If a user is found matching the provided credentials, the user information can be stored in [`locals`](hooks#Server-hooks-locals).\n\n## Guides\n\n[Lucia](https://lucia-auth.com/) is a good reference for session-based web app auth. It contains example code snippets and projects for implementing session-based auth within SvelteKit and other JS projects. You can add code which follows the Lucia guide to your project with `npx sv create` when creating a new project or `npx sv add lucia` for an existing project.\n\nAn auth system is tightly coupled to a web framework because most of the code lies in validating user input, handling errors, and directing users to the appropriate next page. As a result, many of the generic JS auth libraries include one or more web frameworks within them. For this reason, many users will find it preferrable to follow a SvelteKit-specific guide such as the examples found in [Lucia](https://lucia-auth.com/) rather than having multiple web frameworks inside their project.\n","## Sessions vs Tokens\n\n**Session IDs**: Stored in database, can be immediately revoked, but require a database query on each request.\n\n**JWT**: Not checked against datastore, cannot be immediately revoked, but offer improved latency and reduced datastore load.\n\n## Implementation in SvelteKit\n\nAuth cookies can be checked inside server hooks. When a user matches provided credentials, store user information in `locals` via server hooks.\n\n## Framework-Specific Approach\n\nUse framework-specific auth libraries like Lucia rather than generic JS auth libraries, since auth is tightly coupled to the web framework. Most auth code involves validating user input, handling errors, and routing users appropriately. Lucia provides session-based auth examples and can be added via `npx sv add lucia` to existing projects.","**Sessions vs JWT**: Sessions are revocable but require DB queries; JWT offer better latency but can't be revoked.\n\n**SvelteKit Integration**: Check auth cookies in server hooks, store user info in `locals`.\n\n**Use framework-specific libraries** like Lucia for auth implementation.","Authentication and authorization strategies in SvelteKit: comparing sessions vs tokens, integration via server hooks, and using framework-specific libraries.","performance",{"name":744,"path":746,"children":747,"data":748},"best-practices/performance",["Map"],{"type":22,"path":749,"relevant":44,"token_counts":750,"usage":754,"markdown":757},"40-best-practices/05-performance.md",{"fulltext":751,"digest":752,"short_digest":753},2510,571,351,{"input":755,"output":756,"details":32},3553,1039,{"fulltext":758,"digest":759,"short_digest":760,"essence":761},"---\ntitle: Performance\n---\n\nOut of the box, SvelteKit does a lot of work to make your applications as performant as possible:\n\n- Code-splitting, so that only the code you need for the current page is loaded\n- Asset preloading, so that 'waterfalls' (of files requesting other files) are prevented\n- File hashing, so that your assets can be cached forever\n- Request coalescing, so that data fetched from separate server `load` functions is grouped into a single HTTP request\n- Parallel loading, so that separate universal `load` functions fetch data simultaneously\n- Data inlining, so that requests made with `fetch` during server rendering can be replayed in the browser without issuing a new request\n- Conservative invalidation, so that `load` functions are only re-run when necessary\n- Prerendering (configurable on a per-route basis, if necessary) so that pages without dynamic data can be served instantaneously\n- Link preloading, so that data and code requirements for a client-side navigation are eagerly anticipated\n\nNevertheless, we can't (yet) eliminate all sources of slowness. To eke out maximum performance, you should be mindful of the following tips.\n\n## Diagnosing issues\n\nGoogle's [PageSpeed Insights](https://pagespeed.web.dev/) and (for more advanced analysis) [WebPageTest](https://www.webpagetest.org/) are excellent ways to understand the performance characteristics of a site that is already deployed to the internet.\n\nYour browser also includes useful developer tools for analysing your site, whether deployed or running locally:\n\n* Chrome - [Lighthouse](https://developer.chrome.com/docs/lighthouse/overview#devtools), [Network](https://developer.chrome.com/docs/devtools/network), and [Performance](https://developer.chrome.com/docs/devtools/performance) devtools\n* Edge - [Lighthouse](https://learn.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium/lighthouse/lighthouse-tool), [Network](https://learn.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium/network/), and [Performance](https://learn.microsoft.com/en-us/microsoft-edge/devtools-guide-chromium/evaluate-performance/) devtools\n* Firefox - [Network](https://firefox-source-docs.mozilla.org/devtools-user/network_monitor/) and [Performance](https://hacks.mozilla.org/2022/03/performance-tool-in-firefox-devtools-reloaded/) devtools\n* Safari - [enhancing the performance of your webpage](https://developer.apple.com/library/archive/documentation/NetworkingInternetWeb/Conceptual/Web_Inspector_Tutorial/EnhancingyourWebpagesPerformance/EnhancingyourWebpagesPerformance.html)\n\nNote that your site running locally in `dev` mode will exhibit different behaviour than your production app, so you should do performance testing in [preview](building-your-app#Preview-your-app) mode after building.\n\n### Instrumenting\n\nIf you see in the network tab of your browser that an API call is taking a long time and you'd like to understand why, you may consider instrumenting your backend with a tool like [OpenTelemetry](https://opentelemetry.io/) or [Server-Timing headers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Server-Timing).\n\n## Optimizing assets\n\n### Images\n\nReducing the size of image files is often one of the most impactful changes you can make to a site's performance. Svelte provides the `@sveltejs/enhanced-img` package, detailed on the [images](images) page, for making this easier. Additionally, Lighthouse is useful for identifying the worst offenders.\n\n### Videos\n\nVideo files can be very large, so extra care should be taken to ensure that they're optimized:\n\n- Compress videos with tools such as [Handbrake](https://handbrake.fr/). Consider converting the videos to web-friendly formats such as `.webm` or `.mp4`.\n- You can [lazy-load videos](https://web.dev/articles/lazy-loading-video) located below the fold with `preload=\"none\"` (though note that this will slow down playback when the user _does_ initiate it).\n- Strip the audio track out of muted videos using a tool like [FFmpeg](https://ffmpeg.org/).\n\n### Fonts\n\nSvelteKit automatically preloads critical `.js` and `.css` files when the user visits a page, but it does _not_ preload fonts by default, since this may cause unnecessary files (such as font weights that are referenced by your CSS but not actually used on the current page) to be downloaded. Having said that, preloading fonts correctly can make a big difference to how fast your site feels. In your [`handle`](hooks#Server-hooks-handle) hook, you can call `resolve` with a `preload` filter that includes your fonts.\n\nYou can reduce the size of font files by [subsetting](https://web.dev/learn/performance/optimize-web-fonts#subset_your_web_fonts) your fonts.\n\n## Reducing code size\n\n### Svelte version\n\nWe recommend running the latest version of Svelte. Svelte 5 is smaller and faster than Svelte 4, which is smaller and faster than Svelte 3.\n\n### Packages\n\n[`rollup-plugin-visualizer`](https://www.npmjs.com/package/rollup-plugin-visualizer) can be helpful for identifying which packages are contributing the most to the size of your site. You may also find opportunities to remove code by manually inspecting the build output (use `build: { minify: false }` in your [Vite config](https://vitejs.dev/config/build-options.html#build-minify) to make the output readable, but remember to undo that before deploying your app), or via the network tab of your browser's devtools.\n\n### External scripts\n\nTry to minimize the number of third-party scripts running in the browser. For example, instead of using JavaScript-based analytics consider using server-side implementations, such as those offered by many platforms with SvelteKit adapters including [Cloudflare](https://www.cloudflare.com/web-analytics/), [Netlify](https://docs.netlify.com/monitor-sites/site-analytics/), and [Vercel](https://vercel.com/docs/analytics).\n\nTo run third party scripts in a web worker (which avoids blocking the main thread), use [Partytown's SvelteKit integration](https://partytown.builder.io/sveltekit).\n\n### Selective loading\n\nCode imported with static `import` declarations will be automatically bundled with the rest of your page. If there is a piece of code you need only when some condition is met, use the dynamic `import(...)` form to selectively lazy-load the component.\n\n## Navigation\n\n### Preloading\n\nYou can speed up client-side navigations by eagerly preloading the necessary code and data, using [link options](link-options). This is configured by default on the `\u003Cbody>` element when you create a new SvelteKit app.\n\n### Non-essential data\n\nFor slow-loading data that isn't needed immediately, the object returned from your `load` function can contain promises rather than the data itself. For server `load` functions, this will cause the data to [stream](load#Streaming-with-promises) in after the navigation (or initial page load).\n\n### Preventing waterfalls\n\nOne of the biggest performance killers is what is referred to as a _waterfall_, which is a series of requests that is made sequentially. This can happen on the server or in the browser, but is especially costly when dealing with data that has to travel further or across slower networks, such as a mobile user making a call to a distant server.\n\nIn the browser, waterfalls can occur when your HTML kicks off request chains such as requesting JS which requests CSS which requests a background image and web font. SvelteKit will largely solve this class of problems for you by adding [`modulepreload`](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/rel/modulepreload) tags or headers, but you should view [the network tab in your devtools](#Diagnosing-issues) to check whether additional resources need to be preloaded.\n- Pay special attention to this if you use [web fonts](#Optimizing-assets-Fonts) since they need to be handled manually.\n- Enabling [single page app (SPA) mode](single-page-apps) will cause such waterfalls. With SPA mode, an empty page is generated, which fetches JavaScript, which ultimately loads and renders the page. This results in extra network round trips before a single pixel can be displayed.\n\nWaterfalls can also occur on calls to the backend whether made from the browser or server. E.g. if a universal `load` function makes an API call to fetch the current user, then uses the details from that response to fetch a list of saved items, and then uses _that_ response to fetch the details for each item, the browser will end up making multiple sequential requests. This is deadly for performance, especially for users that are physically located far from your backend.\n- Avoid this issue by using [server `load` functions](load#Universal-vs-server) to make requests to backend services that are dependencies from the server rather than from the browser. Note, however, that server `load` functions are also not immune to waterfalls (though they are much less costly since they rarely involve round trips with high latency). For example, if you query a database to get the current user and then use that data to make a second query for a list of saved items, it will typically be more performant to issue a single query with a database join.\n\n## Hosting\n\nYour frontend should be located in the same data center as your backend to minimize latency. For sites with no central backend, many SvelteKit adapters support deploying to the _edge_, which means handling each user's requests from a nearby server. This can reduce load times significantly. Some adapters even support [configuring deployment on a per-route basis](page-options#config). You should also consider serving images from a CDN (which are typically edge networks) — the hosts for many SvelteKit adapters will do this automatically.\n\nEnsure your host uses HTTP/2 or newer. Vite's code splitting creates numerous small files for improved cacheability, which results in excellent performance, but this does assume that your files can be loaded in parallel with HTTP/2.\n\n## Further reading\n\nFor the most part, building a performant SvelteKit app is the same as building any performant web app. You should be able to apply information from general performance resources such as [Core Web Vitals](https://web.dev/explore/learn-core-web-vitals) to any web experience you build.\n","## Built-in optimizations\n\nSvelteKit automatically handles: code-splitting, asset preloading, file hashing, request coalescing, parallel loading, data inlining, conservative invalidation, prerendering, and link preloading.\n\n## Diagnosing performance issues\n\nUse PageSpeed Insights or WebPageTest for deployed sites. Browser devtools provide Lighthouse, Network, and Performance tabs. Always test in preview mode after building, not in dev mode.\n\nFor slow API calls, instrument your backend with OpenTelemetry or Server-Timing headers.\n\n## Optimizing assets\n\n**Images**: Use `@sveltejs/enhanced-img` package. Lighthouse identifies problematic images.\n\n**Videos**: Compress with Handbrake to `.webm` or `.mp4`. Lazy-load below-the-fold videos with `preload=\"none\"`. Strip audio from muted videos with FFmpeg.\n\n**Fonts**: SvelteKit doesn't preload fonts by default to avoid downloading unused variants. In your `handle` hook, call `resolve` with a `preload` filter to include fonts. Subset fonts to reduce file size.\n\n## Reducing code size\n\n- Use latest Svelte version (Svelte 5 is smaller/faster than 4, which is smaller/faster than 3)\n- Use `rollup-plugin-visualizer` to identify large packages\n- Replace JavaScript analytics with server-side implementations (Cloudflare, Netlify, Vercel offer SvelteKit adapters)\n- Use Partytown's SvelteKit integration to run third-party scripts in web workers\n- Use dynamic `import(...)` instead of static imports for conditionally-needed code\n\n## Navigation performance\n\n**Preloading**: Use link options to eagerly preload code and data for client-side navigation (enabled by default).\n\n**Non-essential data**: Return promises from `load` functions instead of data to stream results after navigation.\n\n**Preventing waterfalls**: \n- Browser waterfalls: SvelteKit adds `modulepreload` tags/headers. Manually preload web fonts. SPA mode causes extra round trips.\n- Backend waterfalls: Use server `load` functions instead of universal ones to avoid sequential API calls from the browser. Combine database queries with joins instead of multiple sequential queries.\n\n## Hosting\n\nDeploy frontend in same data center as backend. Use edge deployment for sites without central backend. Serve images from CDN. Ensure host supports HTTP/2 or newer for parallel file loading.","## Built-in optimizations\n\nSvelteKit handles code-splitting, asset preloading, file hashing, request coalescing, parallel loading, data inlining, conservative invalidation, prerendering, and link preloading.\n\n## Diagnosing issues\n\nTest in preview mode (not dev). Use PageSpeed Insights, WebPageTest, or browser devtools (Lighthouse, Network, Performance tabs). Instrument slow APIs with OpenTelemetry or Server-Timing headers.\n\n## Asset optimization\n\n- **Images**: Use `@sveltejs/enhanced-img`\n- **Videos**: Compress to `.webm`/`.mp4`, lazy-load with `preload=\"none\"`, strip audio with FFmpeg\n- **Fonts**: Preload via `resolve` with `preload` filter in `handle` hook, subset fonts\n\n## Code size\n\n- Use latest Svelte version\n- Use `rollup-plugin-visualizer` to find large packages\n- Replace JS analytics with server-side (Cloudflare, Netlify, Vercel)\n- Use Partytown for third-party scripts in web workers\n- Use dynamic `import(...)` for conditional code\n\n## Navigation\n\n- Preload with link options (default enabled)\n- Return promises from `load` for streaming non-essential data\n- Avoid waterfalls: use server `load` instead of universal, combine DB queries with joins\n\n## Hosting\n\nDeploy frontend near backend or use edge deployment. Serve images from CDN. Use HTTP/2+.","Practical performance optimization techniques for SvelteKit apps: diagnosing issues, optimizing assets, reducing code size, improving navigation, and hosting considerations.","icons",{"name":762,"path":764,"children":765,"data":766},"best-practices/icons",["Map"],{"type":22,"path":767,"relevant":44,"token_counts":768,"usage":772,"markdown":775},"40-best-practices/06-icons.md",{"fulltext":769,"digest":770,"short_digest":771},345,134,66,{"input":773,"output":774,"details":32},1388,326,{"fulltext":776,"digest":777,"short_digest":778,"essence":779},"---\ntitle: Icons\n---\n\n## CSS\n\nA great way to use icons is to define them purely via CSS. Iconify offers support for [many popular icon sets](https://icon-sets.iconify.design/) that [can be included via CSS](https://iconify.design/docs/usage/css/). This method can also be used with popular CSS frameworks by leveraging the Iconify [Tailwind CSS plugin](https://iconify.design/docs/usage/css/tailwind/) or [UnoCSS plugin](https://iconify.design/docs/usage/css/unocss/). As opposed to libraries based on Svelte components, it doesn't require each icon to be imported into your `.svelte` file.\n\n## Svelte\n\nThere are many [icon libraries for Svelte](/packages#icons). When choosing an icon library, it is recommended to avoid those that provide a `.svelte` file per icon, as these libraries can have thousands of `.svelte` files which really slow down [Vite's dependency optimization](https://vite.dev/guide/dep-pre-bundling.html). This can become especially pathological if the icons are imported both via an umbrella import and subpath import [as described in the `vite-plugin-svelte` FAQ](https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/faq.md#what-is-going-on-with-vite-and-pre-bundling-dependencies).\n","## CSS\nUse Iconify to define icons purely via CSS. Iconify supports many popular icon sets and can be included via CSS. Works with popular CSS frameworks using the Iconify Tailwind CSS plugin or UnoCSS plugin. Doesn't require importing icons into `.svelte` files.\n\n## Svelte\nWhen choosing an icon library, avoid those that provide a `.svelte` file per icon. Libraries with thousands of `.svelte` files significantly slow down Vite's dependency optimization. This problem is especially severe when icons are imported both via umbrella import and subpath import.","**CSS**: Use Iconify for CSS-based icons with support for many icon sets and CSS framework plugins.\n\n**Svelte**: Avoid icon libraries with one `.svelte` file per icon as they slow down Vite's dependency optimization, especially with mixed import styles.","Best practices for using icons in SvelteKit: prefer CSS-based approaches with Iconify, and avoid Svelte component libraries with per-icon files due to Vite optimization issues.","images",{"name":780,"path":782,"children":783,"data":784},"best-practices/images",["Map"],{"type":22,"path":785,"relevant":44,"token_counts":786,"usage":790,"markdown":793},"40-best-practices/07-images.md",{"fulltext":787,"digest":788,"short_digest":789},3000,756,323,{"input":791,"output":792,"details":32},4043,1211,{"fulltext":794,"digest":795,"short_digest":796,"essence":797},"---\ntitle: Images\n---\n\nImages can have a big impact on your app's performance. For best results, you should optimize them by doing the following:\n\n- generate optimal formats like `.avif` and `.webp`\n- create different sizes for different screens\n- ensure that assets can be cached effectively\n\nDoing this manually is tedious. There are a variety of techniques you can use, depending on your needs and preferences.\n\n## Vite's built-in handling\n\n[Vite will automatically process imported assets](https://vitejs.dev/guide/assets.html) for improved performance. This includes assets referenced via the CSS `url()` function. Hashes will be added to the filenames so that they can be cached, and assets smaller than `assetsInlineLimit` will be inlined. Vite's asset handling is most often used for images, but is also useful for video, audio, etc.\n\n```svelte\n\u003Cscript>\n\timport logo from '$lib/assets/logo.png';\n\u003C/script>\n\n\u003Cimg alt=\"The project logo\" src={logo} />\n```\n\n## @sveltejs/enhanced-img\n\n`@sveltejs/enhanced-img` is a plugin offered on top of Vite's built-in asset handling. It provides plug and play image processing that serves smaller file formats like `avif` or `webp`, automatically sets the intrinsic `width` and `height` of the image to avoid layout shift, creates images of multiple sizes for various devices, and strips EXIF data for privacy. It will work in any Vite-based project including, but not limited to, SvelteKit projects.\n\n> [!NOTE] As a build plugin, `@sveltejs/enhanced-img` can only optimize files located on your machine during the build process. If you have an image located elsewhere (such as a path served from your database, CMS, or backend), please read about [loading images dynamically from a CDN](#Loading-images-dynamically-from-a-CDN).\n\n### Setup\n\nInstall:\n\n```sh\nnpm i -D @sveltejs/enhanced-img\n```\n\nAdjust `vite.config.js`:\n\n```js\nimport { sveltekit } from '@sveltejs/kit/vite';\n+++import { enhancedImages } from '@sveltejs/enhanced-img';+++\nimport { defineConfig } from 'vite';\n\nexport default defineConfig({\n\tplugins: [\n\t\t+++enhancedImages(), // must come before the SvelteKit plugin+++\n\t\tsveltekit()\n\t]\n});\n```\n\nBuilding will take longer on the first build due to the computational expense of transforming images. However, the build output will be cached in `./node_modules/.cache/imagetools` so that subsequent builds will be fast.\n\n### Basic usage\n\nUse in your `.svelte` components by using `\u003Cenhanced:img>` rather than `\u003Cimg>` and referencing the image file with a [Vite asset import](https://vitejs.dev/guide/assets.html#static-asset-handling) path:\n\n```svelte\n\u003Cenhanced:img src=\"./path/to/your/image.jpg\" alt=\"An alt text\" />\n```\n\nAt build time, your `\u003Cenhanced:img>` tag will be replaced with an `\u003Cimg>` wrapped by a `\u003Cpicture>` providing multiple image types and sizes. It's only possible to downscale images without losing quality, which means that you should provide the highest resolution image that you need — smaller versions will be generated for the various device types that may request an image.\n\nYou should provide your image at 2x resolution for HiDPI displays (a.k.a. retina displays). `\u003Cenhanced:img>` will automatically take care of serving smaller versions to smaller devices.\n\n> [!NOTE] if you wish to use a [tag name CSS selector](https://developer.mozilla.org/en-US/docs/Learn_web_development/Core/Styling_basics/Basic_selectors#type_selectors) in your `\u003Cstyle>` block you will need to write `enhanced\\:img` to escape the colon in the tag name.\n\n### Dynamically choosing an image\n\nYou can also manually import an image asset and pass it to an `\u003Cenhanced:img>`. This is useful when you have a collection of static images and would like to dynamically choose one or [iterate over them](https://github.com/sveltejs/kit/blob/0ab1733e394b6310895a1d3bf0f126ce34531170/sites/kit.svelte.dev/src/routes/home/Showcase.svelte). In this case you will need to update both the `import` statement and `\u003Cimg>` element as shown below to indicate you'd like process them.\n\n```svelte\n\u003Cscript>\n\timport MyImage from './path/to/your/image.jpg?enhanced';\n\u003C/script>\n\n\u003Cenhanced:img src={MyImage} alt=\"some alt text\" />\n```\n\nYou can also use [Vite's `import.meta.glob`](https://vitejs.dev/guide/features.html#glob-import). Note that you will have to specify `enhanced` via a [custom query](https://vitejs.dev/guide/features.html#custom-queries):\n\n```svelte\n\u003Cscript>\n\tconst imageModules = import.meta.glob(\n\t\t'/path/to/assets/*.{avif,gif,heif,jpeg,jpg,png,tiff,webp,svg}',\n\t\t{\n\t\t\teager: true,\n\t\t\tquery: {\n\t\t\t\tenhanced: true\n\t\t\t}\n\t\t}\n\t)\n\u003C/script>\n\n{#each Object.entries(imageModules) as [_path, module]}\n\t\u003Cenhanced:img src={module.default} alt=\"some alt text\" />\n{/each}\n```\n\n### Intrinsic Dimensions\n\n`width` and `height` are optional as they can be inferred from the source image and will be automatically added when the `\u003Cenhanced:img>` tag is preprocessed. With these attributes, the browser can reserve the correct amount of space, preventing [layout shift](https://web.dev/articles/cls). If you'd like to use a different `width` and `height` you can style the image with CSS. Because the preprocessor adds a `width` and `height` for you, if you'd like one of the dimensions to be automatically calculated then you will need to specify that:\n\n```svelte\n\u003Cstyle>\n\t.hero-image img {\n\t\twidth: var(--size);\n\t\theight: auto;\n\t}\n\u003C/style>\n```\n\n### `srcset` and `sizes`\n\nIf you have a large image, such as a hero image taking the width of the design, you should specify `sizes` so that smaller versions are requested on smaller devices. E.g. if you have a 1280px image you may want to specify something like:\n\n```svelte\n\u003Cenhanced:img src=\"./image.png\" sizes=\"min(1280px, 100vw)\"/>\n```\n\nIf `sizes` is specified, `\u003Cenhanced:img>` will generate small images for smaller devices and populate the `srcset` attribute.\n\nThe smallest picture generated automatically will have a width of 540px. If you'd like smaller images or would otherwise like to specify custom widths, you can do that with the `w` query parameter:\n```svelte\n\u003Cenhanced:img\n  src=\"./image.png?w=1280;640;400\"\n  sizes=\"(min-width:1920px) 1280px, (min-width:1080px) 640px, (min-width:768px) 400px\"\n/>\n```\n\nIf `sizes` is not provided, then a HiDPI/Retina image and a standard resolution image will be generated. The image you provide should be 2x the resolution you wish to display so that the browser can display that image on devices with a high [device pixel ratio](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio).\n\n### Per-image transforms\n\nBy default, enhanced images will be transformed to more efficient formats. However, you may wish to apply other transforms such as a blur, quality, flatten, or rotate operation. You can run per-image transforms by appending a query string:\n\n```svelte\n\u003Cenhanced:img src=\"./path/to/your/image.jpg?blur=15\" alt=\"An alt text\" />\n```\n\n[See the imagetools repo for the full list of directives](https://github.com/JonasKruckenberg/imagetools/blob/main/docs/directives.md).\n\n## Loading images dynamically from a CDN\n\nIn some cases, the images may not be accessible at build time — e.g. they may live inside a content management system or elsewhere.\n\nUsing a content delivery network (CDN) can allow you to optimize these images dynamically, and provides more flexibility with regards to sizes, but it may involve some setup overhead and usage costs. Depending on caching strategy, the browser may not be able to use a cached copy of the asset until a [304 response](https://developer.mozilla.org/en-US/docs/Web/HTTP/Status/304) is received from the CDN. Building HTML to target CDNs allows using an `\u003Cimg>` tag since the CDN can serve the appropriate format based on the `User-Agent` header, whereas build-time optimizations must produce `\u003Cpicture>` tags with multiple sources. Finally, some CDNs may generate images lazily, which could have a negative performance impact for sites with low traffic and frequently changing images.\n\nCDNs can generally be used without any need for a library. However, there are a number of libraries with Svelte support that make it easier. [`@unpic/svelte`](https://unpic.pics/img/svelte/) is a CDN-agnostic library with support for a large number of providers. You may also find that specific CDNs like [Cloudinary](https://svelte.cloudinary.dev/) have Svelte support. Finally, some content management systems (CMS) which support Svelte (such as [Contentful](https://www.contentful.com/sveltekit-starter-guide/), [Storyblok](https://github.com/storyblok/storyblok-svelte), and [Contentstack](https://www.contentstack.com/docs/developers/sample-apps/build-a-starter-website-with-sveltekit-and-contentstack)) have built-in support for image handling.\n\n## Best practices\n\n- For each image type, use the appropriate solution from those discussed above. You can mix and match all three solutions in one project. For example, you may use Vite's built-in handling to provide images for `\u003Cmeta>` tags, display images on your homepage with `@sveltejs/enhanced-img`, and display user-submitted content with a dynamic approach.\n- Consider serving all images via CDN regardless of the image optimization types you use. CDNs reduce latency by distributing copies of static assets globally.\n- Your original images should have a good quality/resolution and should have 2x the width it will be displayed at to serve HiDPI devices. Image processing can size images down to save bandwidth when serving smaller screens, but it would be a waste of bandwidth to invent pixels to size images up.\n- For images which are much larger than the width of a mobile device (roughly 400px), such as a hero image taking the width of the page design, specify `sizes` so that smaller images can be served on smaller devices.\n- For important images, such as the [largest contentful paint (LCP)](https://web.dev/articles/lcp) image, set `fetchpriority=\"high\"` and avoid `loading=\"lazy\"` to prioritize loading as early as possible.\n- Give the image a container or styling so that it is constrained and does not jump around while the page is loading affecting your [cumulative layout shift (CLS)](https://web.dev/articles/cls). `width` and `height` help the browser to reserve space while the image is still loading, so `@sveltejs/enhanced-img` will add a `width` and `height` for you.\n- Always provide a good `alt` text. The Svelte compiler will warn you if you don't do this.\n- Do not use `em` or `rem` in `sizes` and change the default size of these measures. When used in `sizes` or `@media` queries, `em` and `rem` are both defined to mean the user's default `font-size`. For a `sizes` declaration like `sizes=\"(min-width: 768px) min(100vw, 108rem), 64rem\"`, the actual `em` or `rem` that controls how the image is laid out on the page can be different if changed by CSS. For example, do not do something like `html { font-size: 62.5%; }` as the slot reserved by the browser preloader will now end up being larger than the actual slot of the CSS object model once it has been created.\n","## Image Optimization Approaches\n\n**Vite's built-in handling**: Automatically processes imported assets, adds hashes for caching, and inlines small assets.\n```svelte\n\u003Cscript>\n\timport logo from '$lib/assets/logo.png';\n\u003C/script>\n\u003Cimg alt=\"The project logo\" src={logo} />\n```\n\n**@sveltejs/enhanced-img**: Build-time plugin that generates optimal formats (avif, webp), creates multiple sizes, sets intrinsic dimensions to prevent layout shift, and strips EXIF data. Only works with local files during build.\n\nSetup:\n```js\nimport { enhancedImages } from '@sveltejs/enhanced-img';\nexport default defineConfig({\n\tplugins: [enhancedImages(), sveltekit()]\n});\n```\n\nUsage with static imports:\n```svelte\n\u003Cenhanced:img src=\"./path/to/your/image.jpg\" alt=\"An alt text\" />\n```\n\nDynamic imports with query parameter:\n```svelte\n\u003Cscript>\n\timport MyImage from './path/to/your/image.jpg?enhanced';\n\u003C/script>\n\u003Cenhanced:img src={MyImage} alt=\"some alt text\" />\n```\n\nOr with glob:\n```svelte\n\u003Cscript>\n\tconst imageModules = import.meta.glob('/path/to/assets/*.{jpg,png}', {\n\t\teager: true,\n\t\tquery: { enhanced: true }\n\t})\n\u003C/script>\n{#each Object.entries(imageModules) as [_path, module]}\n\t\u003Cenhanced:img src={module.default} alt=\"some alt text\" />\n{/each}\n```\n\n**Responsive sizing**: Use `sizes` attribute for large images to serve smaller versions on smaller devices:\n```svelte\n\u003Cenhanced:img src=\"./image.png\" sizes=\"min(1280px, 100vw)\"/>\n```\n\nCustom widths with `w` query parameter:\n```svelte\n\u003Cenhanced:img src=\"./image.png?w=1280;640;400\" sizes=\"(min-width:1920px) 1280px, (min-width:1080px) 640px, (min-width:768px) 400px\"/>\n```\n\n**Per-image transforms**: Apply transforms via query string:\n```svelte\n\u003Cenhanced:img src=\"./path/to/your/image.jpg?blur=15\" alt=\"An alt text\" />\n```\n\n**CDN approach**: For images not available at build time (CMS, database, backend). Use CDN-agnostic libraries like `@unpic/svelte` or provider-specific solutions (Cloudinary, Contentful, Storyblok, Contentstack).\n\n## Best Practices\n\n- Mix approaches in one project as needed\n- Serve all images via CDN to reduce latency\n- Provide images at 2x resolution for HiDPI displays\n- Use `sizes` for images larger than ~400px width\n- Set `fetchpriority=\"high\"` and avoid `loading=\"lazy\"` for LCP images\n- Constrain images with container/styling to prevent layout shift\n- Always provide `alt` text\n- Don't use `em` or `rem` in `sizes` attribute; use absolute units","## Image Optimization\n\n**Vite built-in**: Auto-processes imported assets with hashing and inlining.\n\n**@sveltejs/enhanced-img**: Build-time plugin generating avif/webp formats, multiple sizes, and intrinsic dimensions.\n```svelte\n\u003Cenhanced:img src=\"./image.jpg\" alt=\"text\" />\n```\n\nDynamic imports:\n```svelte\n\u003Cscript>\n\timport MyImage from './image.jpg?enhanced';\n\u003C/script>\n\u003Cenhanced:img src={MyImage} alt=\"text\" />\n```\n\nResponsive sizing:\n```svelte\n\u003Cenhanced:img src=\"./image.png?w=1280;640;400\" sizes=\"(min-width:1920px) 1280px, (min-width:1080px) 640px, (min-width:768px) 400px\"/>\n```\n\nPer-image transforms:\n```svelte\n\u003Cenhanced:img src=\"./image.jpg?blur=15\" alt=\"text\" />\n```\n\n**CDN approach**: For dynamic/external images using `@unpic/svelte` or provider-specific libraries.\n\n**Best practices**: Mix approaches as needed, serve via CDN, provide 2x resolution images, use `sizes` for large images, set `fetchpriority=\"high\"` for LCP images, avoid `em`/`rem` in `sizes`.","Three approaches to image optimization: Vite's built-in asset handling, @sveltejs/enhanced-img for build-time optimization with multiple formats and sizes, and CDN-based solutions for dynamic images.","accessibility",{"name":798,"path":800,"children":801,"data":802},"best-practices/accessibility",["Map"],{"type":22,"path":803,"relevant":44,"token_counts":804,"usage":807,"markdown":810},"40-best-practices/10-accessibility.md",{"fulltext":805,"digest":806,"short_digest":472},1409,414,{"input":808,"output":809,"details":32},2452,669,{"fulltext":811,"digest":812,"short_digest":813,"essence":814},"---\ntitle: Accessibility\n---\n\nSvelteKit strives to provide an accessible platform for your app by default. Svelte's [compile-time accessibility checks](../svelte/compiler-warnings) will also apply to any SvelteKit application you build.\n\nHere's how SvelteKit's built-in accessibility features work and what you need to do to help these features to work as well as possible. Keep in mind that while SvelteKit provides an accessible foundation, you are still responsible for making sure your application code is accessible. If you're new to accessibility, see the [\"further reading\"](accessibility#Further-reading) section of this guide for additional resources.\n\nWe recognize that accessibility can be hard to get right. If you want to suggest improvements to how SvelteKit handles accessibility, please [open a GitHub issue](https://github.com/sveltejs/kit/issues).\n\n## Route announcements\n\nIn traditional server-rendered applications, every navigation (e.g. clicking on an `\u003Ca>` tag) triggers a full page reload. When this happens, screen readers and other assistive technology will read out the new page's title so that users understand that the page has changed.\n\nSince navigation between pages in SvelteKit happens without reloading the page (known as [client-side routing](glossary#Routing)), SvelteKit injects a [live region](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions) onto the page that will read out the new page name after each navigation. This determines the page name to announce by inspecting the `\u003Ctitle>` element.\n\nBecause of this behavior, every page in your app should have a unique, descriptive title. In SvelteKit, you can do this by placing a `\u003Csvelte:head>` element on each page:\n\n```svelte\n\u003C!--- file: src/routes/+page.svelte --->\n\u003Csvelte:head>\n\t\u003Ctitle>Todo List\u003C/title>\n\u003C/svelte:head>\n```\n\nThis will allow screen readers and other assistive technology to identify the new page after a navigation occurs. Providing a descriptive title is also important for [SEO](seo#Manual-setup-title-and-meta).\n\n## Focus management\n\nIn traditional server-rendered applications, every navigation will reset focus to the top of the page. This ensures that people browsing the web with a keyboard or screen reader will start interacting with the page from the beginning.\n\nTo simulate this behavior during client-side routing, SvelteKit focuses the `\u003Cbody>` element after each navigation and [enhanced form submission](form-actions#Progressive-enhancement). There is one exception - if an element with the [`autofocus`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autofocus) attribute is present, SvelteKit will focus that element instead. Make sure to [consider the implications for assistive technology](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/autofocus#accessibility_considerations) when using that attribute.\n\nIf you want to customize SvelteKit's focus management, you can use the `afterNavigate` hook:\n\n```js\n/// \u003Creference types=\"@sveltejs/kit\" />\n// ---cut---\nimport { afterNavigate } from '$app/navigation';\n\nafterNavigate(() => {\n\t/** @type {HTMLElement | null} */\n\tconst to_focus = document.querySelector('.focus-me');\n\tto_focus?.focus();\n});\n```\n\nYou can also programmatically navigate to a different page using the [`goto`]($app-navigation#goto) function. By default, this will have the same client-side routing behavior as clicking on a link. However, `goto` also accepts a `keepFocus` option that will preserve the currently-focused element instead of resetting focus. If you enable this option, make sure the currently-focused element still exists on the page after navigation. If the element no longer exists, the user's focus will be lost, making for a confusing experience for assistive technology users.\n\n## The \"lang\" attribute\n\nBy default, SvelteKit's page template sets the default language of the document to English. If your content is not in English, you should update the `\u003Chtml>` element in `src/app.html` to have the correct [`lang`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang#accessibility) attribute. This will ensure that any assistive technology reading the document uses the correct pronunciation. For example, if your content is in German, you should update `app.html` to the following:\n\n```html\n/// file: src/app.html\n\u003Chtml lang=\"de\">\n```\n\nIf your content is available in multiple languages, you should set the `lang` attribute based on the language of the current page. You can do this with SvelteKit's [handle hook](hooks#Server-hooks-handle):\n\n```html\n/// file: src/app.html\n\u003Chtml lang=\"%lang%\">\n```\n\n```js\n/// file: src/hooks.server.js\n/**\n * @param {import('@sveltejs/kit').RequestEvent} event\n */\nfunction get_lang(event) {\n\treturn 'en';\n}\n// ---cut---\n/** @type {import('@sveltejs/kit').Handle} */\nexport function handle({ event, resolve }) {\n\treturn resolve(event, {\n\t\ttransformPageChunk: ({ html }) => html.replace('%lang%', get_lang(event))\n\t});\n}\n```\n\n## Further reading\n\nFor the most part, building an accessible SvelteKit app is the same as building an accessible web app. You should be able to apply information from the following general accessibility resources to any web experience you build:\n\n- [MDN Web Docs: Accessibility](https://developer.mozilla.org/en-US/docs/Learn/Accessibility)\n- [The A11y Project](https://www.a11yproject.com/)\n- [How to Meet WCAG (Quick Reference)](https://www.w3.org/WAI/WCAG21/quickref/)\n","## Route announcements\n\nSvelteKit uses client-side routing, so page reloads don't occur. To announce page changes to screen readers, SvelteKit injects a live region that reads the page title after navigation. Every page must have a unique, descriptive `\u003Ctitle>` in a `\u003Csvelte:head>` block:\n\n```svelte\n\u003Csvelte:head>\n\t\u003Ctitle>Todo List\u003C/title>\n\u003C/svelte:head>\n```\n\n## Focus management\n\nSvelteKit focuses the `\u003Cbody>` element after navigation and form submission to simulate traditional server-rendered behavior. If an element has the `autofocus` attribute, that element is focused instead.\n\nCustomize focus management with the `afterNavigate` hook:\n\n```js\nimport { afterNavigate } from '$app/navigation';\n\nafterNavigate(() => {\n\tconst to_focus = document.querySelector('.focus-me');\n\tto_focus?.focus();\n});\n```\n\nThe `goto` function accepts a `keepFocus` option to preserve the currently-focused element instead of resetting focus. Ensure the focused element still exists after navigation.\n\n## Language attribute\n\nSet the `lang` attribute on the `\u003Chtml>` element in `src/app.html` for correct assistive technology pronunciation:\n\n```html\n\u003Chtml lang=\"de\">\n```\n\nFor multi-language content, use the server-side `handle` hook to set `lang` dynamically:\n\n```html\n\u003C!-- src/app.html -->\n\u003Chtml lang=\"%lang%\">\n```\n\n```js\n// src/hooks.server.js\nexport function handle({ event, resolve }) {\n\treturn resolve(event, {\n\t\ttransformPageChunk: ({ html }) => html.replace('%lang%', get_lang(event))\n\t});\n}\n```","## Route announcements\nEvery page needs a unique `\u003Ctitle>` in `\u003Csvelte:head>` so screen readers announce page changes during client-side navigation.\n\n## Focus management\nSvelteKit focuses `\u003Cbody>` after navigation (or an `autofocus` element if present). Customize with `afterNavigate` hook. The `goto` function has a `keepFocus` option to preserve focus.\n\n## Language attribute\nSet `lang` attribute on `\u003Chtml>` in `src/app.html`. Use the `handle` hook to set it dynamically for multi-language apps.","SvelteKit provides built-in accessibility features: route announcements via live regions, focus management after navigation, and language attribute configuration.","seo",{"name":815,"path":817,"children":818,"data":819},"best-practices/seo",["Map"],{"type":22,"path":820,"relevant":44,"token_counts":821,"usage":825,"markdown":828},"40-best-practices/20-seo.md",{"fulltext":822,"digest":823,"short_digest":824},1685,399,132,{"input":826,"output":827,"details":32},2729,653,{"fulltext":829,"digest":830,"short_digest":831,"essence":832},"---\ntitle: SEO\n---\n\nThe most important aspect of SEO is to create high-quality content that is widely linked to from around the web. However, there are a few technical considerations for building sites that rank well.\n\n## Out of the box\n\n### SSR\n\nWhile search engines have got better in recent years at indexing content that was rendered with client-side JavaScript, server-side rendered content is indexed more frequently and reliably. SvelteKit employs SSR by default, and while you can disable it in [`handle`](hooks#Server-hooks-handle), you should leave it on unless you have a good reason not to.\n\n> [!NOTE] SvelteKit's rendering is highly configurable and you can implement [dynamic rendering](https://developers.google.com/search/docs/advanced/javascript/dynamic-rendering) if necessary. It's not generally recommended, since SSR has other benefits beyond SEO.\n\n### Performance\n\nSignals such as [Core Web Vitals](https://web.dev/vitals/#core-web-vitals) impact search engine ranking. Because Svelte and SvelteKit introduce minimal overhead, they make it easier to build high performance sites. You can test your site's performance using Google's [PageSpeed Insights](https://pagespeed.web.dev/) or [Lighthouse](https://developers.google.com/web/tools/lighthouse). With just a few key actions like using SvelteKit's default [hybrid rendering](glossary#Hybrid-app) mode and [optimizing your images](images), you can greatly improve your site's speed. Read [the performance page](performance) for more details.\n\n### Normalized URLs\n\nSvelteKit redirects pathnames with trailing slashes to ones without (or vice versa depending on your [configuration](page-options#trailingSlash)), as duplicate URLs are bad for SEO.\n\n## Manual setup\n\n### &lt;title&gt; and &lt;meta&gt;\n\nEvery page should have well-written and unique `\u003Ctitle>` and `\u003Cmeta name=\"description\">` elements inside a [`\u003Csvelte:head>`](../svelte/svelte-head). Guidance on how to write descriptive titles and descriptions, along with other suggestions on making content understandable by search engines, can be found on Google's [Lighthouse SEO audits](https://web.dev/lighthouse-seo/) documentation.\n\n> [!NOTE] A common pattern is to return SEO-related `data` from page [`load`](load) functions, then use it (as [`page.data`]($app-state)) in a `\u003Csvelte:head>` in your root [layout](routing#layout).\n\n### Sitemaps\n\n[Sitemaps](https://developers.google.com/search/docs/advanced/sitemaps/build-sitemap) help search engines prioritize pages within your site, particularly when you have a large amount of content. You can create a sitemap dynamically using an endpoint:\n\n```js\n/// file: src/routes/sitemap.xml/+server.js\nexport async function GET() {\n\treturn new Response(\n\t\t`\n\t\t\u003C?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\t\t\u003Curlset\n\t\t\txmlns=\"https://www.sitemaps.org/schemas/sitemap/0.9\"\n\t\t\txmlns:xhtml=\"https://www.w3.org/1999/xhtml\"\n\t\t\txmlns:mobile=\"https://www.google.com/schemas/sitemap-mobile/1.0\"\n\t\t\txmlns:news=\"https://www.google.com/schemas/sitemap-news/0.9\"\n\t\t\txmlns:image=\"https://www.google.com/schemas/sitemap-image/1.1\"\n\t\t\txmlns:video=\"https://www.google.com/schemas/sitemap-video/1.1\"\n\t\t>\n\t\t\t\u003C!-- \u003Curl> elements go here -->\n\t\t\u003C/urlset>`.trim(),\n\t\t{\n\t\t\theaders: {\n\t\t\t\t'Content-Type': 'application/xml'\n\t\t\t}\n\t\t}\n\t);\n}\n```\n\n### AMP\n\nAn unfortunate reality of modern web development is that it is sometimes necessary to create an [Accelerated Mobile Pages (AMP)](https://amp.dev/) version of your site. In SvelteKit this can be done by setting the [`inlineStyleThreshold`](configuration#inlineStyleThreshold) option...\n\n```js\n/// file: svelte.config.js\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\t// since \u003Clink rel=\"stylesheet\"> isn't\n\t\t// allowed, inline all styles\n\t\tinlineStyleThreshold: Infinity\n\t}\n};\n\nexport default config;\n```\n\n...disabling `csr` in your root `+layout.js`/`+layout.server.js`...\n\n```js\n/// file: src/routes/+layout.server.js\nexport const csr = false;\n```\n\n...adding `amp` to your `app.html`\n\n```html\n\u003Chtml amp>\n...\n```\n\n...and transforming the HTML using `transformPageChunk` along with `transform` imported from `@sveltejs/amp`:\n\n```js\n/// file: src/hooks.server.js\nimport * as amp from '@sveltejs/amp';\n\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tlet buffer = '';\n\treturn await resolve(event, {\n\t\ttransformPageChunk: ({ html, done }) => {\n\t\t\tbuffer += html;\n\t\t\tif (done) return amp.transform(buffer);\n\t\t}\n\t});\n}\n```\n\nTo prevent shipping any unused CSS as a result of transforming the page to amp, we can use [`dropcss`](https://www.npmjs.com/package/dropcss):\n\n```js\n// @filename: ambient.d.ts\ndeclare module 'dropcss';\n\n// @filename: index.js\n// ---cut---\n/// file: src/hooks.server.js\n// @errors: 2307\nimport * as amp from '@sveltejs/amp';\nimport dropcss from 'dropcss';\n\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tlet buffer = '';\n\n\treturn await resolve(event, {\n\t\ttransformPageChunk: ({ html, done }) => {\n\t\t\tbuffer += html;\n\n\t\t\tif (done) {\n\t\t\t\tlet css = '';\n\t\t\t\tconst markup = amp\n\t\t\t\t\t.transform(buffer)\n\t\t\t\t\t.replace('⚡', 'amp') // dropcss can't handle this character\n\t\t\t\t\t.replace(/\u003Cstyle amp-custom([^>]*?)>([^]+?)\u003C\\/style>/, (match, attributes, contents) => {\n\t\t\t\t\t\tcss = contents;\n\t\t\t\t\t\treturn `\u003Cstyle amp-custom${attributes}>\u003C/style>`;\n\t\t\t\t\t});\n\n\t\t\t\tcss = dropcss({ css, html: markup }).css;\n\t\t\t\treturn markup.replace('\u003C/style>', `${css}\u003C/style>`);\n\t\t\t}\n\t\t}\n\t});\n}\n\n```\n\n> [!NOTE] It's a good idea to use the `handle` hook to validate the transformed HTML using `amphtml-validator`, but only if you're prerendering pages since it's very slow.\n","## Out of the box\n\n**SSR**: SvelteKit uses server-side rendering by default, which search engines index more reliably than client-side rendered content. Keep it enabled unless you have a specific reason to disable it.\n\n**Performance**: Core Web Vitals impact search rankings. Svelte/SvelteKit have minimal overhead. Use hybrid rendering mode and optimize images. Test with PageSpeed Insights or Lighthouse.\n\n**Normalized URLs**: SvelteKit automatically redirects trailing slash variants to prevent duplicate URL issues.\n\n## Manual setup\n\n**Title and Meta**: Every page needs unique `\u003Ctitle>` and `\u003Cmeta name=\"description\">` in `\u003Csvelte:head>`. Common pattern: return SEO data from page `load` functions and use it in root layout's `\u003Csvelte:head>`.\n\n**Sitemaps**: Create dynamically via endpoint at `src/routes/sitemap.xml/+server.js`:\n```js\nexport async function GET() {\n\treturn new Response(\n\t\t`\u003C?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n\t\t\u003Curlset xmlns=\"https://www.sitemaps.org/schemas/sitemap/0.9\">\n\t\t\t\u003C!-- \u003Curl> elements go here -->\n\t\t\u003C/urlset>`,\n\t\t{ headers: { 'Content-Type': 'application/xml' } }\n\t);\n}\n```\n\n**AMP**: To create AMP versions, set `inlineStyleThreshold: Infinity` in config, disable `csr` in root layout, add `amp` attribute to `\u003Chtml>`, and transform HTML in `src/hooks.server.js` using `@sveltejs/amp`. Optionally use `dropcss` to remove unused CSS.","**Out of box**: SSR enabled by default (better indexing), minimal performance overhead, automatic trailing slash normalization.\n\n**Manual setup**: Add unique `\u003Ctitle>` and `\u003Cmeta name=\"description\">` to each page in `\u003Csvelte:head>`. Create sitemaps via `src/routes/sitemap.xml/+server.js` endpoint. For AMP support, set `inlineStyleThreshold: Infinity`, disable `csr`, add `amp` to `\u003Chtml>`, and transform with `@sveltejs/amp` in hooks.","Technical SEO best practices for SvelteKit: leverage built-in SSR and performance, set page metadata, create sitemaps, and optionally support AMP.",{"name":724,"path":834,"children":835,"data":836},"best-practices/best-practices",["Map"],{"type":22,"path":837,"relevant":24,"token_counts":838,"usage":840,"markdown":842},"40-best-practices/index.md",{"fulltext":117,"digest":48,"short_digest":839},18,{"input":121,"output":841,"details":32},181,{"fulltext":843,"digest":844,"short_digest":845,"essence":846},"---\ntitle: Best practices\n---\n","This page serves as an index for best practices documentation in SvelteKit. It appears to be a landing page for a collection of best practice guidelines and recommendations for developers using SvelteKit. The actual best practices content would be found in linked sections within this documentation area.","Index page for SvelteKit best practices documentation.","Landing page for best practices guidelines in SvelteKit development.",{"type":129,"path":848,"relevant":44,"token_counts":849,"usage":853,"markdown":856},"40-best-practices",{"fulltext":850,"digest":851,"short_digest":852},1296,724,350,{"input":854,"output":855,"details":32},2410,1187,{"fulltext":857,"digest":858,"short_digest":859,"essence":860},"\n\n## Pages\n\n### authentication-and-authorization\nAuthentication and authorization strategies in SvelteKit: comparing sessions vs tokens, integration via server hooks, and using framework-specific libraries.\n\n**Sessions vs JWT**: Sessions are revocable but require DB queries; JWT offer better latency but can't be revoked.\n\n**SvelteKit Integration**: Check auth cookies in server hooks, store user info in `locals`.\n\n**Use framework-specific libraries** like Lucia for auth implementation.\n\n### performance\nPractical performance optimization techniques for SvelteKit apps: diagnosing issues, optimizing assets, reducing code size, improving navigation, and hosting considerations.\n\n## Built-in optimizations\n\nSvelteKit handles code-splitting, asset preloading, file hashing, request coalescing, parallel loading, data inlining, conservative invalidation, prerendering, and link preloading.\n\n## Diagnosing issues\n\nTest in preview mode (not dev). Use PageSpeed Insights, WebPageTest, or browser devtools (Lighthouse, Network, Performance tabs). Instrument slow APIs with OpenTelemetry or Server-Timing headers.\n\n## Asset optimization\n\n- **Images**: Use `@sveltejs/enhanced-img`\n- **Videos**: Compress to `.webm`/`.mp4`, lazy-load with `preload=\"none\"`, strip audio with FFmpeg\n- **Fonts**: Preload via `resolve` with `preload` filter in `handle` hook, subset fonts\n\n## Code size\n\n- Use latest Svelte version\n- Use `rollup-plugin-visualizer` to find large packages\n- Replace JS analytics with server-side (Cloudflare, Netlify, Vercel)\n- Use Partytown for third-party scripts in web workers\n- Use dynamic `import(...)` for conditional code\n\n## Navigation\n\n- Preload with link options (default enabled)\n- Return promises from `load` for streaming non-essential data\n- Avoid waterfalls: use server `load` instead of universal, combine DB queries with joins\n\n## Hosting\n\nDeploy frontend near backend or use edge deployment. Serve images from CDN. Use HTTP/2+.\n\n### icons\nBest practices for using icons in SvelteKit: prefer CSS-based approaches with Iconify, and avoid Svelte component libraries with per-icon files due to Vite optimization issues.\n\n**CSS**: Use Iconify for CSS-based icons with support for many icon sets and CSS framework plugins.\n\n**Svelte**: Avoid icon libraries with one `.svelte` file per icon as they slow down Vite's dependency optimization, especially with mixed import styles.\n\n### images\nThree approaches to image optimization: Vite's built-in asset handling, @sveltejs/enhanced-img for build-time optimization with multiple formats and sizes, and CDN-based solutions for dynamic images.\n\n## Image Optimization\n\n**Vite built-in**: Auto-processes imported assets with hashing and inlining.\n\n**@sveltejs/enhanced-img**: Build-time plugin generating avif/webp formats, multiple sizes, and intrinsic dimensions.\n```svelte\n\u003Cenhanced:img src=\"./image.jpg\" alt=\"text\" />\n```\n\nDynamic imports:\n```svelte\n\u003Cscript>\n\timport MyImage from './image.jpg?enhanced';\n\u003C/script>\n\u003Cenhanced:img src={MyImage} alt=\"text\" />\n```\n\nResponsive sizing:\n```svelte\n\u003Cenhanced:img src=\"./image.png?w=1280;640;400\" sizes=\"(min-width:1920px) 1280px, (min-width:1080px) 640px, (min-width:768px) 400px\"/>\n```\n\nPer-image transforms:\n```svelte\n\u003Cenhanced:img src=\"./image.jpg?blur=15\" alt=\"text\" />\n```\n\n**CDN approach**: For dynamic/external images using `@unpic/svelte` or provider-specific libraries.\n\n**Best practices**: Mix approaches as needed, serve via CDN, provide 2x resolution images, use `sizes` for large images, set `fetchpriority=\"high\"` for LCP images, avoid `em`/`rem` in `sizes`.\n\n### accessibility\nSvelteKit provides built-in accessibility features: route announcements via live regions, focus management after navigation, and language attribute configuration.\n\n## Route announcements\nEvery page needs a unique `\u003Ctitle>` in `\u003Csvelte:head>` so screen readers announce page changes during client-side navigation.\n\n## Focus management\nSvelteKit focuses `\u003Cbody>` after navigation (or an `autofocus` element if present). Customize with `afterNavigate` hook. The `goto` function has a `keepFocus` option to preserve focus.\n\n## Language attribute\nSet `lang` attribute on `\u003Chtml>` in `src/app.html`. Use the `handle` hook to set it dynamically for multi-language apps.\n\n### seo\nTechnical SEO best practices for SvelteKit: leverage built-in SSR and performance, set page metadata, create sitemaps, and optionally support AMP.\n\n**Out of box**: SSR enabled by default (better indexing), minimal performance overhead, automatic trailing slash normalization.\n\n**Manual setup**: Add unique `\u003Ctitle>` and `\u003Cmeta name=\"description\">` to each page in `\u003Csvelte:head>`. Create sitemaps via `src/routes/sitemap.xml/+server.js` endpoint. For AMP support, set `inlineStyleThreshold: Infinity`, disable `csr`, add `amp` to `\u003Chtml>`, and transform with `@sveltejs/amp` in hooks.\n\n","## Authentication and Authorization\nSessions are revocable but require DB queries; JWT offer better latency but can't be revoked. Check auth cookies in server hooks and store user info in `locals`. Use framework-specific libraries like Lucia.\n\n## Performance\nSvelteKit handles code-splitting, asset preloading, file hashing, request coalescing, parallel loading, data inlining, conservative invalidation, prerendering, and link preloading.\n\nDiagnose with PageSpeed Insights, WebPageTest, or browser devtools (Lighthouse, Network, Performance tabs). Instrument slow APIs with OpenTelemetry or Server-Timing headers.\n\nOptimize images with `@sveltejs/enhanced-img`, compress videos to `.webm`/`.mp4` with lazy-loading, preload fonts via `resolve` with `preload` filter in `handle` hook. Find large packages with `rollup-plugin-visualizer`. Replace JS analytics with server-side solutions. Use Partytown for third-party scripts. Use dynamic `import(...)` for conditional code.\n\nPreload links (default enabled), return promises from `load` for streaming non-essential data, use server `load` instead of universal to avoid waterfalls. Deploy frontend near backend or use edge deployment, serve images from CDN, use HTTP/2+.\n\n## Icons\nUse Iconify for CSS-based icons. Avoid icon libraries with one `.svelte` file per icon as they slow down Vite's dependency optimization.\n\n## Images\nVite auto-processes imported assets with hashing and inlining. `@sveltejs/enhanced-img` generates avif/webp formats, multiple sizes, and intrinsic dimensions:\n```svelte\n\u003Cenhanced:img src=\"./image.jpg?w=1280;640;400\" sizes=\"(min-width:1920px) 1280px, (min-width:1080px) 640px, (min-width:768px) 400px\" fetchpriority=\"high\" alt=\"text\" />\n```\nFor dynamic/external images use `@unpic/svelte` or provider-specific libraries. Serve via CDN, provide 2x resolution images, set `fetchpriority=\"high\"` for LCP images.\n\n## Accessibility\nEvery page needs a unique `\u003Ctitle>` in `\u003Csvelte:head>` for screen reader announcements. SvelteKit focuses `\u003Cbody>` after navigation (or an `autofocus` element if present). Customize with `afterNavigate` hook. Set `lang` attribute on `\u003Chtml>` in `src/app.html` or dynamically via `handle` hook.\n\n## SEO\nSSR enabled by default with minimal performance overhead and automatic trailing slash normalization. Add unique `\u003Ctitle>` and `\u003Cmeta name=\"description\">` to each page in `\u003Csvelte:head>`. Create sitemaps via `src/routes/sitemap.xml/+server.js` endpoint. For AMP support, set `inlineStyleThreshold: Infinity`, disable `csr`, add `amp` to `\u003Chtml>`, and transform with `@sveltejs/amp` in hooks.","## Authentication\nSessions are revocable but require DB queries; JWT offer better latency but can't be revoked. Check auth cookies in server hooks, store user info in `locals`, use Lucia.\n\n## Performance\nSvelteKit handles code-splitting, preloading, hashing, and prerendering. Optimize images with `@sveltejs/enhanced-img`, compress videos, preload fonts. Use `rollup-plugin-visualizer` to find large packages. Return promises from `load` for streaming, use server `load` to avoid waterfalls. Deploy near backend, serve images from CDN.\n\n## Icons & Images\nUse Iconify for CSS icons. Avoid per-icon `.svelte` files. Use `@sveltejs/enhanced-img` for responsive images with multiple formats:\n```svelte\n\u003Cenhanced:img src=\"./image.jpg?w=1280;640;400\" sizes=\"(min-width:1920px) 1280px, (min-width:1080px) 640px\" fetchpriority=\"high\" alt=\"text\" />\n```\n\n## Accessibility\nAdd unique `\u003Ctitle>` in `\u003Csvelte:head>` for screen readers. SvelteKit focuses `\u003Cbody>` after navigation. Set `lang` on `\u003Chtml>`.\n\n## SEO\nSSR enabled by default. Add unique `\u003Ctitle>` and `\u003Cmeta name=\"description\">` per page. Create sitemaps via `src/routes/sitemap.xml/+server.js`.","Production-ready patterns for authentication, performance optimization, accessibility, SEO, and asset handling in SvelteKit applications.","appendix-&-reference",{"name":861,"path":861,"children":863,"data":1001},["Map",864,865,881,882,899,900,916,917,933,934,950,951,968,969,986,987],"frequently-asked-questions",{"name":864,"path":866,"children":867,"data":868},"appendix-&-reference/frequently-asked-questions",["Map"],{"type":22,"path":869,"relevant":44,"token_counts":870,"usage":873,"markdown":876},"60-appendix/10-faq.md",{"fulltext":871,"digest":872,"short_digest":292},2741,880,{"input":874,"output":875,"details":32},3784,1350,{"fulltext":877,"digest":878,"short_digest":879,"essence":880},"---\ntitle: Frequently asked questions\n---\n\n## Other resources\n\nPlease see [the Svelte FAQ](../svelte/faq) and [`vite-plugin-svelte` FAQ](https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/faq.md) as well for the answers to questions deriving from those libraries.\n\n## What can I make with SvelteKit?\n\nSee [the documentation regarding project types](project-types) for more details.\n\n## How do I include details from package.json in my application?\n\nIf you'd like to include your application's version number or other information from `package.json` in your application, you can load JSON like so:\n\n```ts\n// @errors: 2732\n/// file: svelte.config.js\nimport pkg from './package.json' with { type: 'json' };\n```\n\n## How do I fix the error I'm getting trying to include a package?\n\nMost issues related to including a library are due to incorrect packaging. You can check if a library's packaging is compatible with Node.js by entering it into [the publint website](https://publint.dev/).\n\nHere are a few things to keep in mind when checking if a library is packaged correctly:\n\n- `exports` takes precedence over the other entry point fields such as `main` and `module`. Adding an `exports` field may not be backwards-compatible as it prevents deep imports.\n- ESM files should end with `.mjs` unless `\"type\": \"module\"` is set in which any case CommonJS files should end with `.cjs`.\n- `main` should be defined if `exports` is not. It should be either a CommonJS or ESM file and adhere to the previous bullet. If a `module` field is defined, it should refer to an ESM file.\n- Svelte components should be distributed as uncompiled `.svelte` files with any JS in the package written as ESM only. Custom script and style languages, like TypeScript and SCSS, should be preprocessed as vanilla JS and CSS respectively. We recommend using [`svelte-package`](./packaging) for packaging Svelte libraries, which will do this for you.\n\nLibraries work best in the browser with Vite when they distribute an ESM version, especially if they are dependencies of a Svelte component library. You may wish to suggest to library authors that they provide an ESM version. However, CommonJS (CJS) dependencies should work as well since, by default, [`vite-plugin-svelte` will ask Vite to pre-bundle them](https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/faq.md#what-is-going-on-with-vite-and-pre-bundling-dependencies) using `esbuild` to convert them to ESM.\n\nIf you are still encountering issues we recommend searching both [the Vite issue tracker](https://github.com/vitejs/vite/issues) and the issue tracker of the library in question. Sometimes issues can be worked around by fiddling with the [`optimizeDeps`](https://vitejs.dev/config/#dep-optimization-options) or [`ssr`](https://vitejs.dev/config/#ssr-options) config values though we recommend this as only a short-term workaround in favor of fixing the library in question.\n\n## How do I use the view transitions API?\n\nWhile SvelteKit does not have any specific integration with [view transitions](https://developer.chrome.com/docs/web-platform/view-transitions/), you can call `document.startViewTransition` in [`onNavigate`]($app-navigation#onNavigate) to trigger a view transition on every client-side navigation.\n\n```js\n// @errors: 2339 2810\nimport { onNavigate } from '$app/navigation';\n\nonNavigate((navigation) => {\n\tif (!document.startViewTransition) return;\n\n\treturn new Promise((resolve) => {\n\t\tdocument.startViewTransition(async () => {\n\t\t\tresolve();\n\t\t\tawait navigation.complete;\n\t\t});\n\t});\n});\n```\n\nFor more, see [\"Unlocking view transitions\"](/blog/view-transitions) on the Svelte blog.\n\n## How do I set up a database?\n\nPut the code to query your database in a [server route](./routing#server) - don't query the database in .svelte files. You can create a `db.js` or similar that sets up a connection immediately and makes the client accessible throughout the app as a singleton. You can execute any one-time setup code in `hooks.server.js` and import your database helpers into any endpoint that needs them.\n\nYou can use [the Svelte CLI](/docs/cli/overview) to automatically set up database integrations.\n\n## How do I use a client-side library accessing `document` or `window`?\n\nIf you need access to the `document` or `window` variables or otherwise need code to run only on the client-side you can wrap it in a `browser` check:\n\n```js\n/// \u003Creference types=\"@sveltejs/kit\" />\n// ---cut---\nimport { browser } from '$app/environment';\n\nif (browser) {\n\t// client-only code here\n}\n```\n\nYou can also run code in `onMount` if you'd like to run it after the component has been first rendered to the DOM:\n\n```js\n// @filename: ambient.d.ts\n// @lib: ES2015\ndeclare module 'some-browser-only-library';\n\n// @filename: index.js\n// ---cut---\nimport { onMount } from 'svelte';\n\nonMount(async () => {\n\tconst { method } = await import('some-browser-only-library');\n\tmethod('hello world');\n});\n```\n\nIf the library you'd like to use is side-effect free you can also statically import it and it will be tree-shaken out in the server-side build where `onMount` will be automatically replaced with a no-op:\n\n```js\n// @filename: ambient.d.ts\n// @lib: ES2015\ndeclare module 'some-browser-only-library';\n\n// @filename: index.js\n// ---cut---\nimport { onMount } from 'svelte';\nimport { method } from 'some-browser-only-library';\n\nonMount(() => {\n\tmethod('hello world');\n});\n```\n\nFinally, you may also consider using an `{#await}` block:\n```svelte\n\u003C!--- file: index.svelte --->\n\u003Cscript>\n\timport { browser } from '$app/environment';\n\n\tconst ComponentConstructor = browser ?\n\t\timport('some-browser-only-library').then((module) => module.Component) :\n\t\tnew Promise(() => {});\n\u003C/script>\n\n{#await ComponentConstructor}\n\t\u003Cp>Loading...\u003C/p>\n{:then component}\n\t\u003Csvelte:component this={component} />\n{:catch error}\n\t\u003Cp>Something went wrong: {error.message}\u003C/p>\n{/await}\n```\n\n## How do I use a different backend API server?\n\nYou can use [`event.fetch`](./load#Making-fetch-requests) to request data from an external API server, but be aware that you would need to deal with [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS), which will result in complications such as generally requiring requests to be preflighted resulting in higher latency. Requests to a separate subdomain may also increase latency due to an additional DNS lookup, TLS setup, etc. If you wish to use this method, you may find [`handleFetch`](./hooks#Server-hooks-handleFetch) helpful.\n\nAnother approach is to set up a proxy to bypass CORS headaches. In production, you would rewrite a path like `/api` to the API server; for local development, use Vite's [`server.proxy`](https://vitejs.dev/config/server-options.html#server-proxy) option.\n\nHow to setup rewrites in production will depend on your deployment platform. If rewrites aren't an option, you could alternatively add an [API route](./routing#server):\n\n```js\n/// file: src/routes/api/[...path]/+server.js\n/** @type {import('./$types').RequestHandler} */\nexport function GET({ params, url }) {\n\treturn fetch(`https://example.com/${params.path + url.search}`);\n}\n```\n\n(Note that you may also need to proxy `POST`/`PATCH` etc requests, and forward `request.headers`, depending on your needs.)\n\n## How do I use middleware?\n\n`adapter-node` builds a middleware that you can use with your own server for production mode. In dev, you can add middleware to Vite by using a Vite plugin. For example:\n\n```js\n// @errors: 2322\n// @filename: ambient.d.ts\ndeclare module '@sveltejs/kit/vite'; // TODO this feels unnecessary, why can't it 'see' the declarations?\n\n// @filename: index.js\n// ---cut---\nimport { sveltekit } from '@sveltejs/kit/vite';\n\n/** @type {import('vite').Plugin} */\nconst myPlugin = {\n\tname: 'log-request-middleware',\n\tconfigureServer(server) {\n\t\tserver.middlewares.use((req, res, next) => {\n\t\t\tconsole.log(`Got request ${req.url}`);\n\t\t\tnext();\n\t\t});\n\t}\n};\n\n/** @type {import('vite').UserConfig} */\nconst config = {\n\tplugins: [myPlugin, sveltekit()]\n};\n\nexport default config;\n```\n\nSee [Vite's `configureServer` docs](https://vitejs.dev/guide/api-plugin.html#configureserver) for more details including how to control ordering.\n\n## How do I use Yarn?\n\n### Does it work with Yarn 2?\n\nSort of. The Plug'n'Play feature, aka 'pnp', is broken (it deviates from the Node module resolution algorithm, and [doesn't yet work with native JavaScript modules](https://github.com/yarnpkg/berry/issues/638) which SvelteKit — along with an [increasing number of packages](https://blog.sindresorhus.com/get-ready-for-esm-aa53530b3f77) — uses). You can use `nodeLinker: 'node-modules'` in your [`.yarnrc.yml`](https://yarnpkg.com/configuration/yarnrc#nodeLinker) file to disable pnp, but it's probably easier to just use npm or [pnpm](https://pnpm.io/), which is similarly fast and efficient but without the compatibility headaches.\n\n### How do I use with Yarn 3?\n\nCurrently ESM Support within the latest Yarn (version 3) is considered [experimental](https://github.com/yarnpkg/berry/pull/2161).\n\nThe below seems to work although your results may vary. First create a new application:\n\n```sh\nyarn create svelte myapp\ncd myapp\n```\n\nAnd enable Yarn Berry:\n\n```sh\nyarn set version berry\nyarn install\n```\n\nOne of the more interesting features of Yarn Berry is the ability to have a single global cache for packages, instead of having multiple copies for each project on the disk. However, setting `enableGlobalCache` to true causes building to fail, so it is recommended to add the following to the `.yarnrc.yml` file:\n\n```yaml\nnodeLinker: node-modules\n```\n\nThis will cause packages to be downloaded into a local node_modules directory but avoids the above problem and is your best bet for using version 3 of Yarn at this point in time.\n","## Package.json in Application\nImport JSON with: `import pkg from './package.json' with { type: 'json' };`\n\n## Library Packaging Issues\nCheck library compatibility at publint.dev. Key points:\n- `exports` field takes precedence over `main` and `module`\n- ESM files should end with `.mjs` (or any extension if `\"type\": \"module\"` is set); CommonJS files should end with `.cjs`\n- `main` should be defined if `exports` is not\n- Svelte components should be distributed as uncompiled `.svelte` files with ESM-only JS\n- Use `svelte-package` for packaging Svelte libraries\n- Libraries work best with ESM versions; CommonJS dependencies are pre-bundled by vite-plugin-svelte using esbuild\n- Troubleshoot with `optimizeDeps` or `ssr` config values if needed\n\n## View Transitions API\nCall `document.startViewTransition` in `onNavigate` to trigger transitions on client-side navigation:\n```js\nimport { onNavigate } from '$app/navigation';\nonNavigate((navigation) => {\n\tif (!document.startViewTransition) return;\n\treturn new Promise((resolve) => {\n\t\tdocument.startViewTransition(async () => {\n\t\t\tresolve();\n\t\t\tawait navigation.complete;\n\t\t});\n\t});\n});\n```\n\n## Database Setup\nPut database queries in server routes, not .svelte files. Create a `db.js` singleton for connection management. Use `hooks.server.js` for one-time setup code. Use Svelte CLI to automatically set up database integrations.\n\n## Client-side Libraries Accessing document/window\nWrap in browser check: `import { browser } from '$app/environment'; if (browser) { /* code */ }`\n\nOr use `onMount` for code that runs after first DOM render:\n```js\nimport { onMount } from 'svelte';\nonMount(async () => {\n\tconst { method } = await import('some-browser-only-library');\n\tmethod('hello world');\n});\n```\n\nFor side-effect-free libraries, static import works (tree-shaken in server build):\n```js\nimport { method } from 'some-browser-only-library';\nonMount(() => { method('hello world'); });\n```\n\nOr use `{#await}` block for dynamic imports.\n\n## Different Backend API Server\nUse `event.fetch` to request from external API, but handle CORS complications. Better approach: set up a proxy. In production, rewrite paths like `/api` to the API server; in dev, use Vite's `server.proxy` option. Alternatively, create an API route:\n```js\nexport function GET({ params, url }) {\n\treturn fetch(`https://example.com/${params.path + url.search}`);\n}\n```\n\n## Middleware\nFor production with adapter-node, build a middleware for your own server. For dev, add middleware via Vite plugin using `configureServer`:\n```js\nconst myPlugin = {\n\tname: 'log-request-middleware',\n\tconfigureServer(server) {\n\t\tserver.middlewares.use((req, res, next) => {\n\t\t\tconsole.log(`Got request ${req.url}`);\n\t\t\tnext();\n\t\t});\n\t}\n};\n```\n\n## Yarn Support\nYarn 2: Plug'n'Play (pnp) is broken with ESM. Use `nodeLinker: 'node-modules'` in `.yarnrc.yml` or switch to npm/pnpm.\n\nYarn 3: ESM support is experimental. Add `nodeLinker: node-modules` to `.yarnrc.yml` to use local node_modules instead of global cache.","## Package.json\n`import pkg from './package.json' with { type: 'json' };`\n\n## Library Packaging\nCheck publint.dev. Ensure `exports` field, correct file extensions (`.mjs`/`.cjs`), and Svelte components as uncompiled `.svelte` files. Use `svelte-package` for Svelte libraries.\n\n## View Transitions\n```js\nimport { onNavigate } from '$app/navigation';\nonNavigate((navigation) => {\n\tif (!document.startViewTransition) return;\n\treturn new Promise((resolve) => {\n\t\tdocument.startViewTransition(async () => {\n\t\t\tresolve();\n\t\t\tawait navigation.complete;\n\t\t});\n\t});\n});\n```\n\n## Database\nPut queries in server routes. Create `db.js` singleton. Use `hooks.server.js` for setup.\n\n## Client-side Libraries\nUse `import { browser } from '$app/environment'` check, `onMount`, or `{#await}` blocks.\n\n## Backend API Proxy\nUse `event.fetch` or set up proxy with `server.proxy` in dev. In production, rewrite paths or create API route.\n\n## Middleware\nUse Vite plugin with `configureServer` in dev; adapter-node in production.\n\n## Yarn\nYarn 2: Use `nodeLinker: 'node-modules'` in `.yarnrc.yml`. Yarn 3: Same setting recommended for ESM support.","Common questions about SvelteKit development covering package management, library integration, APIs, databases, client-side code, proxying, middleware, and package managers.","integrations",{"name":881,"path":883,"children":884,"data":885},"appendix-&-reference/integrations",["Map"],{"type":22,"path":886,"relevant":44,"token_counts":887,"usage":891,"markdown":894},"60-appendix/20-integrations.md",{"fulltext":888,"digest":889,"short_digest":890},812,363,209,{"input":892,"output":893,"details":32},1855,695,{"fulltext":895,"digest":896,"short_digest":897,"essence":898},"---\ntitle: Integrations\n---\n\n## `vitePreprocess`\n\nIncluding [`vitePreprocess`](https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/preprocess.md) in your project will allow you to use the various flavors of CSS that Vite supports: PostCSS, SCSS, Less, Stylus, and SugarSS. If you set your project up with TypeScript it will be included by default:\n\n```js\n// svelte.config.js\nimport { vitePreprocess } from '@sveltejs/vite-plugin-svelte';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n  preprocess: [vitePreprocess()]\n};\n\nexport default config;\n```\n\nYou will also need to use a preprocessor if you're using TypeScript with Svelte 4. TypeScript is supported natively in Svelte 5 if you're using only the type syntax. To use more complex TypeScript syntax in Svelte 5, you will need still need a preprocessor and can use `vitePreprocess({ script: true })`.\n\n## Add-ons\n\nRun [`npx sv add`](/docs/cli/sv-add) to setup many different complex integrations with a single command including:\n- prettier (formatting)\n- eslint (linting)\n- vitest (unit testing)\n- playwright (e2e testing)\n- lucia (auth)\n- tailwind (CSS)\n- drizzle (DB)\n- paraglide (i18n)\n- mdsvex (markdown)\n- storybook (frontend workshop)\n\n## Packages\n\nCheck out [the packages page](/packages) for a curated set of high quality Svelte packages. You can also see [sveltesociety.dev](https://sveltesociety.dev/) for additional libraries, templates, and resources.\n\n## Additional integrations\n\n### `svelte-preprocess`\n\n`svelte-preprocess` has some additional functionality not found in `vitePreprocess` such as support for Pug, Babel, and global styles. However, `vitePreprocess` may be faster and require less configuration, so it is used by default. Note that CoffeeScript is [not supported](https://github.com/sveltejs/kit/issues/2920#issuecomment-996469815) by SvelteKit.\n\nYou will need to install `svelte-preprocess` with `npm i -D svelte-preprocess` and [add it to your `svelte.config.js`](https://github.com/sveltejs/svelte-preprocess/blob/main/docs/usage.md#with-svelte-config). After that, you will often need to [install the corresponding library](https://github.com/sveltejs/svelte-preprocess/blob/main/docs/getting-started.md) such as `npm i -D sass` or `npm i -D less`.\n\n## Vite plugins\n\nSince SvelteKit projects are built with Vite, you can use Vite plugins to enhance your project. See a list of available plugins at [`vitejs/awesome-vite`](https://github.com/vitejs/awesome-vite?tab=readme-ov-file#plugins).\n\n## Integration FAQs\n\n[The SvelteKit FAQ](./faq) answers many questions about how to do X with SvelteKit, which may be helpful if you still have questions.\n","## vitePreprocess\n\nInclude `vitePreprocess` from `@sveltejs/vite-plugin-svelte` to use CSS flavors supported by Vite: PostCSS, SCSS, Less, Stylus, and SugarSS. Included by default with TypeScript setup.\n\n```js\nimport { vitePreprocess } from '@sveltejs/vite-plugin-svelte';\n\nconst config = {\n  preprocess: [vitePreprocess()]\n};\n```\n\nTypeScript support: native in Svelte 5 for type syntax only; use `vitePreprocess({ script: true })` for complex TypeScript in Svelte 5 or any TypeScript in Svelte 4.\n\n## Add-ons\n\nUse `npx sv add` to setup integrations: prettier, eslint, vitest, playwright, lucia, tailwind, drizzle, paraglide, mdsvex, storybook.\n\n## Packages\n\nBrowse curated Svelte packages on the packages page or sveltesociety.dev for libraries, templates, and resources.\n\n## svelte-preprocess\n\nAlternative preprocessor with additional features: Pug, Babel, and global styles support. May be slower and require more configuration than vitePreprocess. Install with `npm i -D svelte-preprocess` and configure in svelte.config.js. CoffeeScript is not supported.\n\n## Vite plugins\n\nSvelteKit uses Vite, so Vite plugins can enhance projects. See vitejs/awesome-vite repository for available plugins.","## vitePreprocess\n\nEnable CSS preprocessors (PostCSS, SCSS, Less, Stylus, SugarSS) with `vitePreprocess` from `@sveltejs/vite-plugin-svelte`. Included by default with TypeScript. Use `vitePreprocess({ script: true })` for complex TypeScript in Svelte 5.\n\n## Add-ons\n\n`npx sv add` sets up: prettier, eslint, vitest, playwright, lucia, tailwind, drizzle, paraglide, mdsvex, storybook.\n\n## svelte-preprocess\n\nAlternative with Pug, Babel, global styles support. Install `npm i -D svelte-preprocess` and configure in svelte.config.js.\n\n## Vite plugins\n\nUse Vite plugins to enhance SvelteKit projects (see vitejs/awesome-vite).","Overview of available integrations and preprocessors for SvelteKit projects including vitePreprocess, add-ons, alternative preprocessors, and Vite plugins.","breakpoint-debugging",{"name":899,"path":901,"children":902,"data":903},"appendix-&-reference/breakpoint-debugging",["Map"],{"type":22,"path":904,"relevant":44,"token_counts":905,"usage":908,"markdown":911},"60-appendix/25-debugging.md",{"fulltext":906,"digest":907,"short_digest":436},723,313,{"input":909,"output":910,"details":32},1765,560,{"fulltext":912,"digest":913,"short_digest":914,"essence":915},"---\ntitle: Breakpoint Debugging\n---\n\nIn addition to the [`@debug`](../svelte/@debug) tag, you can also debug Svelte and SvelteKit projects using breakpoints within various tools and development environments. This includes both frontend and backend code.\n\nThe following guides assume your JavaScript runtime environment is Node.js.\n\n## Visual Studio Code\n\nWith the built-in debug terminal, you can set up breakpoints in source files within VSCode.\n\n1. Open the command palette: `CMD/Ctrl` + `Shift` + `P`.\n2. Find and launch \"Debug: JavaScript Debug Terminal\".\n3. Start your project using the debug terminal. For example: `npm run dev`.\n4. Set some breakpoints in your client or server-side source code.\n5. Trigger the breakpoint.\n\n### Launch via debug pane\n\nYou may alternatively set up a `.vscode/launch.json` in your project. To set one up automatically:\n\n1. Go to the \"Run and Debug\" pane.\n2. In the \"Run\" select menu, choose \"Node.js...\".\n3. Select the \"run script\" that corresponds to your project, such as \"Run script: dev\".\n4. Press the \"Start debugging\" play button, or hit `F5` to begin breakpoint debugging.\n\nHere's an example `launch.json`:\n\n```json\n{\n\t\"version\": \"0.2.0\",\n\t\"configurations\": [\n\t\t{\n\t\t\t\"command\": \"npm run dev\",\n\t\t\t\"name\": \"Run development server\",\n\t\t\t\"request\": \"launch\",\n\t\t\t\"type\": \"node-terminal\"\n\t\t}\n\t]\n}\n```\n\nFurther reading: \u003Chttps://code.visualstudio.com/docs/editor/debugging>.\n\n## Other Editors\n\nIf you use a different editor, these community guides might be useful for you:\n\n- [WebStorm Svelte: Debug Your Application](https://www.jetbrains.com/help/webstorm/svelte.html#ws_svelte_debug)\n- [Debugging JavaScript Frameworks in Neovim](https://theosteiner.de/debugging-javascript-frameworks-in-neovim)\n\n## Google Chrome and Microsoft Edge Developer Tools\n\nIt's possible to debug Node.js applications using a browser-based debugger.\n\n> [!NOTE] Note this only works with debugging client-side SvelteKit source maps.\n\n1. Run the `--inspect` flag when starting the Vite server with Node.js. For instance: `NODE_OPTIONS=\"--inspect\" npm run dev`\n2. Open your site in a new tab. Typically at `localhost:5173`.\n3. Open your browser's dev tools, and click on the \"Open dedicated DevTools for Node.js\" icon near the top-left. It should display the Node.js logo.\n4. Set up breakpoints and debug your application.\n\nYou may alternatively open the debugger devtools by navigating to `chrome://inspect` in Google Chrome, or `edge://inspect` in Microsoft Edge.\n\n## References\n\n- [Debugging Node.js](https://nodejs.org/en/learn/getting-started/debugging)\n","## Visual Studio Code\n\nUse the built-in debug terminal:\n1. Open command palette: `CMD/Ctrl` + `Shift` + `P`\n2. Launch \"Debug: JavaScript Debug Terminal\"\n3. Start your project: `npm run dev`\n4. Set breakpoints in source code\n5. Trigger the breakpoint\n\nAlternatively, set up `.vscode/launch.json`:\n```json\n{\n\t\"version\": \"0.2.0\",\n\t\"configurations\": [\n\t\t{\n\t\t\t\"command\": \"npm run dev\",\n\t\t\t\"name\": \"Run development server\",\n\t\t\t\"request\": \"launch\",\n\t\t\t\"type\": \"node-terminal\"\n\t\t}\n\t]\n}\n```\nThen use the \"Run and Debug\" pane to select and start debugging with `F5`.\n\n## Other Editors\n\nWebStorm and Neovim have community guides available for debugging Svelte applications.\n\n## Browser DevTools for Node.js\n\nDebug Node.js using Chrome or Edge DevTools:\n1. Run: `NODE_OPTIONS=\"--inspect\" npm run dev`\n2. Open site at `localhost:5173`\n3. Open browser dev tools and click \"Open dedicated DevTools for Node.js\" icon\n4. Set breakpoints and debug\n\nAlternatively, navigate to `chrome://inspect` or `edge://inspect` directly.","## Visual Studio Code\n\nDebug terminal: `CMD/Ctrl` + `Shift` + `P` → \"Debug: JavaScript Debug Terminal\" → `npm run dev` → set breakpoints\n\nOr use `.vscode/launch.json` with `\"type\": \"node-terminal\"` and start with `F5`.\n\n## Browser DevTools\n\nRun `NODE_OPTIONS=\"--inspect\" npm run dev`, open `localhost:5173`, click \"Open dedicated DevTools for Node.js\" in dev tools, or navigate to `chrome://inspect`.","Set breakpoints to debug SvelteKit projects using VSCode debug terminal, launch.json configuration, or browser DevTools with Node.js inspection.","migrating-to-sveltekit-v2",{"name":916,"path":918,"children":919,"data":920},"appendix-&-reference/migrating-to-sveltekit-v2",["Map"],{"type":22,"path":921,"relevant":44,"token_counts":922,"usage":925,"markdown":928},"60-appendix/30-migrating-to-sveltekit-2.md",{"fulltext":923,"digest":924,"short_digest":735},3679,671,{"input":926,"output":927,"details":32},4731,981,{"fulltext":929,"digest":930,"short_digest":931,"essence":932},"---\ntitle: Migrating to SvelteKit v2\n---\n\nUpgrading from SvelteKit version 1 to version 2 should be mostly seamless. There are a few breaking changes to note, which are listed here. You can use `npx sv migrate sveltekit-2` to migrate some of these changes automatically.\n\nWe highly recommend upgrading to the most recent 1.x version before upgrading to 2.0, so that you can take advantage of targeted deprecation warnings. We also recommend [updating to Svelte 4](../svelte/v4-migration-guide) first: Later versions of SvelteKit 1.x support it, and SvelteKit 2.0 requires it.\n\n## `redirect` and `error` are no longer thrown by you\n\nPreviously, you had to `throw` the values returned from `error(...)` and `redirect(...)` yourself. In SvelteKit 2 this is no longer the case — calling the functions is sufficient.\n\n```js\nimport { error } from '@sveltejs/kit'\n\n// ...\n---throw error(500, 'something went wrong');---\n+++error(500, 'something went wrong');+++\n```\n\n`svelte-migrate` will do these changes automatically for you.\n\nIf the error or redirect is thrown inside a `try {...}` block (hint: don't do this!), you can distinguish them from unexpected errors using [`isHttpError`](@sveltejs-kit#isHttpError) and [`isRedirect`](@sveltejs-kit#isRedirect) imported from `@sveltejs/kit`.\n\n## path is required when setting cookies\n\nWhen receiving a `Set-Cookie` header that doesn't specify a `path`, browsers will [set the cookie path](https://www.rfc-editor.org/rfc/rfc6265#section-5.1.4) to the parent of the resource in question. This behaviour isn't particularly helpful or intuitive, and frequently results in bugs because the developer expected the cookie to apply to the domain as a whole.\n\nAs of SvelteKit 2.0, you need to set a `path` when calling `cookies.set(...)`, `cookies.delete(...)` or `cookies.serialize(...)` so that there's no ambiguity. Most of the time, you probably want to use `path: '/'`, but you can set it to whatever you like, including relative paths — `''` means 'the current path', `'.'` means 'the current directory'.\n\n```js\n/** @type {import('./$types').PageServerLoad} */\nexport function load({ cookies }) {\n\tcookies.set(name, value, +++{ path: '/' }+++);\n\treturn { response }\n}\n```\n\n`svelte-migrate` will add comments highlighting the locations that need to be adjusted.\n\n## Top-level promises are no longer awaited\n\nIn SvelteKit version 1, if the top-level properties of the object returned from a `load` function were promises, they were automatically awaited. With the introduction of [streaming](/blog/streaming-snapshots-sveltekit) this behavior became a bit awkward as it forces you to nest your streamed data one level deep.\n\nAs of version 2, SvelteKit no longer differentiates between top-level and non-top-level promises. To get back the blocking behavior, use `await` (with `Promise.all` to prevent waterfalls, where appropriate):\n\n```js\n// @filename: ambient.d.ts\ndeclare const url: string;\n\n// @filename: index.js\n// ---cut---\n// If you have a single promise\n/** @type {import('./$types').PageServerLoad} */\nexport +++async+++ function load({ fetch }) {\n\tconst response = +++await+++ fetch(url).then(r => r.json());\n\treturn { response }\n}\n```\n\n```js\n// @filename: ambient.d.ts\ndeclare const url1: string;\ndeclare const url2: string;\n\n// @filename: index.js\n// ---cut---\n// If you have multiple promises\n/** @type {import('./$types').PageServerLoad} */\nexport +++async+++ function load({ fetch }) {\n---\tconst a = fetch(url1).then(r => r.json());---\n---\tconst b = fetch(url2).then(r => r.json());---\n+++\tconst [a, b] = await Promise.all([\n\t  fetch(url1).then(r => r.json()),\n\t  fetch(url2).then(r => r.json()),\n\t]);+++\n\treturn { a, b };\n}\n```\n\n## goto(...) changes\n\n`goto(...)` no longer accepts external URLs. To navigate to an external URL, use `window.location.href = url`. The `state` object now determines `$page.state` and must adhere to the `App.PageState` interface, if declared. See [shallow routing](shallow-routing) for more details.\n\n## paths are now relative by default\n\nIn SvelteKit 1, `%sveltekit.assets%` in your `app.html` was replaced with a relative path by default (i.e. `.` or `..` or `../..` etc, depending on the path being rendered) during server-side rendering unless the [`paths.relative`](configuration#paths) config option was explicitly set to `false`. The same was true for `base` and `assets` imported from `$app/paths`, but only if the `paths.relative` option was explicitly set to `true`.\n\nThis inconsistency is fixed in version 2. Paths are either always relative or always absolute, depending on the value of [`paths.relative`](configuration#paths). It defaults to `true` as this results in more portable apps: if the `base` is something other than the app expected (as is the case when viewed on the [Internet Archive](https://archive.org/), for example) or unknown at build time (as is the case when deploying to [IPFS](https://ipfs.tech/) and so on), fewer things are likely to break.\n\n## Server fetches are not trackable anymore\n\nPreviously it was possible to track URLs from `fetch`es on the server in order to rerun load functions. This poses a possible security risk (private URLs leaking), and for this reason it was behind the `dangerZone.trackServerFetches` setting, which is now removed.\n\n## `preloadCode` arguments must be prefixed with `base`\n\nSvelteKit exposes two functions, [`preloadCode`]($app-navigation#preloadCode) and [`preloadData`]($app-navigation#preloadData), for programmatically loading the code and data associated with a particular path. In version 1, there was a subtle inconsistency — the path passed to `preloadCode` did not need to be prefixed with the `base` path (if set), while the path passed to `preloadData` did.\n\nThis is fixed in SvelteKit 2 — in both cases, the path should be prefixed with `base` if it is set.\n\nAdditionally, `preloadCode` now takes a single argument rather than _n_ arguments.\n\n## `resolvePath` has been removed\n\nSvelteKit 1 included a function called `resolvePath` which allows you to resolve a route ID (like `/blog/[slug]`) and a set of parameters (like `{ slug: 'hello' }`) to a pathname. Unfortunately the return value didn't include the `base` path, limiting its usefulness in cases where `base` was set.\n\nFor this reason, SvelteKit 2 replaces `resolvePath` with a (slightly better named) function called `resolveRoute`, which is imported from `$app/paths` and which takes `base` into account.\n\n```js\n---import { resolvePath } from '@sveltejs/kit';\nimport { base } from '$app/paths';---\n+++import { resolveRoute } from '$app/paths';+++\n\n---const path = base + resolvePath('/blog/[slug]', { slug });---\n+++const path = resolveRoute('/blog/[slug]', { slug });+++\n```\n\n`svelte-migrate` will do the method replacement for you, though if you later prepend the result with `base`, you need to remove that yourself.\n\n## Improved error handling\n\nErrors are handled inconsistently in SvelteKit 1. Some errors trigger the `handleError` hook but there is no good way to discern their status (for example, the only way to tell a 404 from a 500 is by seeing if `event.route.id` is `null`), while others (such as 405 errors for `POST` requests to pages without actions) don't trigger `handleError` at all, but should. In the latter case, the resulting `$page.error` will deviate from the [`App.Error`](types#Error) type, if it is specified.\n\nSvelteKit 2 cleans this up by calling `handleError` hooks with two new properties: `status` and `message`. For errors thrown from your code (or library code called by your code) the status will be `500` and the message will be `Internal Error`. While `error.message` may contain sensitive information that should not be exposed to users, `message` is safe.\n\n## Dynamic environment variables cannot be used during prerendering\n\nThe `$env/dynamic/public` and `$env/dynamic/private` modules provide access to _run time_ environment variables, as opposed to the _build time_ environment variables exposed by `$env/static/public` and `$env/static/private`.\n\nDuring prerendering in SvelteKit 1, they are one and the same. This means that prerendered pages that make use of 'dynamic' environment variables are really 'baking in' build time values, which is incorrect. Worse, `$env/dynamic/public` is populated in the browser with these stale values if the user happens to land on a prerendered page before navigating to dynamically-rendered pages.\n\nBecause of this, dynamic environment variables can no longer be read during prerendering in SvelteKit 2 — you should use the `static` modules instead. If the user lands on a prerendered page, SvelteKit will request up-to-date values for `$env/dynamic/public` from the server (by default from a module called `/_app/env.js`) instead of reading them from the server-rendered HTML.\n\n## `form` and `data` have been removed from `use:enhance` callbacks\n\nIf you provide a callback to [`use:enhance`](form-actions#Progressive-enhancement-use:enhance), it will be called with an object containing various useful properties.\n\nIn SvelteKit 1, those properties included `form` and `data`. These were deprecated some time ago in favour of `formElement` and `formData`, and have been removed altogether in SvelteKit 2.\n\n## Forms containing file inputs must use `multipart/form-data`\n\nIf a form contains an `\u003Cinput type=\"file\">` but does not have an `enctype=\"multipart/form-data\"` attribute, non-JS submissions will omit the file. SvelteKit 2 will throw an error if it encounters a form like this during a `use:enhance` submission to ensure that your forms work correctly when JavaScript is not present.\n\n## Generated `tsconfig.json` is more strict\n\nPreviously, the generated `tsconfig.json` was trying its best to still produce a somewhat valid config when your `tsconfig.json` included `paths` or `baseUrl`. In SvelteKit 2, the validation is more strict and will warn when you use either `paths` or `baseUrl` in your `tsconfig.json`. These settings are used to generate path aliases and you should use [the `alias` config](configuration#alias) option in your `svelte.config.js` instead, to also create a corresponding alias for the bundler.\n\n## `getRequest` no longer throws errors\n\nThe `@sveltejs/kit/node` module exports helper functions for use in Node environments, including `getRequest` which turns a Node [`ClientRequest`](https://nodejs.org/api/http.html#class-httpclientrequest) into a standard [`Request`](https://developer.mozilla.org/en-US/docs/Web/API/Request) object.\n\nIn SvelteKit 1, `getRequest` could throw if the `Content-Length` header exceeded the specified size limit. In SvelteKit 2, the error will not be thrown until later, when the request body (if any) is being read. This enables better diagnostics and simpler code.\n\n## `vitePreprocess` is no longer exported from `@sveltejs/kit/vite`\n\nSince `@sveltejs/vite-plugin-svelte` is now a peer dependency, SvelteKit 2 no longer re-exports `vitePreprocess`. You should import it directly from `@sveltejs/vite-plugin-svelte`.\n\n## Updated dependency requirements\n\nSvelteKit 2 requires Node `18.13` or higher, and the following minimum dependency versions:\n\n- `svelte@4`\n- `vite@5`\n- `typescript@5`\n- `@sveltejs/vite-plugin-svelte@3` (this is now required as a `peerDependency` of SvelteKit — previously it was directly depended upon)\n- `@sveltejs/adapter-cloudflare@3` (if you're using these adapters)\n- `@sveltejs/adapter-cloudflare-workers@2`\n- `@sveltejs/adapter-netlify@3`\n- `@sveltejs/adapter-node@2`\n- `@sveltejs/adapter-static@3`\n- `@sveltejs/adapter-vercel@4`\n\n`svelte-migrate` will update your `package.json` for you.\n\nAs part of the TypeScript upgrade, the generated `tsconfig.json` (the one your `tsconfig.json` extends from) now uses `\"moduleResolution\": \"bundler\"` (which is recommended by the TypeScript team, as it properly resolves types from packages with an `exports` map in package.json) and `verbatimModuleSyntax` (which replaces the existing `importsNotUsedAsValues ` and `preserveValueImports` flags — if you have those in your `tsconfig.json`, remove them. `svelte-migrate` will do this for you).\n\n## SvelteKit 2.12: $app/stores deprecated\n\nSvelteKit 2.12 introduced `$app/state` based on the [Svelte 5 runes API](/docs/svelte/what-are-runes). `$app/state` provides everything that `$app/stores` provides but with more flexibility as to where and how you use it. Most importantly, the `page` object is now fine-grained, e.g. updates to `page.state` will not invalidate `page.data` and vice-versa.\n\nAs a consequence, `$app/stores` is deprecated and subject to be removed in SvelteKit 3. We recommend [upgrading to Svelte 5](/docs/svelte/v5-migration-guide), if you haven't already, and then migrate away from `$app/stores`. Most of the replacements should be pretty simple: Replace the `$app/stores` import with `$app/state` and remove the `$` prefixes from the usage sites.\n\n```svelte\n\u003Cscript>\n\t---import { page } from '$app/stores';---\n\t+++import { page } from '$app/state';+++\n\u003C/script>\n\n---{$page.data}---\n+++{page.data}+++\n```\n\nUse `npx sv migrate app-state` to auto-migrate most of your `$app/stores` usages inside `.svelte` components.\n","## Breaking Changes\n\n**`redirect` and `error` no longer require throwing:**\n```js\n// Before\nthrow error(500, 'something went wrong');\n// After\nerror(500, 'something went wrong');\n```\n\n**`path` is required when setting cookies:**\n```js\ncookies.set(name, value, { path: '/' });\ncookies.delete(name, { path: '/' });\n```\n\n**Top-level promises are no longer awaited:**\n```js\n// Before: automatically awaited\nexport function load({ fetch }) {\n  const response = fetch(url).then(r => r.json());\n  return { response };\n}\n// After: must explicitly await\nexport async function load({ fetch }) {\n  const response = await fetch(url).then(r => r.json());\n  return { response };\n}\n```\n\n**`goto()` no longer accepts external URLs** — use `window.location.href` instead.\n\n**Paths are now relative by default** — `paths.relative` defaults to `true` for more portable apps.\n\n**`preloadCode` arguments must be prefixed with `base`** and now takes a single argument instead of multiple.\n\n**`resolvePath` replaced with `resolveRoute`:**\n```js\n// Before\nimport { resolvePath } from '@sveltejs/kit';\nimport { base } from '$app/paths';\nconst path = base + resolvePath('/blog/[slug]', { slug });\n// After\nimport { resolveRoute } from '$app/paths';\nconst path = resolveRoute('/blog/[slug]', { slug });\n```\n\n**Improved error handling** — `handleError` hooks now receive `status` and `message` properties.\n\n**Dynamic environment variables cannot be used during prerendering** — use `$env/static/public` and `$env/static/private` instead.\n\n**`form` and `data` removed from `use:enhance` callbacks** — use `formElement` and `formData` instead.\n\n**Forms with file inputs must have `enctype=\"multipart/form-data\"`** or SvelteKit will throw an error.\n\n**`vitePreprocess` no longer exported from `@sveltejs/kit/vite`** — import from `@sveltejs/vite-plugin-svelte` instead.\n\n**Minimum dependency versions:** Node 18.13+, Svelte 4, Vite 5, TypeScript 5, and updated adapter versions.\n\n**SvelteKit 2.12: `$app/stores` deprecated** in favor of `$app/state`:\n```svelte\n// Before\nimport { page } from '$app/stores';\n{$page.data}\n// After\nimport { page } from '$app/state';\n{page.data}\n```\n\nUse `npx sv migrate sveltekit-2` to automatically apply most changes.","## Key Changes\n\n- `error()` and `redirect()` no longer need `throw`\n- `cookies.set/delete` require `path` parameter\n- Top-level promises must be explicitly `await`ed\n- `goto()` rejects external URLs\n- `preloadCode` requires `base` prefix\n- `resolvePath` → `resolveRoute`\n- Dynamic env vars blocked during prerendering\n- `$app/stores` deprecated → use `$app/state`\n- Forms with file inputs need `enctype=\"multipart/form-data\"`\n- Node 18.13+, Svelte 4, Vite 5, TypeScript 5 required\n\nRun `npx sv migrate sveltekit-2` for automatic migration.","Breaking changes and migration guide for upgrading from SvelteKit v1 to v2, including API changes for error handling, cookies, promises, routing, and environment variables.","migrating-from-sapper",{"name":933,"path":935,"children":936,"data":937},"appendix-&-reference/migrating-from-sapper",["Map"],{"type":22,"path":938,"relevant":44,"token_counts":939,"usage":942,"markdown":945},"60-appendix/40-migrating.md",{"fulltext":940,"digest":941,"short_digest":102},2571,868,{"input":943,"output":944,"details":32},3614,1300,{"fulltext":946,"digest":947,"short_digest":948,"essence":949},"---\ntitle: Migrating from Sapper\nrank: 1\n---\n\nSvelteKit is the successor to Sapper and shares many elements of its design.\n\nIf you have an existing Sapper app that you plan to migrate to SvelteKit, there are a number of changes you will need to make. You may find it helpful to view [some examples](additional-resources#Examples) while migrating.\n\n## package.json\n\n### type: \"module\"\n\nAdd `\"type\": \"module\"` to your `package.json`. You can do this step separately from the rest as part of an incremental migration if you are using Sapper 0.29.3\nor newer.\n\n### dependencies\n\nRemove `polka` or `express`, if you're using one of those, and any middleware such as `sirv` or `compression`.\n\n### devDependencies\n\nRemove `sapper` from your `devDependencies` and replace it with `@sveltejs/kit` and whichever [adapter](adapters) you plan to use (see [next section](migrating#Project-files-Configuration)).\n\n### scripts\n\nAny scripts that reference `sapper` should be updated:\n\n- `sapper build` should become `vite build` using the Node [adapter](adapters)\n- `sapper export` should become `vite build` using the static [adapter](adapters)\n- `sapper dev` should become `vite dev`\n- `node __sapper__/build` should become `node build`\n\n## Project files\n\nThe bulk of your app, in `src/routes`, can be left where it is, but several project files will need to be moved or updated.\n\n### Configuration\n\nYour `webpack.config.js` or `rollup.config.js` should be replaced with a `svelte.config.js`, as documented [here](configuration). Svelte preprocessor options should be moved to `config.preprocess`.\n\nYou will need to add an [adapter](adapters). `sapper build` is roughly equivalent to [adapter-node](adapter-node) while `sapper export` is roughly equivalent to [adapter-static](adapter-static), though you might prefer to use an adapter designed for the platform you're deploying to.\n\nIf you were using plugins for filetypes that are not automatically handled by [Vite](https://vitejs.dev), you will need to find Vite equivalents and add them to the [Vite config](project-structure#Project-files-vite.config.js).\n\n### src/client.js\n\nThis file has no equivalent in SvelteKit. Any custom logic (beyond `sapper.start(...)`) should be expressed in your `+layout.svelte` file, inside an `onMount` callback.\n\n### src/server.js\n\nWhen using `adapter-node` the equivalent is a [custom server](adapter-node#Custom-server). Otherwise, this file has no direct equivalent, since SvelteKit apps can run in serverless environments.\n\n### src/service-worker.js\n\nMost imports from `@sapper/service-worker` have equivalents in [`$service-worker`]($service-worker):\n\n- `files` is unchanged\n- `routes` has been removed\n- `shell` is now `build`\n- `timestamp` is now `version`\n\n### src/template.html\n\nThe `src/template.html` file should be renamed `src/app.html`.\n\nRemove `%sapper.base%`, `%sapper.scripts%` and `%sapper.styles%`. Replace `%sapper.head%` with `%sveltekit.head%` and `%sapper.html%` with `%sveltekit.body%`. The `\u003Cdiv id=\"sapper\">` is no longer necessary.\n\n### src/node_modules\n\nA common pattern in Sapper apps is to put your internal library in a directory inside `src/node_modules`. This doesn't work with Vite, so we use [`src/lib`]($lib) instead.\n\n## Pages and layouts\n\n### Renamed files\n\nRoutes now are made up of the folder name exclusively to remove ambiguity, the folder names leading up to a `+page.svelte` correspond to the route. See [the routing docs](routing) for an overview. The following shows a old/new comparison:\n\n| Old                       | New                       |\n| ------------------------- | ------------------------- |\n| routes/about/index.svelte | routes/about/+page.svelte |\n| routes/about.svelte       | routes/about/+page.svelte |\n\nYour custom error page component should be renamed from `_error.svelte` to `+error.svelte`. Any `_layout.svelte` files should likewise be renamed `+layout.svelte`. [Any other files are ignored](routing#Other-files).\n\n### Imports\n\nThe `goto`, `prefetch` and `prefetchRoutes` imports from `@sapper/app` should be replaced with `goto`, `preloadData` and `preloadCode` imports respectively from [`$app/navigation`]($app-navigation).\n\nThe `stores` import from `@sapper/app` should be replaced — see the [Stores](migrating#Pages-and-layouts-Stores) section below.\n\nAny files you previously imported from directories in `src/node_modules` will need to be replaced with [`$lib`]($lib) imports.\n\n### Preload\n\nAs before, pages and layouts can export a function that allows data to be loaded before rendering takes place.\n\nThis function has been renamed from `preload` to [`load`](load), it now lives in a `+page.js` (or `+layout.js`) next to its `+page.svelte` (or `+layout.svelte`), and its API has changed. Instead of two arguments — `page` and `session` — there is a single `event` argument.\n\nThere is no more `this` object, and consequently no `this.fetch`, `this.error` or `this.redirect`. Instead, you can get [`fetch`](load#Making-fetch-requests) from the input methods, and both [`error`](load#Errors) and [`redirect`](load#Redirects) are now thrown.\n\n### Stores\n\nIn Sapper, you would get references to provided stores like so:\n\n```js\n// @filename: ambient.d.ts\ndeclare module '@sapper/app';\n\n// @filename: index.js\n// ---cut---\nimport { stores } from '@sapper/app';\nconst { preloading, page, session } = stores();\n```\n\nThe `page` store still exists; `preloading` has been replaced with a `navigating` store that contains `from` and `to` properties. `page` now has `url` and `params` properties, but no `path` or `query`.\n\nYou access them differently in SvelteKit. `stores` is now `getStores`, but in most cases it is unnecessary since you can import `navigating`, and `page` directly from [`$app/stores`]($app-stores). If you're on Svelte 5 and SvelteKit 2.12 or higher, consider using [`$app/state`]($app-state) instead.\n\n### Routing\n\nRegex routes are no longer supported. Instead, use [advanced route matching](advanced-routing#Matching).\n\n### Segments\n\nPreviously, layout components received a `segment` prop indicating the child segment. This has been removed; you should use the more flexible `$page.url.pathname` (or `page.url.pathname`) value to derive the segment you're interested in.\n\n### URLs\n\nIn Sapper, all relative URLs were resolved against the base URL — usually `/`, unless the `basepath` option was used — rather than against the current page.\n\nThis caused problems and is no longer the case in SvelteKit. Instead, relative URLs are resolved against the current page (or the destination page, for `fetch` URLs in `load` functions) instead. In most cases, it's easier to use root-relative (i.e. starts with `/`) URLs, since their meaning is not context-dependent.\n\n### &lt;a&gt; attributes\n\n- `sapper:prefetch` is now `data-sveltekit-preload-data`\n- `sapper:noscroll` is now `data-sveltekit-noscroll`\n\n## Endpoints\n\nIn Sapper, [server routes](routing#server) received the `req` and `res` objects exposed by Node's `http` module (or the augmented versions provided by frameworks like Polka and Express).\n\nSvelteKit is designed to be agnostic as to where the app is running — it could be running on a Node server, but could equally be running on a serverless platform or in a Cloudflare Worker. For that reason, you no longer interact directly with `req` and `res`. Your endpoints will need to be updated to match the new signature.\n\nTo support this environment-agnostic behavior, `fetch` is now available in the global context, so you don't need to import `node-fetch`, `cross-fetch`, or similar server-side fetch implementations in order to use it.\n\n## Integrations\n\nSee [integrations](./integrations) for detailed information about integrations.\n\n### HTML minifier\n\nSapper includes `html-minifier` by default. SvelteKit does not include this, but you can add it as a prod dependency and then use it through a [hook](hooks#Server-hooks-handle):\n\n```js\n// @filename: ambient.d.ts\n/// \u003Creference types=\"@sveltejs/kit\" />\ndeclare module 'html-minifier';\n\n// @filename: index.js\n// ---cut---\nimport { minify } from 'html-minifier';\nimport { building } from '$app/environment';\n\nconst minification_options = {\n\tcollapseBooleanAttributes: true,\n\tcollapseWhitespace: true,\n\tconservativeCollapse: true,\n\tdecodeEntities: true,\n\thtml5: true,\n\tignoreCustomComments: [/^#/],\n\tminifyCSS: true,\n\tminifyJS: false,\n\tremoveAttributeQuotes: true,\n\tremoveComments: false, // some hydration code needs comments, so leave them in\n\tremoveOptionalTags: true,\n\tremoveRedundantAttributes: true,\n\tremoveScriptTypeAttributes: true,\n\tremoveStyleLinkTypeAttributes: true,\n\tsortAttributes: true,\n\tsortClassName: true\n};\n\n/** @type {import('@sveltejs/kit').Handle} */\nexport async function handle({ event, resolve }) {\n\tlet page = '';\n\n\treturn resolve(event, {\n\t\ttransformPageChunk: ({ html, done }) => {\n\t\t\tpage += html;\n\t\t\tif (done) {\n\t\t\t\treturn building ? minify(page, minification_options) : page;\n\t\t\t}\n\t\t}\n\t});\n}\n```\n\nNote that `prerendering` is `false` when using `vite preview` to test the production build of the site, so to verify the results of minifying, you'll need to inspect the built HTML files directly.\n","## package.json Changes\n- Add `\"type\": \"module\"`\n- Remove `polka`, `express`, `sirv`, `compression`\n- Replace `sapper` with `@sveltejs/kit` and an adapter\n- Update scripts: `sapper build` → `vite build`, `sapper export` → `vite build` (with static adapter), `sapper dev` → `vite dev`, `node __sapper__/build` → `node build`\n\n## Configuration\n- Replace `webpack.config.js` or `rollup.config.js` with `svelte.config.js`\n- Move Svelte preprocessor options to `config.preprocess`\n- Add an adapter (adapter-node for `sapper build`, adapter-static for `sapper export`)\n- Add Vite plugins for unhandled filetypes to `vite.config.js`\n\n## File Migrations\n- `src/client.js` → move logic to `+layout.svelte` in `onMount` callback\n- `src/server.js` → custom server with adapter-node or no equivalent for serverless\n- `src/service-worker.js`: `files` unchanged, `routes` removed, `shell` → `build`, `timestamp` → `version`\n- `src/template.html` → `src/app.html`: replace `%sapper.base%`, `%sapper.scripts%`, `%sapper.styles%` (remove), `%sapper.head%` → `%sveltekit.head%`, `%sapper.html%` → `%sveltekit.body%`, remove `\u003Cdiv id=\"sapper\">`\n- `src/node_modules` internal libraries → `src/lib`\n\n## Routing & Pages\n- `routes/about/index.svelte` → `routes/about/+page.svelte`\n- `routes/about.svelte` → `routes/about/+page.svelte`\n- `_error.svelte` → `+error.svelte`\n- `_layout.svelte` → `+layout.svelte`\n- Regex routes no longer supported; use advanced route matching\n\n## API Changes\n- `@sapper/app` imports: `goto`, `prefetch`, `prefetchRoutes` → `goto`, `preloadData`, `preloadCode` from `$app/navigation`\n- `stores` from `@sapper/app` → import `navigating`, `page` from `$app/stores` (or use `$app/state` in Svelte 5 + SvelteKit 2.12+)\n- `preload` function → `load` in `+page.js`/`+layout.js`, single `event` argument instead of `page` and `session`\n- No `this` object; use `fetch` from input, throw `error` and `redirect`\n- `preloading` store → `navigating` store with `from` and `to` properties\n- `page` store: has `url` and `params`, no `path` or `query`\n- `segment` prop removed; use `$page.url.pathname`\n- Relative URLs now resolve against current page, not base URL\n- `sapper:prefetch` → `data-sveltekit-preload-data`\n- `sapper:noscroll` → `data-sveltekit-noscroll`\n\n## Endpoints\n- No direct `req`/`res` access; SvelteKit is environment-agnostic\n- `fetch` available globally; no need to import node-fetch or cross-fetch\n\n## HTML Minification\nAdd html-minifier as dependency and use in server hook via `transformPageChunk`","## Key Changes\n- Add `\"type\": \"module\"` to package.json, replace `sapper` with `@sveltejs/kit` + adapter\n- Update scripts: `sapper build/dev/export` → `vite build/dev` (with appropriate adapter)\n- Replace `webpack.config.js`/`rollup.config.js` with `svelte.config.js`\n- File renames: `src/template.html` → `src/app.html`, `_layout.svelte` → `+layout.svelte`, `_error.svelte` → `+error.svelte`\n- Route renames: `routes/about.svelte` → `routes/about/+page.svelte`\n- `preload` → `load` function in `+page.js`/`+layout.js` with single `event` argument\n- `@sapper/app` imports: `goto`, `prefetch`, `prefetchRoutes` → `goto`, `preloadData`, `preloadCode` from `$app/navigation`\n- `stores()` → import `navigating`, `page` from `$app/stores`\n- No `req`/`res` access; `fetch` available globally\n- Relative URLs resolve against current page, not base URL","Comprehensive guide to migrating a Sapper application to SvelteKit, covering package.json updates, file structure changes, routing conventions, API migrations, and configuration updates.","additional-resources",{"name":950,"path":952,"children":953,"data":954},"appendix-&-reference/additional-resources",["Map"],{"type":22,"path":955,"relevant":44,"token_counts":956,"usage":960,"markdown":963},"60-appendix/50-additional-resources.md",{"fulltext":957,"digest":958,"short_digest":959},440,176,106,{"input":961,"output":962,"details":32},1484,388,{"fulltext":964,"digest":965,"short_digest":966,"essence":967},"---\ntitle: Additional resources\n---\n\n## FAQs\n\nPlease see the [SvelteKit FAQ](faq) for solutions to common issues and helpful tips and tricks.\n\nThe [Svelte FAQ](../svelte/faq) and [`vite-plugin-svelte` FAQ](https://github.com/sveltejs/vite-plugin-svelte/blob/main/docs/faq.md) may also be helpful for questions deriving from those libraries.\n\n## Examples\n\nWe've written and published a few different SvelteKit sites as examples:\n\n- [`sveltejs/realworld`](https://github.com/sveltejs/realworld) contains an example blog site\n- [A HackerNews clone](https://github.com/sveltejs/sites/tree/master/sites/hn.svelte.dev)\n- [`svelte.dev`](https://github.com/sveltejs/svelte.dev)\n\nSvelteKit users have also published plenty of examples on GitHub, under the [#sveltekit](https://github.com/topics/sveltekit) and [#sveltekit-template](https://github.com/topics/sveltekit-template) topics, as well as on [the Svelte Society site](https://sveltesociety.dev/templates?category=sveltekit). Note that these have not been vetted by the maintainers and may not be up to date.\n\n## Support\n\nYou can ask for help on [Discord](/chat) and [StackOverflow](https://stackoverflow.com/questions/tagged/sveltekit). Please first search for information related to your issue in the FAQ, Google or another search engine, issue tracker, and Discord chat history in order to be respectful of others' time. There are many more people asking questions than answering them, so this will help in allowing the community to grow in a scalable fashion.\n","## FAQs\n\nCheck the SvelteKit FAQ for common issues and tips. Also see the Svelte FAQ and vite-plugin-svelte FAQ for questions related to those libraries.\n\n## Examples\n\nOfficial examples:\n- `sveltejs/realworld` - example blog site\n- HackerNews clone at hn.svelte.dev\n- svelte.dev source code\n\nCommunity examples available on GitHub under #sveltekit and #sveltekit-template topics, and on Svelte Society site. Note: community examples are not vetted and may be outdated.\n\n## Support\n\nAsk for help on Discord or StackOverflow. Search FAQs, Google, issue trackers, and Discord history first to respect community time and help the community scale.","**FAQs**: SvelteKit FAQ, Svelte FAQ, vite-plugin-svelte FAQ\n\n**Examples**: Official - sveltejs/realworld (blog), HackerNews clone, svelte.dev. Community examples on GitHub (#sveltekit, #sveltekit-template) and Svelte Society (unvetted, may be outdated).\n\n**Support**: Discord, StackOverflow. Search existing resources first.","Links to FAQs, example projects, and community support channels for SvelteKit developers.","glossary",{"name":968,"path":970,"children":971,"data":972},"appendix-&-reference/glossary",["Map"],{"type":22,"path":973,"relevant":44,"token_counts":974,"usage":978,"markdown":981},"60-appendix/60-glossary.md",{"fulltext":975,"digest":976,"short_digest":977},1613,506,264,{"input":979,"output":980,"details":32},2656,904,{"fulltext":982,"digest":983,"short_digest":984,"essence":985},"---\ntitle: Glossary\n---\n\nThe core of SvelteKit provides a highly configurable rendering engine. This section describes some of the terms used when discussing rendering. A reference for setting these options is provided in the documentation above.\n\n## CSR\n\nClient-side rendering (CSR) is the generation of the page contents in the web browser using JavaScript.\n\nIn SvelteKit, client-side rendering will be used by default, but you can turn off JavaScript with [the `csr = false` page option](page-options#csr).\n\n## Edge\n\nRendering on the edge refers to rendering an application in a content delivery network (CDN) near the user. Edge rendering allows the request and response for a page to travel a shorter distance thus improving latency.\n\n## Hybrid app\n\nSvelteKit uses a hybrid rendering mode by default where it loads the initial HTML from the server (SSR), and then updates the page contents on subsequent navigations via client-side rendering (CSR).\n\n## Hydration\n\nSvelte components store some state and update the DOM when the state is updated. When fetching data during SSR, by default SvelteKit will store this data and transmit it to the client along with the server-rendered HTML. The components can then be initialized on the client with that data without having to call the same API endpoints again. Svelte will then check that the DOM is in the expected state and attach event listeners in a process called hydration. Once the components are fully hydrated, they can react to changes to their properties just like any newly created Svelte component.\n\nIn SvelteKit, pages will be hydrated by default, but you can turn off JavaScript with [the `csr = false` page option](page-options#csr).\n\n## ISR\n\nIncremental static regeneration (ISR) allows you to generate static pages on your site as visitors request those pages without redeploying. This may reduces build times compared to [SSG](#SSG) sites with a large number of pages. You can do [ISR with `adapter-vercel`](adapter-vercel#Incremental-Static-Regeneration).\n\n## MPA\n\nTraditional applications that render each page view on the server — such as those written in languages other than JavaScript — are often referred to as multi-page apps (MPA).\n\n## Prerendering\n\nPrerendering means computing the contents of a page at build time and saving the HTML for display. This approach has the same benefits as traditional server-rendered pages, but avoids recomputing the page for each visitor and so scales nearly for free as the number of visitors increases. The tradeoff is that the build process is more expensive and prerendered content can only be updated by building and deploying a new version of the application.\n\nNot all pages can be prerendered. The basic rule is this: for content to be prerenderable, any two users hitting it directly must get the same content from the server, and the page must not contain [actions](form-actions). Note that you can still prerender content that is loaded based on the page's parameters as long as all users will be seeing the same prerendered content.\n\nPre-rendered pages are not limited to static content. You can build personalized pages if user-specific data is fetched and rendered client-side. This is subject to the caveat that you will experience the downsides of not doing SSR for that content as discussed above.\n\nIn SvelteKit, you can control prerendering with [the `prerender` page option](page-options#prerender) and [`prerender` config](configuration#prerender) in `svelte.config.js`.\n\n## PWA\n\nA progressive web app (PWA) is an app that's built using web APIs and technologies, but functions like a mobile or desktop app. Sites served as [PWAs can be installed](https://web.dev/learn/pwa/installation), allowing you to add a shortcut to the application on your launcher, home screen, or start menu. Many PWAs will utilize [service workers](service-workers) to build offline capabilities.\n\n## Routing\n\nBy default, when you navigate to a new page (by clicking on a link or using the browser's forward or back buttons), SvelteKit will intercept the attempted navigation and handle it instead of allowing the browser to send a request to the server for the destination page. SvelteKit will then update the displayed contents on the client by rendering the component for the new page, which in turn can make calls to the necessary API endpoints. This process of updating the page on the client in response to attempted navigation is called client-side routing.\n\nIn SvelteKit, client-side routing will be used by default, but you can skip it with [`data-sveltekit-reload`](link-options#data-sveltekit-reload).\n\n## SPA\n\nA single-page app (SPA) is an application in which all requests to the server load a single HTML file which then does client-side rendering based on the requested URL. All navigation is handled on the client-side in a process called client-side routing with per-page contents being updated and common layout elements remaining largely unchanged. Throughout this site, when we refer to a SPA, we use this definition where a SPA simply serves an empty shell on the initial request. It should not be confused with a [hybrid app](#Hybrid-app), which serves HTML on the initial request. It has a large performance impact by forcing two network round trips before rendering can begin. Because SPA mode has large negative performance and SEO impacts, it is recommended only in very limited circumstances such as when being wrapped in a mobile app.\n\nIn SvelteKit, you can [build SPAs with `adapter-static`](single-page-apps).\n\n## SSG\n\nStatic Site Generation (SSG) is a term that refers to a site where every page is prerendered. One benefit of fully prerendering a site is that you do not need to maintain or pay for servers to perform SSR. Once generated, the site can be served from CDNs, leading to great “time to first byte” performance. This delivery model is often referred to as JAMstack.\n\nIn SvelteKit, you can do static site generation by using [`adapter-static`](adapter-static) or by configuring every page to be prerendered using [the `prerender` page option](page-options#prerender) or [`prerender` config](configuration#prerender) in `svelte.config.js`.\n\n## SSR\n\nServer-side rendering (SSR) is the generation of the page contents on the server. Returning the page contents from the server via SSR or prerendering is highly preferred for performance and SEO. It significantly improves performance by avoiding the introduction of extra round trips necessary in a SPA, and makes your app accessible to users if JavaScript fails or is disabled (which happens [more often than you probably think](https://kryogenix.org/code/browser/everyonehasjs.html)). While some search engines can index content that is dynamically generated on the client-side, it is likely to take longer even in these cases.\n\nIn SvelteKit, pages are server-side rendered by default. You can disable SSR with [the `ssr` page option](page-options#ssr).\n","## Rendering Modes\n\n**CSR (Client-Side Rendering)**: Page generation in the browser using JavaScript. Default in SvelteKit but can be disabled with `csr = false`.\n\n**SSR (Server-Side Rendering)**: Page generation on the server. Default in SvelteKit, can be disabled with `ssr = false`. Preferred for performance and SEO, improves accessibility when JavaScript fails.\n\n**Hybrid App**: SvelteKit's default mode combining SSR for initial HTML load with CSR for subsequent navigations.\n\n**SPA (Single-Page App)**: Serves a single empty HTML shell on initial request, all navigation handled client-side. Has performance and SEO downsides; recommended only for mobile app wrappers. Build with `adapter-static`.\n\n**SSG (Static Site Generation)**: Every page prerendered at build time. No server needed, served from CDNs. Use `adapter-static` or configure `prerender` option.\n\n**ISR (Incremental Static Regeneration)**: Generate static pages on-demand as visitors request them without redeploying. Available with `adapter-vercel`.\n\n## Related Concepts\n\n**Hydration**: Process where server-rendered HTML is enhanced with client-side interactivity. SvelteKit transmits fetched data with SSR HTML so components initialize without re-fetching APIs, then Svelte attaches event listeners. Enabled by default, disabled with `csr = false`.\n\n**Prerendering**: Computing page contents at build time and saving HTML. Scales for free with visitors but requires rebuilding to update content. Pages must return same content for all users and cannot contain form actions. Can still be personalized if user-specific data loads client-side.\n\n**Edge Rendering**: Rendering in CDNs near users to reduce latency.\n\n**Routing**: SvelteKit intercepts navigation by default and updates page client-side (client-side routing). Can be skipped with `data-sveltekit-reload`.\n\n**PWA (Progressive Web App)**: Web app installable as mobile/desktop app, often using service workers for offline capabilities.\n\n**MPA (Multi-Page App)**: Traditional server-rendered applications rendering each page view on the server.","## Rendering Modes\n\n- **CSR**: Browser-based rendering, default but can disable with `csr = false`\n- **SSR**: Server-side rendering, default, disable with `ssr = false`\n- **Hybrid**: Default SvelteKit mode (SSR initial + CSR navigation)\n- **SPA**: Single HTML shell, all client-side routing, use `adapter-static`\n- **SSG**: All pages prerendered, use `adapter-static` or `prerender` option\n- **ISR**: On-demand static generation with `adapter-vercel`\n\n## Key Concepts\n\n- **Hydration**: Server data transmitted with HTML, components initialize without re-fetching, event listeners attached\n- **Prerendering**: Build-time HTML generation, must return same content for all users, no form actions\n- **Edge Rendering**: CDN-based rendering near users\n- **Routing**: Client-side navigation by default, skip with `data-sveltekit-reload`\n- **PWA**: Installable web app with offline capabilities via service workers\n- **MPA**: Traditional server-rendered multi-page applications","Reference guide defining rendering modes (CSR, SSR, SPA, SSG, ISR, hybrid) and related concepts (hydration, prerendering, routing, PWA) used in SvelteKit.","appendix",{"name":986,"path":988,"children":989,"data":990},"appendix-&-reference/appendix",["Map"],{"type":22,"path":991,"relevant":24,"token_counts":992,"usage":994,"markdown":996},"60-appendix/index.md",{"fulltext":487,"digest":993,"short_digest":119},35,{"input":121,"output":995,"details":32},154,{"fulltext":997,"digest":998,"short_digest":999,"essence":1000},"---\ntitle: Appendix\n---\n","This page serves as an appendix section for the documentation. The actual content of the appendix is not provided in the page data shown.","Appendix section (content not available in provided data).","Appendix index page with no substantive content provided.",{"type":129,"path":1002,"relevant":44,"token_counts":1003,"usage":1007,"markdown":1010},"60-appendix",{"fulltext":1004,"digest":1005,"short_digest":1006},1799,1458,577,{"input":1008,"output":1009,"details":32},2924,2155,{"fulltext":1011,"digest":1012,"short_digest":1013,"essence":1014},"\n\n## Pages\n\n### frequently-asked-questions\nCommon questions about SvelteKit development covering package management, library integration, APIs, databases, client-side code, proxying, middleware, and package managers.\n\n## Package.json\n`import pkg from './package.json' with { type: 'json' };`\n\n## Library Packaging\nCheck publint.dev. Ensure `exports` field, correct file extensions (`.mjs`/`.cjs`), and Svelte components as uncompiled `.svelte` files. Use `svelte-package` for Svelte libraries.\n\n## View Transitions\n```js\nimport { onNavigate } from '$app/navigation';\nonNavigate((navigation) => {\n\tif (!document.startViewTransition) return;\n\treturn new Promise((resolve) => {\n\t\tdocument.startViewTransition(async () => {\n\t\t\tresolve();\n\t\t\tawait navigation.complete;\n\t\t});\n\t});\n});\n```\n\n## Database\nPut queries in server routes. Create `db.js` singleton. Use `hooks.server.js` for setup.\n\n## Client-side Libraries\nUse `import { browser } from '$app/environment'` check, `onMount`, or `{#await}` blocks.\n\n## Backend API Proxy\nUse `event.fetch` or set up proxy with `server.proxy` in dev. In production, rewrite paths or create API route.\n\n## Middleware\nUse Vite plugin with `configureServer` in dev; adapter-node in production.\n\n## Yarn\nYarn 2: Use `nodeLinker: 'node-modules'` in `.yarnrc.yml`. Yarn 3: Same setting recommended for ESM support.\n\n### integrations\nOverview of available integrations and preprocessors for SvelteKit projects including vitePreprocess, add-ons, alternative preprocessors, and Vite plugins.\n\n## vitePreprocess\n\nEnable CSS preprocessors (PostCSS, SCSS, Less, Stylus, SugarSS) with `vitePreprocess` from `@sveltejs/vite-plugin-svelte`. Included by default with TypeScript. Use `vitePreprocess({ script: true })` for complex TypeScript in Svelte 5.\n\n## Add-ons\n\n`npx sv add` sets up: prettier, eslint, vitest, playwright, lucia, tailwind, drizzle, paraglide, mdsvex, storybook.\n\n## svelte-preprocess\n\nAlternative with Pug, Babel, global styles support. Install `npm i -D svelte-preprocess` and configure in svelte.config.js.\n\n## Vite plugins\n\nUse Vite plugins to enhance SvelteKit projects (see vitejs/awesome-vite).\n\n### breakpoint-debugging\nSet breakpoints to debug SvelteKit projects using VSCode debug terminal, launch.json configuration, or browser DevTools with Node.js inspection.\n\n## Visual Studio Code\n\nDebug terminal: `CMD/Ctrl` + `Shift` + `P` → \"Debug: JavaScript Debug Terminal\" → `npm run dev` → set breakpoints\n\nOr use `.vscode/launch.json` with `\"type\": \"node-terminal\"` and start with `F5`.\n\n## Browser DevTools\n\nRun `NODE_OPTIONS=\"--inspect\" npm run dev`, open `localhost:5173`, click \"Open dedicated DevTools for Node.js\" in dev tools, or navigate to `chrome://inspect`.\n\n### migrating-to-sveltekit-v2\nBreaking changes and migration guide for upgrading from SvelteKit v1 to v2, including API changes for error handling, cookies, promises, routing, and environment variables.\n\n## Key Changes\n\n- `error()` and `redirect()` no longer need `throw`\n- `cookies.set/delete` require `path` parameter\n- Top-level promises must be explicitly `await`ed\n- `goto()` rejects external URLs\n- `preloadCode` requires `base` prefix\n- `resolvePath` → `resolveRoute`\n- Dynamic env vars blocked during prerendering\n- `$app/stores` deprecated → use `$app/state`\n- Forms with file inputs need `enctype=\"multipart/form-data\"`\n- Node 18.13+, Svelte 4, Vite 5, TypeScript 5 required\n\nRun `npx sv migrate sveltekit-2` for automatic migration.\n\n### migrating-from-sapper\nComprehensive guide to migrating a Sapper application to SvelteKit, covering package.json updates, file structure changes, routing conventions, API migrations, and configuration updates.\n\n## Key Changes\n- Add `\"type\": \"module\"` to package.json, replace `sapper` with `@sveltejs/kit` + adapter\n- Update scripts: `sapper build/dev/export` → `vite build/dev` (with appropriate adapter)\n- Replace `webpack.config.js`/`rollup.config.js` with `svelte.config.js`\n- File renames: `src/template.html` → `src/app.html`, `_layout.svelte` → `+layout.svelte`, `_error.svelte` → `+error.svelte`\n- Route renames: `routes/about.svelte` → `routes/about/+page.svelte`\n- `preload` → `load` function in `+page.js`/`+layout.js` with single `event` argument\n- `@sapper/app` imports: `goto`, `prefetch`, `prefetchRoutes` → `goto`, `preloadData`, `preloadCode` from `$app/navigation`\n- `stores()` → import `navigating`, `page` from `$app/stores`\n- No `req`/`res` access; `fetch` available globally\n- Relative URLs resolve against current page, not base URL\n\n### additional-resources\nLinks to FAQs, example projects, and community support channels for SvelteKit developers.\n\n**FAQs**: SvelteKit FAQ, Svelte FAQ, vite-plugin-svelte FAQ\n\n**Examples**: Official - sveltejs/realworld (blog), HackerNews clone, svelte.dev. Community examples on GitHub (#sveltekit, #sveltekit-template) and Svelte Society (unvetted, may be outdated).\n\n**Support**: Discord, StackOverflow. Search existing resources first.\n\n### glossary\nReference guide defining rendering modes (CSR, SSR, SPA, SSG, ISR, hybrid) and related concepts (hydration, prerendering, routing, PWA) used in SvelteKit.\n\n## Rendering Modes\n\n- **CSR**: Browser-based rendering, default but can disable with `csr = false`\n- **SSR**: Server-side rendering, default, disable with `ssr = false`\n- **Hybrid**: Default SvelteKit mode (SSR initial + CSR navigation)\n- **SPA**: Single HTML shell, all client-side routing, use `adapter-static`\n- **SSG**: All pages prerendered, use `adapter-static` or `prerender` option\n- **ISR**: On-demand static generation with `adapter-vercel`\n\n## Key Concepts\n\n- **Hydration**: Server data transmitted with HTML, components initialize without re-fetching, event listeners attached\n- **Prerendering**: Build-time HTML generation, must return same content for all users, no form actions\n- **Edge Rendering**: CDN-based rendering near users\n- **Routing**: Client-side navigation by default, skip with `data-sveltekit-reload`\n- **PWA**: Installable web app with offline capabilities via service workers\n- **MPA**: Traditional server-rendered multi-page applications\n\n","## Frequently Asked Questions\n\n**Package Management**: Import JSON with `import pkg from './package.json' with { type: 'json' };`. Use `nodeLinker: 'node-modules'` in `.yarnrc.yml` for Yarn 2/3 ESM support.\n\n**Library Packaging**: Validate with publint.dev. Ensure `exports` field, correct file extensions (`.mjs`/`.cjs`), and ship Svelte components as uncompiled `.svelte` files. Use `svelte-package` for Svelte libraries.\n\n**View Transitions**: \n```js\nimport { onNavigate } from '$app/navigation';\nonNavigate((navigation) => {\n\tif (!document.startViewTransition) return;\n\treturn new Promise((resolve) => {\n\t\tdocument.startViewTransition(async () => {\n\t\t\tresolve();\n\t\t\tawait navigation.complete;\n\t\t});\n\t});\n});\n```\n\n**Database**: Put queries in server routes, create `db.js` singleton, use `hooks.server.js` for setup.\n\n**Client-side Libraries**: Use `import { browser } from '$app/environment'` check, `onMount`, or `{#await}` blocks.\n\n**Backend API Proxy**: Use `event.fetch` in dev/prod, or set up proxy with `server.proxy` in dev and rewrite paths in production.\n\n**Middleware**: Use Vite plugin with `configureServer` in dev; use adapter-node in production.\n\n## Integrations\n\n**vitePreprocess**: Enables CSS preprocessors (PostCSS, SCSS, Less, Stylus, SugarSS). Included by default with TypeScript. Use `vitePreprocess({ script: true })` for complex TypeScript in Svelte 5.\n\n**Add-ons**: `npx sv add` installs prettier, eslint, vitest, playwright, lucia, tailwind, drizzle, paraglide, mdsvex, storybook.\n\n**Alternative Preprocessors**: `svelte-preprocess` supports Pug, Babel, global styles. Install and configure in `svelte.config.js`.\n\n**Vite Plugins**: Enhance projects with Vite plugins (see vitejs/awesome-vite).\n\n## Breakpoint Debugging\n\n**VSCode**: Debug terminal via `CMD/Ctrl + Shift + P` → \"Debug: JavaScript Debug Terminal\" → `npm run dev`, or use `.vscode/launch.json` with `\"type\": \"node-terminal\"` and press `F5`.\n\n**Browser DevTools**: Run `NODE_OPTIONS=\"--inspect\" npm run dev`, open `localhost:5173`, click \"Open dedicated DevTools for Node.js\", or navigate to `chrome://inspect`.\n\n## Migration: v1 to v2\n\n**Breaking Changes**: `error()` and `redirect()` no longer need `throw`. `cookies.set/delete` require `path` parameter. Top-level promises must be explicitly `await`ed. `goto()` rejects external URLs. `preloadCode` requires `base` prefix. `resolvePath` → `resolveRoute`. Dynamic env vars blocked during prerendering. `$app/stores` deprecated → use `$app/state`. Forms with file inputs need `enctype=\"multipart/form-data\"`. Requires Node 18.13+, Svelte 4, Vite 5, TypeScript 5.\n\n**Automatic Migration**: Run `npx sv migrate sveltekit-2`.\n\n## Migration: Sapper to SvelteKit\n\n**Package Setup**: Add `\"type\": \"module\"` to package.json. Replace `sapper` with `@sveltejs/kit` + adapter.\n\n**Scripts**: `sapper build/dev/export` → `vite build/dev` (with appropriate adapter).\n\n**Configuration**: Replace `webpack.config.js`/`rollup.config.js` with `svelte.config.js`.\n\n**File Structure**: `src/template.html` → `src/app.html`, `_layout.svelte` → `+layout.svelte`, `_error.svelte` → `+error.svelte`, `routes/about.svelte` → `routes/about/+page.svelte`.\n\n**Data Loading**: `preload` → `load` function in `+page.js`/`+layout.js` with single `event` argument.\n\n**Navigation**: `@sapper/app` imports (`goto`, `prefetch`, `prefetchRoutes`) → `goto`, `preloadData`, `preloadCode` from `$app/navigation`.\n\n**Stores**: `stores()` → import `navigating`, `page` from `$app/stores`.\n\n**API Access**: No `req`/`res` access; `fetch` available globally. Relative URLs resolve against current page, not base URL.\n\n## Glossary\n\n**Rendering Modes**:\n- **CSR**: Browser-based rendering (disable with `csr = false`)\n- **SSR**: Server-side rendering (disable with `ssr = false`)\n- **Hybrid**: Default SvelteKit mode (SSR initial + CSR navigation)\n- **SPA**: Single HTML shell with client-side routing (`adapter-static`)\n- **SSG**: All pages prerendered (`adapter-static` or `prerender` option)\n- **ISR**: On-demand static generation (`adapter-vercel`)\n\n**Key Concepts**:\n- **Hydration**: Server data transmitted with HTML; components initialize without re-fetching; event listeners attached\n- **Prerendering**: Build-time HTML generation; must return same content for all users; no form actions\n- **Edge Rendering**: CDN-based rendering near users\n- **Routing**: Client-side navigation by default; skip with `data-sveltekit-reload`\n- **PWA**: Installable web app with offline capabilities via service workers\n- **MPA**: Traditional server-rendered multi-page applications\n\n## Resources\n\n**FAQs**: SvelteKit FAQ, Svelte FAQ, vite-plugin-svelte FAQ\n\n**Examples**: Official - sveltejs/realworld (blog), HackerNews clone, svelte.dev. Community examples on GitHub and Svelte Society.\n\n**Support**: Discord, StackOverflow.","## FAQs & Integrations\n\n**Package Management**: Import JSON with `import pkg from './package.json' with { type: 'json' };`. Use `nodeLinker: 'node-modules'` in `.yarnrc.yml` for Yarn 2/3.\n\n**Library Packaging**: Validate with publint.dev, ensure `exports` field, ship Svelte components as uncompiled `.svelte` files.\n\n**View Transitions**: Use `onNavigate` with `document.startViewTransition`.\n\n**Database**: Put queries in server routes, create `db.js` singleton.\n\n**Client-side Libraries**: Use `import { browser }` check, `onMount`, or `{#await}` blocks.\n\n**Middleware**: Vite plugin with `configureServer` in dev; adapter-node in production.\n\n**vitePreprocess**: Enables CSS preprocessors (PostCSS, SCSS, Less, Stylus). Use `vitePreprocess({ script: true })` for complex TypeScript in Svelte 5.\n\n**Add-ons**: `npx sv add` installs prettier, eslint, vitest, playwright, lucia, tailwind, drizzle, paraglide, mdsvex, storybook.\n\n**Debugging**: VSCode debug terminal or `NODE_OPTIONS=\"--inspect\" npm run dev` for browser DevTools.\n\n## Migration Guides\n\n**v1 to v2**: `error()`/`redirect()` no longer need `throw`. `cookies.set/delete` require `path`. Top-level promises must be `await`ed. `$app/stores` → `$app/state`. Requires Node 18.13+, Svelte 4, Vite 5, TypeScript 5. Run `npx sv migrate sveltekit-2`.\n\n**Sapper to SvelteKit**: Add `\"type\": \"module\"`. Replace `sapper` with `@sveltejs/kit` + adapter. `_layout.svelte` → `+layout.svelte`. `preload` → `load` function. `@sapper/app` imports → `$app/navigation`.\n\n## Glossary\n\n**Rendering Modes**: CSR (browser), SSR (server), Hybrid (default), SPA (client-side routing), SSG (prerendered), ISR (on-demand).\n\n**Key Concepts**: Hydration, Prerendering, Edge Rendering, Routing, PWA, MPA.","Reference documentation covering FAQs, integrations, debugging, migration guides from v1/Sapper, and glossary of rendering modes and concepts.","api-reference",{"name":1015,"path":1015,"children":1017,"data":1388},["Map",1018,1019,532,1036,1052,1053,1069,1070,1086,1087,1103,1104,1118,1119,1132,1133,1148,1149,1163,1164,1179,1180,1196,1197,1211,1212,1228,1229,1244,1245,1260,1261,1276,1277,1291,1292,1307,1308,1323,1324,1340,1341,1357,1358,1374,1375],"@sveltejs∕kit-api-reference",{"name":1018,"path":1020,"children":1021,"data":1022},"api-reference/@sveltejs∕kit-api-reference",["Map"],{"type":22,"path":1023,"relevant":24,"token_counts":1024,"usage":1028,"markdown":1031},"98-reference/10-@sveltejs-kit.md",{"fulltext":1025,"digest":1026,"short_digest":1027},58,55,29,{"input":1029,"output":1030,"details":32},1104,195,{"fulltext":1032,"digest":1033,"short_digest":1034,"essence":1035},"---\ntitle: @sveltejs/kit\n---\n\n> MODULE: @sveltejs/kit\n\n## Private types\n\nThe following are referenced by the public types documented above, but cannot be imported directly:\n\n> TYPES: Private types\n","This page documents the @sveltejs/kit module API. It references private types that are used internally by public types but cannot be imported directly by users. The page serves as a reference for the public API surface of the kit module.","Reference documentation for @sveltejs/kit module. Notes that private types exist but cannot be imported directly.","API reference page for @sveltejs/kit module with notes on private vs public types.",{"name":532,"path":1037,"children":1038,"data":1039},"api-reference/hooks",["Map"],{"type":22,"path":1040,"relevant":44,"token_counts":1041,"usage":1044,"markdown":1047},"98-reference/15-@sveltejs-kit-hooks.md",{"fulltext":1042,"digest":1043,"short_digest":48},33,141,{"input":1045,"output":1046,"details":32},1081,310,{"fulltext":1048,"digest":1049,"short_digest":1050,"essence":1051},"---\ntitle: @sveltejs/kit/hooks\n---\n\n> MODULE: @sveltejs/kit/hooks\n","The `@sveltejs/kit/hooks` module provides server-side hooks for intercepting and customizing the request/response lifecycle in SvelteKit applications.\n\n**Key hooks available:**\n- `handle` - Intercepts every request on the server, allowing you to modify request/response or run custom logic\n- `handleError` - Catches errors during request handling and allows custom error processing\n- `handleFetch` - Intercepts fetch requests made on the server side\n\nThese hooks are defined in a `hooks.server.js` file at the root of your project and are called during server-side request processing.","The `@sveltejs/kit/hooks` module provides server-side hooks (`handle`, `handleError`, `handleFetch`) for intercepting and customizing the request/response lifecycle. Define them in `hooks.server.js` at your project root.","Server-side hooks module for intercepting and customizing request/response handling in SvelteKit.","node-polyfills",{"name":1052,"path":1054,"children":1055,"data":1056},"api-reference/node-polyfills",["Map"],{"type":22,"path":1057,"relevant":44,"token_counts":1058,"usage":1061,"markdown":1064},"98-reference/15-@sveltejs-kit-node-polyfills.md",{"fulltext":1059,"digest":1060,"short_digest":1027},41,75,{"input":1062,"output":1063,"details":32},1093,215,{"fulltext":1065,"digest":1066,"short_digest":1067,"essence":1068},"---\ntitle: @sveltejs/kit/node/polyfills\n---\n\n> MODULE: @sveltejs/kit/node/polyfills\n","The `@sveltejs/kit/node/polyfills` module provides polyfills for Node.js environments when using SvelteKit. This module enables compatibility for browser APIs and features in server-side Node.js contexts, allowing code that relies on browser-specific functionality to work in server-side rendering scenarios.","Module that provides Node.js polyfills for browser APIs in SvelteKit server-side contexts.","Polyfills module for using browser APIs in Node.js server-side SvelteKit environments.","node",{"name":1069,"path":1071,"children":1072,"data":1073},"api-reference/node",["Map"],{"type":22,"path":1074,"relevant":44,"token_counts":1075,"usage":1078,"markdown":1081},"98-reference/15-@sveltejs-kit-node.md",{"fulltext":1076,"digest":312,"short_digest":1077},34,25,{"input":1079,"output":1080,"details":32},1082,199,{"fulltext":1082,"digest":1083,"short_digest":1084,"essence":1085},"---\ntitle:  @sveltejs/kit/node\n---\n\n> MODULE: @sveltejs/kit/node\n","The `@sveltejs/kit/node` module provides Node.js runtime support for SvelteKit applications. This module enables server-side rendering and backend functionality when deploying SvelteKit to Node.js environments. It handles the integration between SvelteKit's framework and Node.js server capabilities.","Node.js runtime adapter for SvelteKit server-side rendering and backend deployment.","Node.js runtime module for SvelteKit server deployment and SSR.","vite-integration",{"name":1086,"path":1088,"children":1089,"data":1090},"api-reference/vite-integration",["Map"],{"type":22,"path":1091,"relevant":44,"token_counts":1092,"usage":1095,"markdown":1098},"98-reference/15-@sveltejs-kit-vite.md",{"fulltext":1093,"digest":312,"short_digest":1094},36,26,{"input":1096,"output":1097,"details":32},1085,205,{"fulltext":1099,"digest":1100,"short_digest":1101,"essence":1102},"---\ntitle:  @sveltejs/kit/vite\n---\n\n> MODULE: @sveltejs/kit/vite\n","The @sveltejs/kit/vite module provides Vite plugin integration for SvelteKit projects. This module exports utilities and configuration helpers for integrating Vite with SvelteKit's build system, enabling optimized development and production builds with Vite's fast module replacement and bundling capabilities.","Vite plugin module for SvelteKit that provides build system integration and configuration utilities.","Module for integrating Vite as the build tool in SvelteKit projects.","$app∕environment",{"name":1103,"path":1105,"children":1106,"data":1107},"api-reference/$app∕environment",["Map"],{"type":22,"path":1108,"relevant":44,"token_counts":1109,"usage":1110,"markdown":1113},"98-reference/20-$app-environment.md",{"fulltext":1077,"digest":418,"short_digest":1059},{"input":1111,"output":1112,"details":32},1069,241,{"fulltext":1114,"digest":1115,"short_digest":1116,"essence":1117},"---\ntitle: $app/environment\n---\n\n> MODULE: $app/environment\n","The `$app/environment` module provides access to environment variables and runtime information in SvelteKit applications.\n\nThis module exports environment-related utilities that allow you to:\n- Access environment variables in both server and client contexts\n- Determine the current runtime environment (development, production, etc.)\n- Check build-time and runtime configuration\n\nKey exports include variables for detecting the build mode and accessing environment configuration set during the build process.","The `$app/environment` module provides access to environment variables and runtime information in SvelteKit applications, allowing you to detect build modes and access environment configuration.","Module for accessing environment variables and runtime information in SvelteKit.","$app∕forms",{"name":1118,"path":1120,"children":1121,"data":1122},"api-reference/$app∕forms",["Map"],{"type":22,"path":1123,"relevant":44,"token_counts":1124,"usage":1126,"markdown":1127},"98-reference/20-$app-forms.md",{"fulltext":1077,"digest":1025,"short_digest":1125},31,{"input":1111,"output":383,"details":32},{"fulltext":1128,"digest":1129,"short_digest":1130,"essence":1131},"---\ntitle: $app/forms\n---\n\n> MODULE: $app/forms\n","The `$app/forms` module provides utilities for working with form submissions in SvelteKit applications. This module is part of SvelteKit's app runtime and enables developers to handle form data, validation, and responses in a structured way.","The `$app/forms` module provides utilities for handling form submissions and form data in SvelteKit applications.","Module for managing form submissions and form-related utilities in SvelteKit.","$app∕navigation",{"name":1132,"path":1134,"children":1135,"data":1136},"api-reference/$app∕navigation",["Map"],{"type":22,"path":1137,"relevant":44,"token_counts":1138,"usage":1141,"markdown":1143},"98-reference/20-$app-navigation.md",{"fulltext":1077,"digest":1139,"short_digest":1140},121,54,{"input":1111,"output":1142,"details":32},279,{"fulltext":1144,"digest":1145,"short_digest":1146,"essence":1147},"---\ntitle: $app/navigation\n---\n\n> MODULE: $app/navigation\n","The `$app/navigation` module provides utilities for programmatic navigation in SvelteKit applications.\n\n**Key exports:**\n- `goto(url, options)` - Navigate to a URL programmatically with optional state and replaceHistory parameters\n- `invalidateAll()` - Invalidate all data and re-run load functions\n- `invalidate(url)` - Invalidate specific data based on URL dependency\n\nThese functions enable client-side navigation without full page reloads and allow manual cache invalidation when needed.","The `$app/navigation` module provides `goto()` for programmatic navigation, `invalidateAll()` to re-run all load functions, and `invalidate(url)` to invalidate specific data dependencies.","Navigation utilities for programmatic routing and data invalidation in SvelteKit.","$app∕paths",{"name":1148,"path":1150,"children":1151,"data":1152},"api-reference/$app∕paths",["Map"],{"type":22,"path":1153,"relevant":44,"token_counts":1154,"usage":1157,"markdown":1158},"98-reference/20-$app-paths.md",{"fulltext":1077,"digest":1155,"short_digest":1156},155,48,{"input":1111,"output":51,"details":32},{"fulltext":1159,"digest":1160,"short_digest":1161,"essence":1162},"---\ntitle: $app/paths\n---\n\n> MODULE: $app/paths\n","The `$app/paths` module provides access to application path configuration values that are set during build time.\n\n**Exported values:**\n- `base` - The base path of the application (default: `''`)\n- `assets` - The path where static assets are served from (default: `base`)\n\nThese values are determined by the `config.kit.paths` configuration in `svelte.config.js`.\n\n**Usage example:**\n```javascript\nimport { base, assets } from '$app/paths';\n\n// Use base for routing\nconst url = `${base}/page`;\n\n// Use assets for static resources\nconst image = `${assets}/image.png`;\n```","The `$app/paths` module exports `base` and `assets` paths configured in `svelte.config.js`. Use `base` for routing and `assets` for static resources.","Module providing access to configured application base and assets paths.","$app∕server",{"name":1163,"path":1165,"children":1166,"data":1167},"api-reference/$app∕server",["Map"],{"type":22,"path":1168,"relevant":44,"token_counts":1169,"usage":1172,"markdown":1174},"98-reference/20-$app-server.md",{"fulltext":1077,"digest":1170,"short_digest":1171},80,37,{"input":1111,"output":1173,"details":32},219,{"fulltext":1175,"digest":1176,"short_digest":1177,"essence":1178},"---\ntitle: $app/server\n---\n\n> MODULE: $app/server\n","The `$app/server` module provides server-side utilities and helpers for SvelteKit applications. This module is only available in server-side code (hooks, routes, and server-side load functions) and cannot be used in browser contexts. It exports server-specific APIs that enable developers to access server runtime information and perform server-only operations.","Server-side module providing utilities and APIs for server-only operations in SvelteKit. Available in hooks, routes, and server load functions.","Module reference for server-side utilities in SvelteKit applications.","$app∕state",{"name":1179,"path":1181,"children":1182,"data":1183},"api-reference/$app∕state",["Map"],{"type":22,"path":1184,"relevant":44,"token_counts":1185,"usage":1188,"markdown":1191},"98-reference/20-$app-state.md",{"fulltext":1186,"digest":28,"short_digest":1187},105,57,{"input":1189,"output":1190,"details":32},1149,257,{"fulltext":1192,"digest":1193,"short_digest":1194,"essence":1195},"---\ntitle: $app/state\n---\n\nSvelteKit makes three read-only state objects available via the `$app/state` module — `page`, `navigating` and `updated`.\n\n> [!NOTE]\n> This module was added in 2.12. If you're using an earlier version of SvelteKit, use [`$app/stores`]($app-stores) instead.\n\n> MODULE: $app/state\n","The `$app/state` module provides three read-only state objects:\n\n- `page` - contains page-related state\n- `navigating` - contains navigation state\n- `updated` - contains update state\n\nThis module was added in SvelteKit 2.12. For earlier versions, use `$app/stores` instead.","The `$app/state` module (added in 2.12) exports three read-only state objects: `page`, `navigating`, and `updated`. Use `$app/stores` for earlier SvelteKit versions.","Read-only state objects available via $app/state module: page, navigating, and updated (SvelteKit 2.12+)","$app∕stores",{"name":1196,"path":1198,"children":1199,"data":1200},"api-reference/$app∕stores",["Map"],{"type":22,"path":1201,"relevant":44,"token_counts":1202,"usage":1204,"markdown":1206},"98-reference/20-$app-stores.md",{"fulltext":736,"digest":1203,"short_digest":1093},68,{"input":1205,"output":27,"details":32},1115,{"fulltext":1207,"digest":1208,"short_digest":1209,"essence":1210},"---\ntitle: $app/stores\n---\n\nThis module contains store-based equivalents of the exports from [`$app/state`]($app-state). If you're using SvelteKit 2.12 or later, use that module instead.\n\n> MODULE: $app/stores\n","The `$app/stores` module provides store-based equivalents of the exports from `$app/state`. This module is considered legacy for SvelteKit 2.12 and later versions, where the `$app/state` module should be used instead for accessing application state.","Legacy module providing store-based state equivalents. Use `$app/state` instead for SvelteKit 2.12+.","$app/stores is a deprecated module for accessing application state via stores; use $app/state in SvelteKit 2.12+.","$app∕types",{"name":1211,"path":1213,"children":1214,"data":1215},"api-reference/$app∕types",["Map"],{"type":22,"path":1216,"relevant":44,"token_counts":1217,"usage":1221,"markdown":1223},"98-reference/20-$app-types.md",{"fulltext":1218,"digest":1219,"short_digest":1220},599,344,127,{"input":1222,"output":594,"details":32},1643,{"fulltext":1224,"digest":1225,"short_digest":1226,"essence":1227},"---\ntitle: $app/types\n---\n\nThis module contains generated types for the routes in your app.\n\n\u003Cblockquote class=\"since note\">\n\t\u003Cp>Available since 2.26\u003C/p>\n\u003C/blockquote>\n\n```js\n// @noErrors\nimport type { RouteId, RouteParams, LayoutParams } from '$app/types';\n```\n\n## Asset\n\nA union of all the filenames of assets contained in your `static` directory, plus a `string` wildcard for asset paths generated from `import` declarations.\n\n\u003Cdiv class=\"ts-block\">\n\n```dts\ntype Asset = '/favicon.png' | '/robots.txt' | (string & {});\n```\n\n\u003C/div>\n\n## RouteId\n\nA union of all the route IDs in your app. Used for `page.route.id` and `event.route.id`.\n\n\u003Cdiv class=\"ts-block\">\n\n```dts\ntype RouteId = '/' | '/my-route' | '/my-other-route/[param]';\n```\n\n\u003C/div>\n\n## Pathname\n\nA union of all valid pathnames in your app.\n\n\u003Cdiv class=\"ts-block\">\n\n```dts\ntype Pathname = '/' | '/my-route' | `/my-other-route/${string}` & {};\n```\n\n\u003C/div>\n\n## ResolvedPathname\n\nSimilar to `Pathname`, but possibly prefixed with a [base path](configuration#paths). Used for `page.url.pathname`.\n\n\u003Cdiv class=\"ts-block\">\n\n```dts\ntype ResolvedPathname = `${'' | `/${string}`}/` | `${'' | `/${string}`}/my-route` | `${'' | `/${string}`}/my-other-route/${string}` | {};\n```\n\n\u003C/div>\n\n## RouteParams\n\nA utility for getting the parameters associated with a given route.\n\n```ts\n// @errors: 2552\ntype BlogParams = RouteParams\u003C'/blog/[slug]'>; // { slug: string }\n```\n\n\u003Cdiv class=\"ts-block\">\n\n```dts\ntype RouteParams\u003CT extends RouteId> = { /* generated */ } | Record\u003Cstring, never>;\n```\n\n\u003C/div>\n\n## LayoutParams\n\nA utility for getting the parameters associated with a given layout, which is similar to `RouteParams` but also includes optional parameters for any child route.\n\n\u003Cdiv class=\"ts-block\">\n\n```dts\ntype RouteParams\u003CT extends RouteId> = { /* generated */ } | Record\u003Cstring, never>;\n```\n\n\u003C/div>\n","## Generated Type Utilities\n\nThe `$app/types` module provides auto-generated TypeScript types for your app's routes and assets.\n\n### Asset\nUnion of all static directory filenames plus a string wildcard for dynamically imported assets:\n```ts\ntype Asset = '/favicon.png' | '/robots.txt' | (string & {});\n```\n\n### RouteId\nUnion of all route IDs in your app, used in `page.route.id` and `event.route.id`:\n```ts\ntype RouteId = '/' | '/my-route' | '/my-other-route/[param]';\n```\n\n### Pathname\nUnion of all valid pathnames in your app:\n```ts\ntype Pathname = '/' | '/my-route' | `/my-other-route/${string}` & {};\n```\n\n### ResolvedPathname\nLike `Pathname` but includes base path prefix, used in `page.url.pathname`:\n```ts\ntype ResolvedPathname = `${'' | `/${string}`}/` | `${'' | `/${string}`}/my-route` | `${'' | `/${string}`}/my-other-route/${string}` | {};\n```\n\n### RouteParams\nUtility to get parameters for a given route:\n```ts\ntype BlogParams = RouteParams\u003C'/blog/[slug]'>; // { slug: string }\n```\n\n### LayoutParams\nLike `RouteParams` but includes optional parameters from child routes.","## Generated Route and Asset Types\n\nAuto-generated TypeScript utilities for type-safe route handling:\n\n- **Asset**: Union of static files plus dynamic imports\n- **RouteId**: All route IDs in your app\n- **Pathname**: All valid pathnames\n- **ResolvedPathname**: Pathnames with base path prefix\n- **RouteParams**: Get parameters for a route: `RouteParams\u003C'/blog/[slug]'>` → `{ slug: string }`\n- **LayoutParams**: Route parameters including optional child route params","Auto-generated TypeScript types for type-safe access to routes, pathnames, and parameters in your SvelteKit app.","$env∕dynamic∕private",{"name":1228,"path":1230,"children":1231,"data":1232},"api-reference/$env∕dynamic∕private",["Map"],{"type":22,"path":1233,"relevant":44,"token_counts":1234,"usage":1236,"markdown":1239},"98-reference/25-$env-dynamic-private.md",{"fulltext":1027,"digest":1235,"short_digest":1125},76,{"input":1237,"output":1238,"details":32},1075,213,{"fulltext":1240,"digest":1241,"short_digest":1242,"essence":1243},"---\ntitle: $env/dynamic/private\n---\n\n> MODULE: $env/dynamic/private\n","The `$env/dynamic/private` module provides access to private environment variables at runtime in SvelteKit applications. These are environment variables that should only be accessible on the server side and never exposed to the client. Use this module to securely access sensitive configuration like API keys, database credentials, and other secrets that must remain private.","Module for accessing private environment variables at runtime on the server side. Use for sensitive configuration like API keys and database credentials.","Access private environment variables at runtime in SvelteKit server-side code.","$env∕dynamic∕public",{"name":1244,"path":1246,"children":1247,"data":1248},"api-reference/$env∕dynamic∕public",["Map"],{"type":22,"path":1249,"relevant":44,"token_counts":1250,"usage":1253,"markdown":1255},"98-reference/25-$env-dynamic-public.md",{"fulltext":1027,"digest":1251,"short_digest":1252},138,70,{"input":1237,"output":1254,"details":32},312,{"fulltext":1256,"digest":1257,"short_digest":1258,"essence":1259},"---\ntitle: $env/dynamic/public\n---\n\n> MODULE: $env/dynamic/public\n","The `$env/dynamic/public` module provides access to public environment variables at runtime in SvelteKit applications.\n\nPublic environment variables are those prefixed with `PUBLIC_` and are safe to expose to the browser. Unlike static environment variables, dynamic public variables can change at runtime and are evaluated when the application runs.\n\nAccess public environment variables using:\n```javascript\nimport { env } from '$env/dynamic/public';\nconsole.log(env.PUBLIC_API_URL);\n```\n\nThese variables are available in both server and client code, making them useful for configuration that needs to be accessible from the browser.","The `$env/dynamic/public` module provides runtime access to public environment variables (prefixed with `PUBLIC_`) in both server and client code.\n\n```javascript\nimport { env } from '$env/dynamic/public';\nconsole.log(env.PUBLIC_API_URL);\n```","Runtime access to public environment variables in SvelteKit applications.","$env∕static∕private",{"name":1260,"path":1262,"children":1263,"data":1264},"api-reference/$env∕static∕private",["Map"],{"type":22,"path":1265,"relevant":44,"token_counts":1266,"usage":1269,"markdown":1271},"98-reference/25-$env-static-private.md",{"fulltext":1027,"digest":1267,"short_digest":1268},85,42,{"input":1237,"output":1270,"details":32},236,{"fulltext":1272,"digest":1273,"short_digest":1274,"essence":1275},"---\ntitle: $env/static/private\n---\n\n> MODULE: $env/static/private\n","The `$env/static/private` module provides access to private environment variables that are only available on the server side during build time. These variables are statically replaced at build time and cannot be accessed from the browser or client-side code. Use this module to securely handle sensitive configuration like API keys, database credentials, and other secrets that should never be exposed to the client.","Server-only module for accessing private environment variables at build time. Statically replaced during build, never exposed to client. Use for sensitive secrets like API keys and credentials.","Module for accessing private, server-only environment variables that are statically replaced at build time.","$env∕static∕public",{"name":1276,"path":1278,"children":1279,"data":1280},"api-reference/$env∕static∕public",["Map"],{"type":22,"path":1281,"relevant":44,"token_counts":1282,"usage":1284,"markdown":1286},"98-reference/25-$env-static-public.md",{"fulltext":1027,"digest":1283,"short_digest":701},97,{"input":1237,"output":1285,"details":32},247,{"fulltext":1287,"digest":1288,"short_digest":1289,"essence":1290},"---\ntitle: $env/static/public\n---\n\n> MODULE: $env/static/public\n","The `$env/static/public` module provides access to public environment variables that are statically injected at build time. These variables are safe to expose in client-side code since they're intended to be public. They must be prefixed with `PUBLIC_` in your `.env` file to be included in this module. Use this for configuration values that need to be accessible from the browser, such as API endpoints or feature flags.","Module for accessing public environment variables (prefixed with `PUBLIC_`) that are statically injected at build time and safe to expose in client-side code.","Access public environment variables in SvelteKit applications via the $env/static/public module.","$lib-import-alias",{"name":1291,"path":1293,"children":1294,"data":1295},"api-reference/$lib-import-alias",["Map"],{"type":22,"path":1296,"relevant":44,"token_counts":1297,"usage":1300,"markdown":1302},"98-reference/26-$lib.md",{"fulltext":824,"digest":1298,"short_digest":1299},122,50,{"input":1301,"output":523,"details":32},1174,{"fulltext":1303,"digest":1304,"short_digest":1305,"essence":1306},"---\ntitle: $lib\n---\n\nSvelteKit automatically makes files under `src/lib` available using the `$lib` import alias. You can change which directory this alias points to in your [config file](configuration#files).\n\n```svelte\n\u003C!--- file: src/lib/Component.svelte --->\nA reusable component\n```\n\n```svelte\n\u003C!--- file: src/routes/+page.svelte --->\n\u003Cscript>\n    import Component from '$lib/Component.svelte';\n\u003C/script>\n\n\u003CComponent />\n```\n","SvelteKit automatically provides the `$lib` import alias for files under `src/lib`. This allows you to import reusable components and utilities from your library directory without relative paths.\n\nExample:\n```svelte\n// src/lib/Component.svelte\nA reusable component\n\n// src/routes/+page.svelte\n\u003Cscript>\n    import Component from '$lib/Component.svelte';\n\u003C/script>\n\n\u003CComponent />\n```\n\nThe alias target directory can be customized in the config file.","`$lib` is an automatic import alias pointing to `src/lib`. Customize its target in the config file.\n\n```svelte\nimport Component from '$lib/Component.svelte';\n```","$lib is an automatic import alias for the src/lib directory in SvelteKit projects.","$service-worker",{"name":1307,"path":1309,"children":1310,"data":1311},"api-reference/$service-worker",["Map"],{"type":22,"path":1312,"relevant":44,"token_counts":1313,"usage":1316,"markdown":1318},"98-reference/27-$service-worker.md",{"fulltext":1077,"digest":1314,"short_digest":1315},52,28,{"input":1111,"output":1317,"details":32},183,{"fulltext":1319,"digest":1320,"short_digest":1321,"essence":1322},"---\ntitle: $service-worker\n---\n\n> MODULE: $service-worker\n","The `$service-worker` module provides access to service worker functionality in SvelteKit applications. This is a special module that allows you to interact with and configure service worker behavior within your SvelteKit project.","The `$service-worker` module provides access to service worker functionality in SvelteKit applications.","Module for accessing and configuring service worker functionality in SvelteKit.","configuration",{"name":1323,"path":1325,"children":1326,"data":1327},"api-reference/configuration",["Map"],{"type":22,"path":1328,"relevant":44,"token_counts":1329,"usage":1332,"markdown":1335},"98-reference/50-configuration.md",{"fulltext":1330,"digest":704,"short_digest":1331},248,79,{"input":1333,"output":1334,"details":32},1289,343,{"fulltext":1336,"digest":1337,"short_digest":1338,"essence":1339},"---\ntitle: Configuration\n---\n\nYour project's configuration lives in a `svelte.config.js` file at the root of your project. As well as SvelteKit, this config object is used by other tooling that integrates with Svelte such as editor extensions.\n\n```js\n/// file: svelte.config.js\n// @filename: ambient.d.ts\ndeclare module '@sveltejs/adapter-auto' {\n\tconst plugin: () => import('@sveltejs/kit').Adapter;\n\texport default plugin;\n}\n\n// @filename: index.js\n// ---cut---\nimport adapter from '@sveltejs/adapter-auto';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n\nexport default config;\n```\n\n## Config\n\n> TYPES: Configuration#Config\n\n## KitConfig\n\nThe `kit` property configures SvelteKit, and can have the following properties:\n\n> EXPANDED_TYPES: Configuration#KitConfig\n","## Configuration File\n\nYour project configuration lives in `svelte.config.js` at the root of your project. This config object is used by SvelteKit and other tooling that integrates with Svelte.\n\n## Basic Setup\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter()\n\t}\n};\n\nexport default config;\n```\n\n## Config Properties\n\nThe `kit` property configures SvelteKit and accepts various configuration options for controlling adapter behavior, routing, build output, and other framework features.","Configuration lives in `svelte.config.js` at project root. The `kit` property configures SvelteKit with options like adapter selection:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nconst config = {\n\tkit: { adapter: adapter() }\n};\n\nexport default config;\n```","SvelteKit projects are configured via svelte.config.js file with a kit property that accepts various configuration options.","command-line-interface",{"name":1340,"path":1342,"children":1343,"data":1344},"api-reference/command-line-interface",["Map"],{"type":22,"path":1345,"relevant":44,"token_counts":1346,"usage":1350,"markdown":1352},"98-reference/52-cli.md",{"fulltext":1347,"digest":1348,"short_digest":1349},197,124,67,{"input":1351,"output":1046,"details":32},1238,{"fulltext":1353,"digest":1354,"short_digest":1355,"essence":1356},"---\ntitle: Command Line Interface\n---\n\nSvelteKit projects use [Vite](https://vitejs.dev), meaning you'll mostly use its CLI (albeit via `npm run dev/build/preview` scripts):\n\n- `vite dev` — start a development server\n- `vite build` — build a production version of your app\n- `vite preview` — run the production version locally\n\nHowever SvelteKit includes its own CLI for initialising your project:\n\n## svelte-kit sync\n\n`svelte-kit sync` creates the `tsconfig.json` and all generated types (which you can import as `./$types` inside routing files) for your project. When you create a new project, it is listed as the `prepare` script and will be run automatically as part of the npm lifecycle, so you should not ordinarily have to run this command.\n","SvelteKit uses Vite for its CLI. Common commands are run via npm scripts:\n\n- `vite dev` — start development server\n- `vite build` — build production version\n- `vite preview` — run production build locally\n\nSvelteKit provides its own CLI command:\n\n**svelte-kit sync** — generates `tsconfig.json` and type definitions (importable as `./$types` in routing files). Runs automatically as the `prepare` npm script during project setup, so manual execution is rarely needed.","SvelteKit uses Vite CLI via npm scripts (`vite dev`, `vite build`, `vite preview`). The `svelte-kit sync` command generates `tsconfig.json` and `./$types` definitions, running automatically as the `prepare` script.","SvelteKit leverages Vite's CLI for development and building, with an additional svelte-kit sync command for generating project configuration and types.","types",{"name":1357,"path":1359,"children":1360,"data":1361},"api-reference/types",["Map"],{"type":22,"path":1362,"relevant":44,"token_counts":1363,"usage":1366,"markdown":1369},"98-reference/54-types.md",{"fulltext":1364,"digest":65,"short_digest":1365},1961,129,{"input":1367,"output":1368,"details":32},3002,665,{"fulltext":1370,"digest":1371,"short_digest":1372,"essence":1373},"---\ntitle: Types\n---\n\n## Generated types\n\nThe `RequestHandler` and `Load` types both accept a `Params` argument allowing you to type the `params` object. For example this endpoint expects `foo`, `bar` and `baz` params:\n\n```js\n/// file: src/routes/[foo]/[bar]/[baz]/+server.js\n// @errors: 2355 2322 1360\n/** @type {import('@sveltejs/kit').RequestHandler\u003C{\n    foo: string;\n    bar: string;\n    baz: string\n  }>} */\nexport async function GET({ params }) {\n\t// ...\n}\n```\n\nNeedless to say, this is cumbersome to write out, and less portable (if you were to rename the `[foo]` directory to `[qux]`, the type would no longer reflect reality).\n\nTo solve this problem, SvelteKit generates `.d.ts` files for each of your endpoints and pages:\n\n```ts\n/// file: .svelte-kit/types/src/routes/[foo]/[bar]/[baz]/$types.d.ts\n/// link: true\nimport type * as Kit from '@sveltejs/kit';\n\ntype RouteParams = {\n\tfoo: string;\n\tbar: string;\n\tbaz: string;\n};\n\nexport type RequestHandler = Kit.RequestHandler\u003CRouteParams>;\nexport type PageLoad = Kit.Load\u003CRouteParams>;\n```\n\nThese files can be imported into your endpoints and pages as siblings, thanks to the [`rootDirs`](https://www.typescriptlang.org/tsconfig#rootDirs) option in your TypeScript configuration:\n\n```js\n/// file: src/routes/[foo]/[bar]/[baz]/+server.js\n// @filename: $types.d.ts\nimport type * as Kit from '@sveltejs/kit';\n\ntype RouteParams = {\n\tfoo: string;\n\tbar: string;\n\tbaz: string;\n}\n\nexport type RequestHandler = Kit.RequestHandler\u003CRouteParams>;\n\n// @filename: index.js\n// @errors: 2355 2322\n// ---cut---\n/** @type {import('./$types').RequestHandler} */\nexport async function GET({ params }) {\n\t// ...\n}\n```\n\n```js\n/// file: src/routes/[foo]/[bar]/[baz]/+page.js\n// @filename: $types.d.ts\nimport type * as Kit from '@sveltejs/kit';\n\ntype RouteParams = {\n\tfoo: string;\n\tbar: string;\n\tbaz: string;\n}\n\nexport type PageLoad = Kit.Load\u003CRouteParams>;\n\n// @filename: index.js\n// @errors: 2355\n// ---cut---\n/** @type {import('./$types').PageLoad} */\nexport async function load({ params, fetch }) {\n\t// ...\n}\n```\n\nThe return types of the load functions are then available through the `$types` module as `PageData` and `LayoutData` respectively, while the union of the return values of all `Actions` is available as `ActionData`.\n\nStarting with version 2.16.0, two additional helper types are provided: `PageProps` defines `data: PageData`, as well as `form: ActionData`, when there are actions defined, while `LayoutProps` defines `data: LayoutData`, as well as `children: Snippet`.\n\n```svelte\n\u003C!--- file: src/routes/+page.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data, form } = $props();\n\u003C/script>\n```\n\n> [!LEGACY]\n> Before 2.16.0:\n> ```svelte\n> \u003C!--- file: src/routes/+page.svelte --->\n> \u003Cscript>\n> \t/** @type {{ data: import('./$types').PageData, form: import('./$types').ActionData }} */\n> \tlet { data, form } = $props();\n> \u003C/script>\n> ```\n>\n> Using Svelte 4:\n> ```svelte\n> \u003C!--- file: src/routes/+page.svelte --->\n> \u003Cscript>\n>   /** @type {import('./$types').PageData} */\n>   export let data;\n>   /** @type {import('./$types').ActionData} */\n>   export let form;\n> \u003C/script>\n> ```\n\n> [!NOTE] For this to work, your own `tsconfig.json` or `jsconfig.json` should extend from the generated `.svelte-kit/tsconfig.json` (where `.svelte-kit` is your [`outDir`](configuration#outDir)):\n>\n> `{ \"extends\": \"./.svelte-kit/tsconfig.json\" }`\n\n### Default tsconfig.json\n\nThe generated `.svelte-kit/tsconfig.json` file contains a mixture of options. Some are generated programmatically based on your project configuration, and should generally not be overridden without good reason:\n\n```json\n/// file: .svelte-kit/tsconfig.json\n{\n\t\"compilerOptions\": {\n\t\t\"paths\": {\n\t\t\t\"$lib\": [\"../src/lib\"],\n\t\t\t\"$lib/*\": [\"../src/lib/*\"]\n\t\t},\n\t\t\"rootDirs\": [\"..\", \"./types\"]\n\t},\n\t\"include\": [\n\t\t\"ambient.d.ts\",\n\t\t\"non-ambient.d.ts\",\n\t\t\"./types/**/$types.d.ts\",\n\t\t\"../vite.config.js\",\n\t\t\"../vite.config.ts\",\n\t\t\"../src/**/*.js\",\n\t\t\"../src/**/*.ts\",\n\t\t\"../src/**/*.svelte\",\n\t\t\"../tests/**/*.js\",\n\t\t\"../tests/**/*.ts\",\n\t\t\"../tests/**/*.svelte\"\n\t],\n\t\"exclude\": [\n\t\t\"../node_modules/**\",\n\t\t\"../src/service-worker.js\",\n\t\t\"../src/service-worker/**/*.js\",\n\t\t\"../src/service-worker.ts\",\n\t\t\"../src/service-worker/**/*.ts\",\n\t\t\"../src/service-worker.d.ts\",\n\t\t\"../src/service-worker/**/*.d.ts\"\n\t]\n}\n```\n\nOthers are required for SvelteKit to work properly, and should also be left untouched unless you know what you're doing:\n\n```json\n/// file: .svelte-kit/tsconfig.json\n{\n\t\"compilerOptions\": {\n\t\t// this ensures that types are explicitly\n\t\t// imported with `import type`, which is\n\t\t// necessary as Svelte/Vite cannot\n\t\t// otherwise compile components correctly\n\t\t\"verbatimModuleSyntax\": true,\n\n\t\t// Vite compiles one TypeScript module\n\t\t// at a time, rather than compiling\n\t\t// the entire module graph\n\t\t\"isolatedModules\": true,\n\n\t\t// Tell TS it's used only for type-checking\n\t\t\"noEmit\": true,\n\n\t\t// This ensures both `vite build`\n\t\t// and `svelte-package` work correctly\n\t\t\"lib\": [\"esnext\", \"DOM\", \"DOM.Iterable\"],\n\t\t\"moduleResolution\": \"bundler\",\n\t\t\"module\": \"esnext\",\n\t\t\"target\": \"esnext\"\n\t}\n}\n```\n\nUse the [`typescript.config` setting](configuration#typescript) in `svelte.config.js` to extend or modify the generated `tsconfig.json`.\n\n## $lib\n\nThis is a simple alias to `src/lib`, or whatever directory is specified as [`config.kit.files.lib`](configuration#files). It allows you to access common components and utility modules without `../../../../` nonsense.\n\n### $lib/server\n\nA subdirectory of `$lib`. SvelteKit will prevent you from importing any modules in `$lib/server` into client-side code. See [server-only modules](server-only-modules).\n\n## app.d.ts\n\nThe `app.d.ts` file is home to the ambient types of your apps, i.e. types that are available without explicitly importing them.\n\nAlways part of this file is the `App` namespace. This namespace contains several types that influence the shape of certain SvelteKit features you interact with.\n\n> TYPES: App\n","## Generated Types\n\nSvelteKit automatically generates `.d.ts` files for each endpoint and page that export typed versions of `RequestHandler` and `Load`. These files are located at `.svelte-kit/types/src/routes/[params]/$types.d.ts` and can be imported as siblings thanks to the `rootDirs` TypeScript configuration option.\n\nInstead of manually typing params:\n```js\n/** @type {import('@sveltejs/kit').RequestHandler\u003C{ foo: string; bar: string; baz: string }>} */\nexport async function GET({ params }) {}\n```\n\nImport from the generated `$types` module:\n```js\n/** @type {import('./$types').RequestHandler} */\nexport async function GET({ params }) {}\n```\n\nThe `$types` module also exports `PageData`, `LayoutData`, and `ActionData` types representing the return types of load functions and actions. Starting with version 2.16.0, helper types `PageProps` and `LayoutProps` are available that combine data and form/children properties.\n\n## Configuration\n\nYour `tsconfig.json` or `jsconfig.json` must extend `./.svelte-kit/tsconfig.json` for this to work. The generated tsconfig includes path aliases like `$lib` pointing to `src/lib`, and `rootDirs` configuration enabling the `$types` imports.\n\n## $lib Alias\n\n`$lib` is an alias to `src/lib` (or custom `config.kit.files.lib` directory). `$lib/server` is a subdirectory where SvelteKit prevents client-side imports of server-only modules.\n\n## app.d.ts\n\nThe `app.d.ts` file contains ambient types available without explicit imports, including the `App` namespace that influences SvelteKit feature shapes.","SvelteKit generates `.d.ts` files for routes that export typed `RequestHandler`, `Load`, `PageData`, `LayoutData`, and `ActionData`. Import types from `./$types` instead of manually typing params. Helper types `PageProps` and `LayoutProps` (v2.16.0+) combine data with form/children. Your `tsconfig.json` must extend `./.svelte-kit/tsconfig.json`. `$lib` aliases `src/lib` and `$lib/server` prevents client-side imports.","SvelteKit auto-generates typed `$types` modules for routes to provide type-safe params, load data, and actions without manual type annotations.","reference",{"name":1374,"path":1376,"children":1377,"data":1378},"api-reference/reference",["Map"],{"type":22,"path":1379,"relevant":24,"token_counts":1380,"usage":1382,"markdown":1383},"98-reference/index.md",{"fulltext":700,"digest":1381,"short_digest":260},38,{"input":136,"output":704,"details":32},{"fulltext":1384,"digest":1385,"short_digest":1386,"essence":1387},"---\ntitle: Reference\n---\n","This is a reference documentation index page for SvelteKit. It serves as the entry point to the API reference and technical documentation sections of the framework.","Reference documentation index for SvelteKit APIs and technical specifications.","Landing page for SvelteKit reference documentation.",{"type":129,"path":1389,"relevant":44,"token_counts":1390,"usage":1392,"markdown":1394},"98-reference",{"fulltext":247,"digest":1391,"short_digest":1270},646,{"input":1393,"output":453,"details":32},2879,{"fulltext":1395,"digest":1396,"short_digest":1397,"essence":1398},"\n\n## Pages\n\n### hooks\nServer-side hooks module for intercepting and customizing request/response handling in SvelteKit.\n\nThe `@sveltejs/kit/hooks` module provides server-side hooks (`handle`, `handleError`, `handleFetch`) for intercepting and customizing the request/response lifecycle. Define them in `hooks.server.js` at your project root.\n\n### node-polyfills\nPolyfills module for using browser APIs in Node.js server-side SvelteKit environments.\n\nModule that provides Node.js polyfills for browser APIs in SvelteKit server-side contexts.\n\n### node\nNode.js runtime module for SvelteKit server deployment and SSR.\n\nNode.js runtime adapter for SvelteKit server-side rendering and backend deployment.\n\n### vite-integration\nModule for integrating Vite as the build tool in SvelteKit projects.\n\nVite plugin module for SvelteKit that provides build system integration and configuration utilities.\n\n### $app∕environment\nModule for accessing environment variables and runtime information in SvelteKit.\n\nThe `$app/environment` module provides access to environment variables and runtime information in SvelteKit applications, allowing you to detect build modes and access environment configuration.\n\n### $app∕forms\nModule for managing form submissions and form-related utilities in SvelteKit.\n\nThe `$app/forms` module provides utilities for handling form submissions and form data in SvelteKit applications.\n\n### $app∕navigation\nNavigation utilities for programmatic routing and data invalidation in SvelteKit.\n\nThe `$app/navigation` module provides `goto()` for programmatic navigation, `invalidateAll()` to re-run all load functions, and `invalidate(url)` to invalidate specific data dependencies.\n\n### $app∕paths\nModule providing access to configured application base and assets paths.\n\nThe `$app/paths` module exports `base` and `assets` paths configured in `svelte.config.js`. Use `base` for routing and `assets` for static resources.\n\n### $app∕server\nModule reference for server-side utilities in SvelteKit applications.\n\nServer-side module providing utilities and APIs for server-only operations in SvelteKit. Available in hooks, routes, and server load functions.\n\n### $app∕state\nRead-only state objects available via $app/state module: page, navigating, and updated (SvelteKit 2.12+)\n\nThe `$app/state` module (added in 2.12) exports three read-only state objects: `page`, `navigating`, and `updated`. Use `$app/stores` for earlier SvelteKit versions.\n\n### $app∕stores\n$app/stores is a deprecated module for accessing application state via stores; use $app/state in SvelteKit 2.12+.\n\nLegacy module providing store-based state equivalents. Use `$app/state` instead for SvelteKit 2.12+.\n\n### $app∕types\nAuto-generated TypeScript types for type-safe access to routes, pathnames, and parameters in your SvelteKit app.\n\n## Generated Route and Asset Types\n\nAuto-generated TypeScript utilities for type-safe route handling:\n\n- **Asset**: Union of static files plus dynamic imports\n- **RouteId**: All route IDs in your app\n- **Pathname**: All valid pathnames\n- **ResolvedPathname**: Pathnames with base path prefix\n- **RouteParams**: Get parameters for a route: `RouteParams\u003C'/blog/[slug]'>` → `{ slug: string }`\n- **LayoutParams**: Route parameters including optional child route params\n\n### $env∕dynamic∕private\nAccess private environment variables at runtime in SvelteKit server-side code.\n\nModule for accessing private environment variables at runtime on the server side. Use for sensitive configuration like API keys and database credentials.\n\n### $env∕dynamic∕public\nRuntime access to public environment variables in SvelteKit applications.\n\nThe `$env/dynamic/public` module provides runtime access to public environment variables (prefixed with `PUBLIC_`) in both server and client code.\n\n```javascript\nimport { env } from '$env/dynamic/public';\nconsole.log(env.PUBLIC_API_URL);\n```\n\n### $env∕static∕private\nModule for accessing private, server-only environment variables that are statically replaced at build time.\n\nServer-only module for accessing private environment variables at build time. Statically replaced during build, never exposed to client. Use for sensitive secrets like API keys and credentials.\n\n### $env∕static∕public\nAccess public environment variables in SvelteKit applications via the $env/static/public module.\n\nModule for accessing public environment variables (prefixed with `PUBLIC_`) that are statically injected at build time and safe to expose in client-side code.\n\n### $lib-import-alias\n$lib is an automatic import alias for the src/lib directory in SvelteKit projects.\n\n`$lib` is an automatic import alias pointing to `src/lib`. Customize its target in the config file.\n\n```svelte\nimport Component from '$lib/Component.svelte';\n```\n\n### $service-worker\nModule for accessing and configuring service worker functionality in SvelteKit.\n\nThe `$service-worker` module provides access to service worker functionality in SvelteKit applications.\n\n### configuration\nSvelteKit projects are configured via svelte.config.js file with a kit property that accepts various configuration options.\n\nConfiguration lives in `svelte.config.js` at project root. The `kit` property configures SvelteKit with options like adapter selection:\n\n```js\nimport adapter from '@sveltejs/adapter-auto';\n\nconst config = {\n\tkit: { adapter: adapter() }\n};\n\nexport default config;\n```\n\n### command-line-interface\nSvelteKit leverages Vite's CLI for development and building, with an additional svelte-kit sync command for generating project configuration and types.\n\nSvelteKit uses Vite CLI via npm scripts (`vite dev`, `vite build`, `vite preview`). The `svelte-kit sync` command generates `tsconfig.json` and `./$types` definitions, running automatically as the `prepare` script.\n\n### types\nSvelteKit auto-generates typed `$types` modules for routes to provide type-safe params, load data, and actions without manual type annotations.\n\nSvelteKit generates `.d.ts` files for routes that export typed `RequestHandler`, `Load`, `PageData`, `LayoutData`, and `ActionData`. Import types from `./$types` instead of manually typing params. Helper types `PageProps` and `LayoutProps` (v2.16.0+) combine data with form/children. Your `tsconfig.json` must extend `./.svelte-kit/tsconfig.json`. `$lib` aliases `src/lib` and `$lib/server` prevents client-side imports.\n\n","## Server-side Hooks\n`@sveltejs/kit/hooks` module provides `handle`, `handleError`, `handleFetch` hooks defined in `hooks.server.js` for intercepting and customizing request/response lifecycle.\n\n## Runtime Modules\n- `$app/environment` - Access environment variables and runtime information (build modes, config)\n- `$app/navigation` - `goto()` for programmatic navigation, `invalidateAll()` and `invalidate(url)` to re-run load functions\n- `$app/paths` - `base` and `assets` paths configured in `svelte.config.js`\n- `$app/forms` - Utilities for handling form submissions and form data\n- `$app/state` - Read-only state objects: `page`, `navigating`, `updated` (SvelteKit 2.12+)\n- `$app/stores` - Legacy store-based state (use `$app/state` instead)\n- `$app/server` - Server-only utilities for hooks, routes, and server load functions\n- `$service-worker` - Service worker functionality access\n\n## Environment Variables\n- `$env/static/public` - Public variables (prefixed `PUBLIC_`) injected at build time, safe for client\n- `$env/static/private` - Private variables statically replaced at build time, server-only\n- `$env/dynamic/public` - Runtime access to public variables in server and client code\n- `$env/dynamic/private` - Runtime access to private variables on server side\n\n## Type Safety\n`$app/types` exports auto-generated TypeScript utilities: `Asset`, `RouteId`, `Pathname`, `ResolvedPathname`, `RouteParams\u003C'/blog/[slug]'>` → `{ slug: string }`, `LayoutParams`. Generated `.d.ts` files export typed `RequestHandler`, `Load`, `PageData`, `LayoutData`, `ActionData`. Helper types `PageProps` and `LayoutProps` (v2.16.0+) combine data with form/children.\n\n## Configuration & Build\n- `svelte.config.js` - Project configuration with `kit` property for adapter selection and options\n- `svelte-kit sync` - Generates `tsconfig.json` and `./$types` definitions (runs as `prepare` script)\n- Vite CLI - `vite dev`, `vite build`, `vite preview` for development and building\n- `$lib` - Automatic import alias for `src/lib` directory (customizable in config)\n\n## Adapters & Polyfills\n- Node.js adapter - Runtime for server-side rendering and backend deployment\n- Node.js polyfills - Browser APIs available in server-side contexts\n- Vite integration - Build system plugin and configuration utilities","## Core Modules\n- `$app/navigation` - `goto()`, `invalidateAll()`, `invalidate(url)`\n- `$app/environment`, `$app/paths`, `$app/forms`, `$app/state` - Runtime utilities\n- `$app/server` - Server-only operations\n- `$env/static/public|private`, `$env/dynamic/public|private` - Environment variables\n\n## Types & Config\n- `$app/types` - Auto-generated route types: `RouteParams\u003C'/blog/[slug]'>` → `{ slug: string }`\n- `svelte.config.js` - Kit configuration with adapter selection\n- `svelte-kit sync` - Generate types and config\n- `$lib` - Alias for `src/lib`\n\n## Server\n- `@sveltejs/kit/hooks` - `handle`, `handleError`, `handleFetch` in `hooks.server.js`\n- Node.js adapter for SSR and deployment","Complete reference for SvelteKit's runtime modules, environment variables, type system, configuration, and server-side APIs.","index",{"name":1399,"path":1399,"children":1401,"data":1402},["Map"],{"type":22,"path":1403,"relevant":24,"token_counts":1404,"usage":1405,"markdown":1407},"index.md",{"fulltext":702,"digest":701,"short_digest":487},{"input":136,"output":1406,"details":32},148,{"fulltext":1408,"digest":1409,"short_digest":1410,"essence":1411},"---\ntitle: SvelteKit\n---\n","This is the main entry point for SvelteKit documentation. It serves as the homepage and starting point for developers learning about or working with SvelteKit.","Main documentation homepage for SvelteKit.","SvelteKit documentation homepage"],"uses":{"params":["name"]}}]}
