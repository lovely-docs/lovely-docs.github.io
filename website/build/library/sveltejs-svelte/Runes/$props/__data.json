{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","Runes/$props",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","02-runes/05-$props.md",true,{"fulltext":8,"digest":9,"short_digest":10},2929,439,123,{"input":12,"output":13,"details":14},3968,673,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: $props\n---\n\nThe inputs to a component are referred to as _props_, which is short for _properties_. You pass props to components just like you pass attributes to elements:\n\n```svelte\n\u003C!--- file: App.svelte --->\n\u003Cscript>\n\timport MyComponent from './MyComponent.svelte';\n\u003C/script>\n\n\u003CMyComponent adjective=\"cool\" />\n```\n\nOn the other side, inside `MyComponent.svelte`, we can receive props with the `$props` rune...\n\n```svelte\n\u003C!--- file: MyComponent.svelte --->\n\u003Cscript>\n\tlet props = $props();\n\u003C/script>\n\n\u003Cp>this component is {props.adjective}\u003C/p>\n```\n\n...though more commonly, you'll [_destructure_](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) your props:\n\n```svelte\n\u003C!--- file: MyComponent.svelte --->\n\u003Cscript>\n\tlet +++{ adjective }+++ = $props();\n\u003C/script>\n\n\u003Cp>this component is {+++adjective+++}\u003C/p>\n```\n\n## Fallback values\n\nDestructuring allows us to declare fallback values, which are used if the parent component does not set a given prop (or the value is `undefined`):\n\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n> [!NOTE] Fallback values are not turned into reactive state proxies (see [Updating props](#Updating-props) for more info)\n\n## Renaming props\n\nWe can also use the destructuring assignment to rename props, which is necessary if they're invalid identifiers, or a JavaScript keyword like `super`:\n\n```js\nlet { super: trouper = 'lights are gonna find me' } = $props();\n```\n\n## Rest props\n\nFinally, we can use a _rest property_ to get, well, the rest of the props:\n\n```js\nlet { a, b, c, ...others } = $props();\n```\n\n## Updating props\n\nReferences to a prop inside a component update when the prop itself updates — when `count` changes in `App.svelte`, it will also change inside `Child.svelte`. But the child component is able to temporarily override the prop value, which can be useful for unsaved ephemeral state ([demo](/playground/untitled#H4sIAAAAAAAAE6WQ0WrDMAxFf0WIQR0Wmu3VTQJln7HsIfVcZubIxlbGRvC_DzuBraN92qPula50tODZWB1RPi_IX16jLALWSOOUq6P3-_ihLWftNEZ9TVeOWBNHlNhGFYznfqCBzeRdYHh6M_YVzsFNsNs3pdpGd4eBcqPVDMrNxNDBXeSRtXioDgO1zU8ataeZ2RE4Utao924RFXQ9iHXwvoPHKpW1xY4g_Bg0cSVhKS0p560Za95612ZC02ONrD8ZJYdZp_rGQ37ff_mSP86Np2TWZaNNmdcH56P4P67K66_SXoK9pG-5dF5Z9QEAAA==)):\n\n```svelte\n\u003C!--- file: App.svelte --->\n\u003Cscript>\n\timport Child from './Child.svelte';\n\n\tlet count = $state(0);\n\u003C/script>\n\n\u003Cbutton onclick={() => (count += 1)}>\n\tclicks (parent): {count}\n\u003C/button>\n\n\u003CChild {count} />\n```\n\n```svelte\n\u003C!--- file: Child.svelte --->\n\u003Cscript>\n\tlet { count } = $props();\n\u003C/script>\n\n\u003Cbutton onclick={() => (count += 1)}>\n\tclicks (child): {count}\n\u003C/button>\n```\n\nWhile you can temporarily _reassign_ props, you should not _mutate_ props unless they are [bindable]($bindable).\n\nIf the prop is a regular object, the mutation will have no effect ([demo](/playground/untitled#H4sIAAAAAAAAE3WQwU7DMBBEf2W1QmorQgJXk0RC3PkBwiExG9WQrC17U4Es_ztKUkQp9OjxzM7bjcjtSKjwyfKNp1aLORA4b13ADHszUED1HFE-3eyaBcy-Mw_O5eFAg8xa1wb6T9eWhVgCKiyD9sZJ3XAjZnTWCzzuzfAKvbcjbPJieR2jm_uGy-InweXqtd0baaliBG0nFgW3kBIUNWYo9CGoxE-UsgvIpw2_oc9-LmAPJBCPDJCggqvlVtvdH9puErEMlvVg9HsVtzuoaojzkKKAfRuALVDfk5ZZW0fmy05wXcFdwyktlUs-KIinljTXrRVnm7-kL9dYLVbUAQAA)):\n\n```svelte\n\u003C!--- file: App.svelte --->\n\u003Cscript>\n\timport Child from './Child.svelte';\n\u003C/script>\n\n\u003CChild object={{ count: 0 }} />\n```\n\n```svelte\n\u003C!--- file: Child.svelte --->\n\u003Cscript>\n\tlet { object } = $props();\n\u003C/script>\n\n\u003Cbutton onclick={() => {\n\t// has no effect\n\tobject.count += 1\n}}>\n\tclicks: {object.count}\n\u003C/button>\n```\n\nIf the prop is a reactive state proxy, however, then mutations _will_ have an effect but you will see an [`ownership_invalid_mutation`](runtime-warnings#Client-warnings-ownership_invalid_mutation) warning, because the component is mutating state that does not 'belong' to it ([demo](/playground/untitled#H4sIAAAAAAAAE3WR0U7DMAxFf8VESBuiauG1WycheOEbKA9p67FA6kSNszJV-XeUZhMw2GN8r-1znUmQ7FGU4pn2UqsOes-SlSGRia3S6ET5Mgk-2OiJBZGdOh6szd0eNcdaIx3-V28NMRI7UYq1awdleVNTzaq3ZmB43CndwXYwPSzyYn4dWxermqJRI4Np3rFlqODasWRcTtAaT1zCHYSbVU3r4nsyrdPMKTUFKDYiE4yfLEoePIbsQpqfy3_nOVMuJIqg0wk1RFg7GOuWfwEbz2wIDLVatR_VtLyBagNTHFIUMCqtoZXeIfAOU1JoUJsR2IC3nWTMjt7GM4yKdyBhlAMpesvhydCC0y_i0ZagHByMh26WzUhXUUxKnpbcVnBfUwhznJnNlac7JkuIURL-2VVfwxflyrWcSQIAAA==)):\n\n```svelte\n\u003C!--- file: App.svelte --->\n\u003Cscript>\n\timport Child from './Child.svelte';\n\n\tlet object = $state({count: 0});\n\u003C/script>\n\n\u003CChild {object} />\n```\n\n```svelte\n\u003C!--- file: Child.svelte --->\n\u003Cscript>\n\tlet { object } = $props();\n\u003C/script>\n\n\u003Cbutton onclick={() => {\n\t// will cause the count below to update,\n\t// but with a warning. Don't mutate\n\t// objects you don't own!\n\tobject.count += 1\n}}>\n\tclicks: {object.count}\n\u003C/button>\n```\n\nThe fallback value of a prop not declared with `$bindable` is left untouched — it is not turned into a reactive state proxy — meaning mutations will not cause updates ([demo](/playground/untitled#H4sIAAAAAAAAE3WQwU7DMBBEf2VkIbUVoYFraCIh7vwA4eC4G9Wta1vxpgJZ_nfkBEQp9OjxzOzTRGHlkUQlXpy9G0gq1idCL43ppDrAD84HUYheGwqieo2CP3y2Z0EU3-En79fhRIaz1slA_-nKWSbLQVRiE9SgPTetbVkfvRsYzztttugHd8RiXU6vr-jisbWb8idhN7O3bEQhmN5ZVDyMlIorcOddv_Eufq4AGmJEuG5PilEjQrnRcoV7JCTUuJlGWq7-YHYjs7NwVhmtDnVcrlA3iLmzLLGTAdaB-j736h68Oxv-JM1I0AFjoG1OzPfX023c1nhobUoT39QeKsRzS8owM8DFTG_pE6dcVl70AQAA))\n\n```svelte\n\u003C!--- file: Child.svelte --->\n\u003Cscript>\n\tlet { object = { count: 0 } } = $props();\n\u003C/script>\n\n\u003Cbutton onclick={() => {\n\t// has no effect if the fallback value is used\n\tobject.count += 1\n}}>\n\tclicks: {object.count}\n\u003C/button>\n```\n\nIn summary: don't mutate props. Either use callback props to communicate changes, or — if parent and child should share the same object — use the [`$bindable`]($bindable) rune.\n\n## Type safety\n\nYou can add type safety to your components by annotating your props, as you would with any other variable declaration. In TypeScript that might look like this...\n\n```svelte\n\u003Cscript lang=\"ts\">\n\tlet { adjective }: { adjective: string } = $props();\n\u003C/script>\n```\n\n...while in JSDoc you can do this:\n\n```svelte\n\u003Cscript>\n\t/** @type {{ adjective: string }} */\n\tlet { adjective } = $props();\n\u003C/script>\n```\n\nYou can, of course, separate the type declaration from the annotation:\n\n```svelte\n\u003Cscript lang=\"ts\">\n\tinterface Props {\n\t\tadjective: string;\n\t}\n\n\tlet { adjective }: Props = $props();\n\u003C/script>\n```\n\n> [!NOTE] Interfaces for native DOM elements are provided in the `svelte/elements` module (see [Typing wrapper components](typescript#Typing-wrapper-components))\n\nAdding types is recommended, as it ensures that people using your component can easily discover which props they should provide.\n\n\n## `$props.id()`\n\nThis rune, added in version 5.20.0, generates an ID that is unique to the current component instance. When hydrating a server-rendered component, the value will be consistent between server and client.\n\nThis is useful for linking elements via attributes like `for` and `aria-labelledby`.\n\n```svelte\n\u003Cscript>\n\tconst uid = $props.id();\n\u003C/script>\n\n\u003Cform>\n\t\u003Clabel for=\"{uid}-firstname\">First Name: \u003C/label>\n\t\u003Cinput id=\"{uid}-firstname\" type=\"text\" />\n\n\t\u003Clabel for=\"{uid}-lastname\">Last Name: \u003C/label>\n\t\u003Cinput id=\"{uid}-lastname\" type=\"text\" />\n\u003C/form>\n```\n","## $props rune\n\nReceive component inputs (props) using the `$props()` rune:\n\n```svelte\n\u003Cscript>\n\tlet { adjective } = $props();\n\u003C/script>\n\n\u003Cp>this component is {adjective}\u003C/p>\n```\n\n### Fallback values\nProvide defaults for props not set by parent:\n```js\nlet { adjective = 'happy' } = $props();\n```\n\n### Renaming props\nRename props using destructuring (useful for keywords or invalid identifiers):\n```js\nlet { super: trouper = 'lights are gonna find me' } = $props();\n```\n\n### Rest props\nCapture remaining props:\n```js\nlet { a, b, c, ...others } = $props();\n```\n\n### Updating props\nProps update reactively when parent changes them. Child can temporarily reassign but should not mutate props unless they're bindable. Mutating regular object props has no effect. Mutating reactive state proxy props causes updates but triggers an `ownership_invalid_mutation` warning. Fallback values are not reactive proxies, so mutations have no effect.\n\n### Type safety\nAdd type annotations for better IDE support:\n```svelte\n\u003Cscript lang=\"ts\">\n\tinterface Props {\n\t\tadjective: string;\n\t}\n\tlet { adjective }: Props = $props();\n\u003C/script>\n```\n\nOr with JSDoc:\n```svelte\n\u003Cscript>\n\t/** @type {{ adjective: string }} */\n\tlet { adjective } = $props();\n\u003C/script>\n```\n\n### $props.id()\nGenerate unique component instance IDs (consistent during hydration):\n```svelte\n\u003Cscript>\n\tconst uid = $props.id();\n\u003C/script>\n\n\u003Clabel for=\"{uid}-firstname\">First Name:\u003C/label>\n\u003Cinput id=\"{uid}-firstname\" type=\"text\" />\n```","## $props rune\n\nReceive component props with destructuring:\n```svelte\nlet { adjective = 'happy' } = $props();\n```\n\nRename props: `let { super: trouper } = $props();`\n\nRest props: `let { a, b, ...others } = $props();`\n\nProps update reactively but shouldn't be mutated unless bindable. Add type safety with TypeScript or JSDoc.\n\nGenerate unique instance IDs with `$props.id()` for linking elements.","The $props rune receives component inputs with destructuring, fallback values, renaming, and type safety support."],"uses":{"params":["name","path"]}}]}
