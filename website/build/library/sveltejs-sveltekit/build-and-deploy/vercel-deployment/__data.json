{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-sveltekit","build-and-deploy/vercel-deployment",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","25-build-and-deploy/90-adapter-vercel.md",true,{"fulltext":8,"digest":9,"short_digest":10},2844,995,342,{"input":12,"output":13,"details":14},3892,1462,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: Vercel\n---\n\nTo deploy to Vercel, use [`adapter-vercel`](https://github.com/sveltejs/kit/tree/main/packages/adapter-vercel).\n\nThis adapter will be installed by default when you use [`adapter-auto`](adapter-auto), but adding it to your project allows you to specify Vercel-specific options.\n\n## Usage\n\nInstall with `npm i -D @sveltejs/adapter-vercel`, then add the adapter to your `svelte.config.js`:\n\n```js\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-vercel';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// see below for options that can be set here\n\t\t})\n\t}\n};\n\nexport default config;\n```\n\n## Deployment configuration\n\nTo control how your routes are deployed to Vercel as functions, you can specify deployment configuration, either through the option shown above or with [`export const config`](page-options#config) inside `+server.js`, `+page(.server).js` and `+layout(.server).js` files.\n\nFor example you could deploy one specific route as an individual serverless function, separate from the rest of your app:\n\n```js\n/// file: about/+page.js\n/** @type {import('@sveltejs/adapter-vercel').Config} */\nexport const config = {\n\tsplit: true\n};\n```\n\nThe following options apply to all functions:\n\n- `runtime`: `'edge'`, `'nodejs20.x'` or `'nodejs22.x'`. By default, the adapter will select the `'nodejs\u003Cversion>.x'` corresponding to the Node version your project is configured to use on the Vercel dashboard\n  > [!NOTE] This option is deprecated and will be removed in a future version, at which point all your functions will use whichever Node version is specified in the project configuration on Vercel\n- `regions`: an array of [edge network regions](https://vercel.com/docs/concepts/edge-network/regions) (defaulting to `[\"iad1\"]` for serverless functions) or `'all'` if `runtime` is `edge` (its default). Note that multiple regions for serverless functions are only supported on Enterprise plans\n- `split`: if `true`, causes a route to be deployed as an individual function. If `split` is set to `true` at the adapter level, all routes will be deployed as individual functions\n\nAdditionally, the following option applies to edge functions:\n- `external`: an array of dependencies that esbuild should treat as external when bundling functions. This should only be used to exclude optional dependencies that will not run outside Node\n\nAnd the following option apply to serverless functions:\n- `memory`: the amount of memory available to the function. Defaults to `1024` Mb, and can be decreased to `128` Mb or [increased](https://vercel.com/docs/concepts/limits/overview#serverless-function-memory) in 64Mb increments up to `3008` Mb on Pro or Enterprise accounts\n- `maxDuration`: [maximum execution duration](https://vercel.com/docs/functions/runtimes#max-duration) of the function. Defaults to `10` seconds for Hobby accounts, `15` for Pro and `900` for Enterprise\n- `isr`: configuration Incremental Static Regeneration, described below\n\nConfiguration set in a layout applies to all the routes beneath that layout, unless overridden at a more granular level.\n\nIf your functions need to access data in a specific region, it's recommended that they be deployed in the same region (or close to it) for optimal performance.\n\n## Image Optimization\n\nYou may set the `images` config to control how Vercel builds your images. See the [image configuration reference](https://vercel.com/docs/build-output-api/v3/configuration#images) for full details. As an example, you may set:\n\n```js\n/// file: svelte.config.js\nimport adapter from '@sveltejs/adapter-vercel';\n\n/** @type {import('@sveltejs/kit').Config} */\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\timages: {\n\t\t\t\tsizes: [640, 828, 1200, 1920, 3840],\n\t\t\t\tformats: ['image/avif', 'image/webp'],\n\t\t\t\tminimumCacheTTL: 300,\n\t\t\t\tdomains: ['example-app.vercel.app'],\n\t\t\t}\n\t\t})\n\t}\n};\n\nexport default config;\n```\n\n## Incremental Static Regeneration\n\nVercel supports [Incremental Static Regeneration](https://vercel.com/docs/incremental-static-regeneration) (ISR), which provides the performance and cost advantages of prerendered content with the flexibility of dynamically rendered content.\n\n> [!NOTE] Use ISR only on routes where every visitor should see the same content (much like when you prerender). If there's anything user-specific happening (like session cookies), they should happen on the client via JavaScript only to not leak sensitive information across visits\n\nTo add ISR to a route, include the `isr` property in your `config` object:\n\n```js\nimport { BYPASS_TOKEN } from '$env/static/private';\n\n/** @type {import('@sveltejs/adapter-vercel').Config} */\nexport const config = {\n\tisr: {\n\t\texpiration: 60,\n\t\tbypassToken: BYPASS_TOKEN,\n\t\tallowQuery: ['search']\n\t}\n};\n```\n\n> [!NOTE] Using ISR on a route with `export const prerender = true` will have no effect, since the route is prerendered at build time\n\nThe `expiration` property is required; all others are optional. The properties are discussed in more detail below.\n\n### expiration\n\nThe expiration time (in seconds) before the cached asset will be re-generated by invoking the Serverless Function. Setting the value to `false` means it will never expire. In that case, you likely want to define a bypass token to re-generate on demand.\n\n### bypassToken\n\nA random token that can be provided in the URL to bypass the cached version of the asset, by requesting the asset with a `__prerender_bypass=\u003Ctoken>` cookie.\n\nMaking a `GET` or `HEAD` request with `x-prerender-revalidate: \u003Ctoken>` will force the asset to be re-validated.\n\nNote that the `BYPASS_TOKEN` string must be at least 32 characters long. You could generate one using the JavaScript console like so:\n\n```js\ncrypto.randomUUID();\n```\n\nSet this string as an environment variable on Vercel by logging in and going to your project then Settings > Environment Variables. For \"Key\" put `BYPASS_TOKEN` and for \"value\" use the string generated above, then hit \"Save\".\n\nTo get this key known about for local development, you can use the [Vercel CLI](https://vercel.com/docs/cli/env) by running the `vercel env pull` command locally like so:\n\n```sh\nvercel env pull .env.development.local\n```\n\n### allowQuery\n\nA list of valid query parameters that contribute to the cache key. Other parameters (such as utm tracking codes) will be ignored, ensuring that they do not result in content being re-generated unnecessarily. By default, query parameters are ignored.\n\n> [!NOTE] Pages that are  [prerendered](page-options#prerender) will ignore ISR configuration.\n\n## Environment variables\n\nVercel makes a set of [deployment-specific environment variables](https://vercel.com/docs/concepts/projects/environment-variables#system-environment-variables) available. Like other environment variables, these are accessible from `$env/static/private` and `$env/dynamic/private` (sometimes — more on that later), and inaccessible from their public counterparts. To access one of these variables from the client:\n\n```js\n/// file: +layout.server.js\nimport { VERCEL_COMMIT_REF } from '$env/static/private';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport function load() {\n\treturn {\n\t\tdeploymentGitBranch: VERCEL_COMMIT_REF\n\t};\n}\n```\n\n```svelte\n\u003C!--- file: +layout.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').LayoutProps} */\n\tlet { data } = $props();\n\u003C/script>\n\n\u003Cp>This staging environment was deployed from {data.deploymentGitBranch}.\u003C/p>\n```\n\nSince all of these variables are unchanged between build time and run time when building on Vercel, we recommend using `$env/static/private` — which will statically replace the variables, enabling optimisations like dead code elimination — rather than `$env/dynamic/private`.\n\n## Skew protection\n\nWhen a new version of your app is deployed, assets belonging to the previous version may no longer be accessible. If a user is actively using your app when this happens, it can cause errors when they navigate — this is known as _version skew_. SvelteKit mitigates this by detecting errors resulting from version skew and causing a hard reload to get the latest version of the app, but this will cause any client-side state to be lost. (You can also proactively mitigate it by observing [`updated.current`]($app-state#updated) from `$app/state`, which tells clients when a new version has been deployed.)\n\n[Skew protection](https://vercel.com/docs/deployments/skew-protection) is a Vercel feature that routes client requests to their original deployment. When a user visits your app, a cookie is set with the deployment ID, and any subsequent requests will be routed to that deployment for as long as skew protection is active. When they reload the page, they will get the newest deployment. (`updated.current` is exempted from this behaviour, and so will continue to report new deployments.) To enable it, visit the Advanced section of your project settings on Vercel.\n\nCookie-based skew protection comes with one caveat: if a user has multiple versions of your app open in multiple tabs, requests from older versions will be routed to the newer one, meaning they will fall back to SvelteKit's built-in skew protection.\n\n## Notes\n\n### Vercel functions\n\nIf you have Vercel functions contained in the `api` directory at the project's root, any requests for `/api/*` will _not_ be handled by SvelteKit. You should implement these as [API routes](routing#server) in your SvelteKit app instead, unless you need to use a non-JavaScript language in which case you will need to ensure that you don't have any `/api/*` routes in your SvelteKit app.\n\n### Node version\n\nProjects created before a certain date may default to using an older Node version than what SvelteKit currently requires. You can [change the Node version in your project settings](https://vercel.com/docs/concepts/functions/serverless-functions/runtimes/node-js#node.js-version).\n\n## Troubleshooting\n\n### Accessing the file system\n\nYou can't use `fs` in edge functions.\n\nYou _can_ use it in serverless functions, but it won't work as expected, since files are not copied from your project into your deployment. Instead, use the [`read`]($app-server#read) function from `$app/server` to access your files. It also works inside routes deployed as edge functions by fetching the file from the deployed public assets location.\n\nAlternatively, you can [prerender](page-options#prerender) the routes in question.\n\n### Deployment protection\n\nIf using [`read`]($app-server#read) in an edge function, SvelteKit will `fetch` the file in question from your deployment. If you are using [Deployment Protection](https://vercel.com/docs/deployment-protection), you must also enable [Protection Bypass for Automation](https://vercel.com/docs/deployment-protection/methods-to-bypass-deployment-protection/protection-bypass-automation) so that the request does not result in a [401 Unauthorized](https://http.dog/401) response.\n","## Installation and Setup\n\nInstall `@sveltejs/adapter-vercel` and configure it in `svelte.config.js`:\n\n```js\nimport adapter from '@sveltejs/adapter-vercel';\n\nconst config = {\n\tkit: {\n\t\tadapter: adapter({\n\t\t\t// options here\n\t\t})\n\t}\n};\n\nexport default config;\n```\n\n## Deployment Configuration\n\nControl route deployment via `export const config` in `+server.js`, `+page(.server).js`, or `+layout(.server).js`:\n\n```js\nexport const config = {\n\tsplit: true,\n\truntime: 'nodejs20.x',\n\tregions: ['iad1'],\n\tmemory: 1024,\n\tmaxDuration: 15\n};\n```\n\n**Options:**\n- `runtime`: `'edge'`, `'nodejs20.x'`, or `'nodejs22.x'` (deprecated, will use project config)\n- `regions`: array of edge regions or `'all'` for edge functions (default `[\"iad1\"]` for serverless)\n- `split`: deploy route as individual function if `true`\n- `memory`: 128-3008 MB (default 1024)\n- `maxDuration`: max execution time in seconds (default 10/15/900 depending on plan)\n- `external`: array of dependencies to exclude from edge function bundling\n\n## Image Optimization\n\nConfigure image handling in adapter options:\n\n```js\nadapter({\n\timages: {\n\t\tsizes: [640, 828, 1200, 1920, 3840],\n\t\tformats: ['image/avif', 'image/webp'],\n\t\tminimumCacheTTL: 300,\n\t\tdomains: ['example-app.vercel.app']\n\t}\n})\n```\n\n## Incremental Static Regeneration (ISR)\n\nEnable ISR for routes with cached content that regenerates on expiration:\n\n```js\nexport const config = {\n\tisr: {\n\t\texpiration: 60,\n\t\tbypassToken: BYPASS_TOKEN,\n\t\tallowQuery: ['search']\n\t}\n};\n```\n\n- `expiration`: seconds before cache regenerates (required; `false` = never expire)\n- `bypassToken`: token to bypass cache via `__prerender_bypass=\u003Ctoken>` cookie or `x-prerender-revalidate` header (must be 32+ chars)\n- `allowQuery`: query parameters that contribute to cache key; others ignored\n\nGenerate token: `crypto.randomUUID()`. Set as environment variable `BYPASS_TOKEN` in Vercel project settings. Pull locally with `vercel env pull .env.development.local`.\n\n## Environment Variables\n\nAccess Vercel deployment variables via `$env/static/private` or `$env/dynamic/private`:\n\n```js\n// +layout.server.js\nimport { VERCEL_COMMIT_REF } from '$env/static/private';\n\nexport function load() {\n\treturn { deploymentGitBranch: VERCEL_COMMIT_REF };\n}\n```\n\nUse `$env/static/private` for static replacement and dead code elimination.\n\n## Skew Protection\n\nEnable in Vercel project Advanced settings. Routes client requests to their original deployment via cookie with deployment ID. When user reloads, they get newest deployment. `updated.current` always reports new deployments.\n\nCaveat: multiple tabs with different versions will route older tabs to newer deployment, triggering SvelteKit's built-in skew protection.\n\n## Troubleshooting\n\n**File system access:** Can't use `fs` in edge functions. In serverless functions, use `read()` from `$app/server` instead (works in edge functions too by fetching from public assets). Alternatively, prerender routes.\n\n**Deployment Protection:** If using `read()` in edge functions with Deployment Protection enabled, enable \"Protection Bypass for Automation\" to avoid 401 errors.\n\n**Vercel `/api` directory:** Requests to `/api/*` won't be handled by SvelteKit if you have Vercel functions in the `api` directory. Implement as SvelteKit API routes instead, unless using non-JavaScript languages.\n\n**Node version:** Older projects may use outdated Node versions. Update in project settings.","## Setup\n\nInstall `@sveltejs/adapter-vercel` and add to `svelte.config.js`.\n\n## Configuration\n\nSet options via `export const config` in route files:\n- `runtime`: `'edge'` or `'nodejs20.x'`/`'nodejs22.x'`\n- `regions`: array of edge regions\n- `split`: deploy as individual function\n- `memory`: 128-3008 MB\n- `maxDuration`: execution time limit\n- `external`: exclude dependencies from edge bundling\n\n## ISR (Incremental Static Regeneration)\n\n```js\nexport const config = {\n\tisr: {\n\t\texpiration: 60,\n\t\tbypassToken: BYPASS_TOKEN,\n\t\tallowQuery: ['search']\n\t}\n};\n```\n\nBypass cache with `__prerender_bypass=\u003Ctoken>` cookie or `x-prerender-revalidate` header.\n\n## Images\n\nConfigure in adapter options with `sizes`, `formats`, `minimumCacheTTL`, `domains`.\n\n## Environment Variables\n\nAccess via `$env/static/private` (preferred for static replacement).\n\n## Troubleshooting\n\n- Edge functions: can't use `fs`, use `read()` from `$app/server`\n- Serverless: `fs` won't work as expected, use `read()` instead\n- Deployment Protection: enable \"Protection Bypass for Automation\" for edge functions using `read()`","Configure and deploy SvelteKit apps to Vercel with adapter-vercel, supporting serverless/edge functions, ISR, image optimization, and environment variables."],"uses":{"params":["name","path"]}}]}
