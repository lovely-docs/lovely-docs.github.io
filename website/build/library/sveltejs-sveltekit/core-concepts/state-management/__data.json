{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-sveltekit","core-concepts/state-management",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","20-core-concepts/50-state-management.md",true,{"fulltext":8,"digest":9,"short_digest":10},2189,635,174,{"input":12,"output":13,"details":14},3234,934,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: State management\n---\n\nIf you're used to building client-only apps, state management in an app that spans server and client might seem intimidating. This section provides tips for avoiding some common gotchas.\n\n## Avoid shared state on the server\n\nBrowsers are _stateful_ — state is stored in memory as the user interacts with the application. Servers, on the other hand, are _stateless_ — the content of the response is determined entirely by the content of the request.\n\nConceptually, that is. In reality, servers are often long-lived and shared by multiple users. For that reason it's important not to store data in shared variables. For example, consider this code:\n\n```js\n// @errors: 7034 7005\n/// file: +page.server.js\nlet user;\n\n/** @type {import('./$types').PageServerLoad} */\nexport function load() {\n\treturn { user };\n}\n\n/** @satisfies {import('./$types').Actions} */\nexport const actions = {\n\tdefault: async ({ request }) => {\n\t\tconst data = await request.formData();\n\n\t\t// NEVER DO THIS!\n\t\tuser = {\n\t\t\tname: data.get('name'),\n\t\t\tembarrassingSecret: data.get('secret')\n\t\t};\n\t}\n}\n```\n\nThe `user` variable is shared by everyone who connects to this server. If Alice submitted an embarrassing secret, and Bob visited the page after her, Bob would know Alice's secret. In addition, when Alice returns to the site later in the day, the server may have restarted, losing her data.\n\nInstead, you should _authenticate_ the user using [`cookies`](load#Cookies) and persist the data to a database.\n\n## No side-effects in load\n\nFor the same reason, your `load` functions should be _pure_ — no side-effects (except maybe the occasional `console.log(...)`). For example, you might be tempted to write to a store or global state inside a `load` function so that you can use the value in your components:\n\n```js\n/// file: +page.js\n// @filename: ambient.d.ts\ndeclare module '$lib/user' {\n\texport const user: { set: (value: any) => void };\n}\n\n// @filename: index.js\n// ---cut---\nimport { user } from '$lib/user';\n\n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch }) {\n\tconst response = await fetch('/api/user');\n\n\t// NEVER DO THIS!\n\tuser.set(await response.json());\n}\n```\n\nAs with the previous example, this puts one user's information in a place that is shared by _all_ users. Instead, just return the data...\n\n```js\n/// file: +page.js\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ fetch }) {\n\tconst response = await fetch('/api/user');\n\n+++\treturn {\n\t\tuser: await response.json()\n\t};+++\n}\n```\n\n...and pass it around to the components that need it, or use [`page.data`](load#page.data).\n\nIf you're not using SSR, then there's no risk of accidentally exposing one user's data to another. But you should still avoid side-effects in your `load` functions — your application will be much easier to reason about without them.\n\n## Using state and stores with context\n\nYou might wonder how we're able to use `page.data` and other [app state]($app-state) (or [app stores]($app-stores)) if we can't use global state. The answer is that app state and app stores on the server use Svelte's [context API](/tutorial/svelte/context-api) — the state (or store) is attached to the component tree with `setContext`, and when you subscribe you retrieve it with `getContext`. We can do the same thing with our own state:\n\n```svelte\n\u003C!--- file: src/routes/+layout.svelte --->\n\u003Cscript>\n\timport { setContext } from 'svelte';\n\n\t/** @type {import('./$types').LayoutProps} */\n\tlet { data } = $props();\n\n\t// Pass a function referencing our state\n\t// to the context for child components to access\n\tsetContext('user', () => data.user);\n\u003C/script>\n```\n\n```svelte\n\u003C!--- file: src/routes/user/+page.svelte --->\n\u003Cscript>\n\timport { getContext } from 'svelte';\n\n\t// Retrieve user store from context\n\tconst user = getContext('user');\n\u003C/script>\n\n\u003Cp>Welcome {user().name}\u003C/p>\n```\n\n> [!NOTE] We're passing a function into `setContext` to keep reactivity across boundaries. Read more about it [here](/docs/svelte/$state#Passing-state-into-functions)\n\n> [!LEGACY]\n> You also use stores from `svelte/store` for this, but when using Svelte 5 it is recommended to make use of universal reactivity instead.\n\nUpdating the value of context-based state in deeper-level pages or components while the page is being rendered via SSR will not affect the value in the parent component because it has already been rendered by the time the state value is updated. In contrast, on the client (when CSR is enabled, which is the default) the value will be propagated and components, pages, and layouts higher in the hierarchy will react to the new value. Therefore, to avoid values 'flashing' during state updates during hydration, it is generally recommended to pass state down into components rather than up.\n\nIf you're not using SSR (and can guarantee that you won't need to use SSR in future) then you can safely keep state in a shared module, without using the context API.\n\n## Component and page state is preserved\n\nWhen you navigate around your application, SvelteKit reuses existing layout and page components. For example, if you have a route like this...\n\n```svelte\n\u003C!--- file: src/routes/blog/[slug]/+page.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\n\t// THIS CODE IS BUGGY!\n\tconst wordCount = data.content.split(' ').length;\n\tconst estimatedReadingTime = wordCount / 250;\n\u003C/script>\n\n\u003Cheader>\n\t\u003Ch1>{data.title}\u003C/h1>\n\t\u003Cp>Reading time: {Math.round(estimatedReadingTime)} minutes\u003C/p>\n\u003C/header>\n\n\u003Cdiv>{@html data.content}\u003C/div>\n```\n\n...then navigating from `/blog/my-short-post` to `/blog/my-long-post` won't cause the layout, page and any other components within to be destroyed and recreated. Instead the `data` prop (and by extension `data.title` and `data.content`) will update (as it would with any other Svelte component) and, because the code isn't rerunning, lifecycle methods like `onMount` and `onDestroy` won't rerun and `estimatedReadingTime` won't be recalculated.\n\nInstead, we need to make the value [_reactive_](/tutorial/svelte/state):\n\n```svelte\n/// file: src/routes/blog/[slug]/+page.svelte\n\u003Cscript>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\n+++\tlet wordCount = $derived(data.content.split(' ').length);\n\tlet estimatedReadingTime = $derived(wordCount / 250);+++\n\u003C/script>\n```\n\n> [!NOTE] If your code in `onMount` and `onDestroy` has to run again after navigation you can use [afterNavigate]($app-navigation#afterNavigate) and [beforeNavigate]($app-navigation#beforeNavigate) respectively.\n\nReusing components like this means that things like sidebar scroll state are preserved, and you can easily animate between changing values. In the case that you do need to completely destroy and remount a component on navigation, you can use this pattern:\n\n```svelte\n\u003Cscript>\n\timport { page } from '$app/state';\n\u003C/script>\n\n{#key page.url.pathname}\n\t\u003CBlogPost title={data.title} content={data.title} />\n{/key}\n```\n\n## Storing state in the URL\n\nIf you have state that should survive a reload and/or affect SSR, such as filters or sorting rules on a table, URL search parameters (like `?sort=price&order=ascending`) are a good place to put them. You can put them in `\u003Ca href=\"...\">` or `\u003Cform action=\"...\">` attributes, or set them programmatically via `goto('?key=value')`. They can be accessed inside `load` functions via the `url` parameter, and inside components via `page.url.searchParams`.\n\n## Storing ephemeral state in snapshots\n\nSome UI state, such as 'is the accordion open?', is disposable — if the user navigates away or refreshes the page, it doesn't matter if the state is lost. In some cases, you _do_ want the data to persist if the user navigates to a different page and comes back, but storing the state in the URL or in a database would be overkill. For this, SvelteKit provides [snapshots](snapshots), which let you associate component state with a history entry.\n","## Avoid shared state on the server\n\nServers are stateless and shared by multiple users. Don't store data in shared variables — this exposes one user's data to others and causes data loss on server restart. Instead, authenticate users with cookies and persist data to a database.\n\n## No side-effects in load functions\n\nLoad functions should be pure. Don't write to stores or global state inside load functions:\n\n```js\n// WRONG\nimport { user } from '$lib/user';\nexport async function load({ fetch }) {\n\tconst response = await fetch('/api/user');\n\tuser.set(await response.json()); // Shared by all users!\n}\n\n// RIGHT\nexport async function load({ fetch }) {\n\tconst response = await fetch('/api/user');\n\treturn { user: await response.json() };\n}\n```\n\nReturn data and pass it to components that need it, or use `page.data`.\n\n## Using state and stores with context\n\nUse Svelte's context API to safely share state on the server:\n\n```svelte\n\u003C!-- +layout.svelte -->\n\u003Cscript>\n\timport { setContext } from 'svelte';\n\tlet { data } = $props();\n\tsetContext('user', () => data.user);\n\u003C/script>\n\n\u003C!-- +page.svelte -->\n\u003Cscript>\n\timport { getContext } from 'svelte';\n\tconst user = getContext('user');\n\u003C/script>\n\u003Cp>Welcome {user().name}\u003C/p>\n```\n\nPass functions into context to maintain reactivity. During SSR, state updates in child components don't affect parent components (already rendered), but on the client they do. Pass state down rather than up to avoid flashing during hydration.\n\n## Component and page state is preserved\n\nWhen navigating between routes with the same layout/page component, the component isn't destroyed — it's reused. This means `onMount`/`onDestroy` don't rerun and local state persists. Make dependent values reactive:\n\n```svelte\n\u003Cscript>\n\tlet { data } = $props();\n\tlet wordCount = $derived(data.content.split(' ').length);\n\tlet estimatedReadingTime = $derived(wordCount / 250);\n\u003C/script>\n```\n\nTo destroy and remount on navigation, use `{#key page.url.pathname}`.\n\n## Storing state in the URL\n\nFor state that should survive reloads or affect SSR (filters, sorting), use URL search parameters: `?sort=price&order=ascending`. Access them in load functions via `url` parameter or in components via `page.url.searchParams`.\n\n## Storing ephemeral state in snapshots\n\nFor disposable UI state like 'is accordion open?', use snapshots to associate component state with history entries.","**Avoid shared state on server** — don't store data in shared variables; use cookies and databases instead.\n\n**No side-effects in load** — return data instead of writing to stores:\n```js\nexport async function load({ fetch }) {\n\treturn { user: await fetch('/api/user').then(r => r.json()) };\n}\n```\n\n**Use context API for safe state sharing** — pass functions into context to maintain reactivity across SSR boundaries.\n\n**Component state is preserved** — make dependent values reactive with `$derived` when data changes.\n\n**URL search parameters** — store state that needs to survive reloads: `?sort=price&order=ascending`.\n\n**Snapshots** — preserve ephemeral UI state across navigation.","Guidelines for managing state in server-rendered and client-side applications, covering shared state pitfalls, load function purity, context API usage, component lifecycle preservation, and state persistence strategies."],"uses":{"params":["name","path"]}}]}
