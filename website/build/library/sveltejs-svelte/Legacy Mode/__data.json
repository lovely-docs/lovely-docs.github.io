{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","Legacy Mode",{"type":4,"path":5,"relevant":6,"token_counts":-1,"usage":7,"markdown":11},"directory","99-legacy",true,{"input":8,"output":9,"details":10},2830,846,null,{"digest":12,"short_digest":13,"essence":14},"## Reactive Variables & Statements\n\nTop-level variables are automatically reactive via assignment-based reactivity. Mutations require reassignment to trigger updates:\n```svelte\nlet numbers = [1, 2, 3];\nnumbers.push(4); // no update\nnumbers = numbers; // triggers update\n```\n\n`$:` prefix makes statements reactiveâ€”they re-run when dependencies change and are topologically ordered:\n```svelte\nlet a = 1, b = 2;\n$: sum = a + b;\n$: console.log(`sum: ${sum}`);\n```\n\n## Props & Exports\n\nDeclare props with `export let`:\n```svelte\nexport let foo;\nexport let bar = 'default value';\nexport { className as class };\n```\n\nAccess all props via `$$props` and undeclared props via `$$restProps`.\n\n## Event Handling\n\nAttach handlers with `on:` directive and chain modifiers:\n```svelte\n\u003Cbutton on:click={handleClick}>click\u003C/button>\n\u003Cform on:submit|preventDefault|once={handle}>\u003C/form>\n```\n\nAvailable modifiers: `preventDefault`, `stopPropagation`, `stopImmediatePropagation`, `passive`, `nonpassive`, `capture`, `once`, `self`, `trusted`\n\nDispatch component events with `createEventDispatcher()`:\n```svelte\nimport { createEventDispatcher } from 'svelte';\nconst dispatch = createEventDispatcher();\ndispatch('increment');\n```\n\n## Slots\n\nRender slotted content with `\u003Cslot>` and named slots with `slot=\"name\"` attribute. Pass data to slots via props and expose to parent using `let:` directive. Check for named slots with `$$slots` object:\n```svelte\n{#if $$slots.description}\n  \u003Cslot name=\"description\" />\n{/if}\n```\n\nUse `\u003Csvelte:fragment slot=\"name\">` to fill named slots without wrapping DOM elements.\n\n## Dynamic Components\n\nUse `\u003Csvelte:component this={MyComponent} />` to re-render when component value changes.\n\n## Imperative API\n\nCreate components imperatively:\n```ts\nconst app = new App({\n  target: document.body,\n  props: { answer: 42 }\n});\napp.$set(props);\napp.$on(event, callback);\napp.$destroy();\n```\n\nRender on server with `App.render({ answer: 42 })`.","## Reactive Variables\nAssignment-based reactivity; mutations require reassignment. `$:` statements are reactive and topologically ordered.\n\n## Props & Events\nDeclare with `export let`. Handle events with `on:` directive and modifiers. Dispatch with `createEventDispatcher()`.\n\n## Slots\nUse `\u003Cslot>` and `slot=\"name\"` for named slots. Check slots with `$$slots`. Fragment element for wrapper-free slot content.\n\n## Dynamic Components & API\n`\u003Csvelte:component this={Component} />` for dynamic rendering. Imperative API: `new App()`, `$set()`, `$on()`, `$destroy()`.","Svelte 3/4 reactive patterns and APIs using assignments, reactive statements, props, event dispatching, and imperative component instantiation."],"uses":{"params":["name","path"]}}]}
