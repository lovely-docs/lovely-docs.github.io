{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","Runtime APIs/lifecycle-hooks",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","06-runtime/03-lifecycle-hooks.md",true,{"fulltext":8,"digest":9,"short_digest":10},3645,781,203,{"input":12,"output":13,"details":14},4684,1111,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: Lifecycle hooks\n---\n\n\u003C!-- - onMount/onDestroy\n- mention that `$effect` might be better for your use case\n- beforeUpdate/afterUpdate with deprecation notice?\n- or skip this entirely and only have it in the reference docs? -->\n\nIn Svelte 5, the component lifecycle consists of only two parts: Its creation and its destruction. Everything in-between — when certain state is updated — is not related to the component as a whole; only the parts that need to react to the state change are notified. This is because under the hood the smallest unit of change is actually not a component, it's the (render) effects that the component sets up upon component initialization. Consequently, there's no such thing as a \"before update\"/\"after update\" hook.\n\n## `onMount`\n\nThe `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM. It must be called during the component's initialisation (but doesn't need to live _inside_ the component; it can be called from an external module).\n\n`onMount` does not run inside a component that is rendered on the server.\n\n```svelte\n\u003Cscript>\n\timport { onMount } from 'svelte';\n\n\tonMount(() => {\n\t\tconsole.log('the component has mounted');\n\t});\n\u003C/script>\n```\n\nIf a function is returned from `onMount`, it will be called when the component is unmounted.\n\n```svelte\n\u003Cscript>\n\timport { onMount } from 'svelte';\n\n\tonMount(() => {\n\t\tconst interval = setInterval(() => {\n\t\t\tconsole.log('beep');\n\t\t}, 1000);\n\n\t\treturn () => clearInterval(interval);\n\t});\n\u003C/script>\n```\n\n> [!NOTE] This behaviour will only work when the function passed to `onMount` _synchronously_ returns a value. `async` functions always return a `Promise`, and as such cannot _synchronously_ return a function.\n\n## `onDestroy`\n\nSchedules a callback to run immediately before the component is unmounted.\n\nOut of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the only one that runs inside a server-side component.\n\n```svelte\n\u003Cscript>\n\timport { onDestroy } from 'svelte';\n\n\tonDestroy(() => {\n\t\tconsole.log('the component is being destroyed');\n\t});\n\u003C/script>\n```\n\n## `tick`\n\nWhile there's no \"after update\" hook, you can use `tick` to ensure that the UI is updated before continuing. `tick` returns a promise that resolves once any pending state changes have been applied, or in the next microtask if there are none.\n\n```svelte\n\u003Cscript>\n\timport { tick } from 'svelte';\n\n\t$effect.pre(() => {\n\t\tconsole.log('the component is about to update');\n\t\ttick().then(() => {\n\t\t\t\tconsole.log('the component just updated');\n\t\t});\n\t});\n\u003C/script>\n```\n\n## Deprecated: `beforeUpdate` / `afterUpdate`\n\nSvelte 4 contained hooks that ran before and after the component as a whole was updated. For backwards compatibility, these hooks were shimmed in Svelte 5 but not available inside components that use runes.\n\n```svelte\n\u003Cscript>\n\timport { beforeUpdate, afterUpdate } from 'svelte';\n\n\tbeforeUpdate(() => {\n\t\tconsole.log('the component is about to update');\n\t});\n\n\tafterUpdate(() => {\n\t\tconsole.log('the component just updated');\n\t});\n\u003C/script>\n```\n\nInstead of `beforeUpdate` use `$effect.pre` and instead of `afterUpdate` use `$effect` instead - these runes offer more granular control and only react to the changes you're actually interested in.\n\n### Chat window example\n\nTo implement a chat window that autoscrolls to the bottom when new messages appear (but only if you were _already_ scrolled to the bottom), we need to measure the DOM before we update it.\n\nIn Svelte 4, we do this with `beforeUpdate`, but this is a flawed approach — it fires before _every_ update, whether it's relevant or not. In the example below, we need to introduce checks like `updatingMessages` to make sure we don't mess with the scroll position when someone toggles dark mode.\n\nWith runes, we can use `$effect.pre`, which behaves the same as `$effect` but runs before the DOM is updated. As long as we explicitly reference `messages` inside the effect body, it will run whenever `messages` changes, but _not_ when `theme` changes.\n\n`beforeUpdate`, and its equally troublesome counterpart `afterUpdate`, are therefore deprecated in Svelte 5.\n\n- [Before](/playground/untitled#H4sIAAAAAAAAE31WXa_bNgz9K6yL1QmWOLlrC-w6H8MeBgwY9tY9NfdBtmlbiywZkpyPBfnvo2zLcZK28AWuRPGI5OGhkEuQc4EmiL9eAskqDOLg97oOZoE9125jDigs0t6oRqfOsjap5rXd7uTO8qpW2sIFEsyVxn_qjFmcAcstar-xPN3DFXKtKgi768IVgQku0ELj3Lgs_kZjWIEGNpAzYXDlHWyJFZI1zJjeh4O5uvl_DY8oUkVeVoFuJKYls-_CGYS25Aboj0EtWNqel0wWoBoLTGZgmdgDS9zW4Uz4NsrswPHoyutN4xInkylstnBxdmIhh8m7xzqmoNE2Wq46n1RJQzEbq4g-JQSl7e-HDx-GdaTy3KD9E3lRWvj5Zu9QX1QN20dj7zyHz8s-1S6lW7Cpz3RnXTcm04hIlfdFuO8p2mQ5-3a06cqjrn559bF_2NHOnRZ5I1PLlXQNyQT-hedMHeUEDyjtdMxsa4n2eIbNhlTwhyRthaOKOmYtniwF6pwt0wXa6MBEg0OibZec27gz_dk3UrZ6hB2LLYoiv521Yd8Gt-foTrfhiCDP0lC9VUUhcDLU49Xe_9943cNvEArHfAjxeBTovvXiNpFynfEDpIIZs9kFbg52QbeNHWZzebz32s7xHco3nJAJl1nshmhz8dYOQJDyZetnbb2gTWe-vEeWlrfpZMavr56ldb29eNt6UXvgwgFbp_WC0tl2RK25rGk6lYz3nUI2lzvBXGHhPZPGWmKUXFNBKqdaW259wl_aHbiqoVIZdpE60Nax6IOujT0LbFFxIVTCxCRR2XloUcYNvSbnGHKBp763jHoj59xiZWJI0Wm0P_m3MSS985xkasn-cFq20xTDy3J5KFcjgUTD69BHdcHIjz431z28IqlxGcPSfdFnrGDZn6gD6lyo45zyHAD-btczf-98nhQxHEvKfeUtOVkSejD3q-9X7JbzjGtsdUxlKdFU8qGsT78uaw848syWMXz85Waq2Gnem4mAn3prweq4q6Y3JEpnqMmnPoFRgmd3ySW0LLRqSKlwYHriCvJvUs2yjMaaoA-XzTXLeGMe45zmhv_XAno3Mj0xF7USuqNvnE9H343QHlq-eAgxpbTPNR9yzUkgLjwSR0NK4wKoxy-jDg-9vy8sUSToakzW-9fX13Em9Q8T6Z26uZhBN36XUYo5q7ggLXBZoub2Ofv7g6GCZfTxe034NCjiudXj7Omla0eTfo7QBPOcYxbE7qG-vl3_B1G-_i_JCAAA)\n- [After](/playground/untitled#H4sIAAAAAAAAE31WXa-jNhD9K7PsdknUQJLurtRLPqo-VKrU1327uQ8GBnBjbGSb5KZR_nvHgMlXtyIS9njO-MyZGZRzUHCBJkhez4FkNQZJ8HvTBLPAnhq3MQcUFmlvVKszZ1mbTPPGbndyZ3ndKG3hDJZne7hAoVUNYY8JV-RBPgIt2AprhA18MpZZnIQ50_twuvLHNRrDSjRXj9fwiCJTBLIKdCsxq5j9EM4gtBU3QD8GjWBZd14xWYJqLTCZg2ViDyx1W4cz4dv0hsiB49FRHkyfsCgws3GjcTKZwmYLZ2feWc9o1W8zJQ2Fb62i5JUQRNRHgs-fx3WsisKg_RN5WVn4-WrvUd9VA9tH4-AcwbfFQIpkLWByvWzqSe2sk3kyjUlOec_XPU-3TRaz_75tuvKoi19e3OvipSpamVmupJM2F_gXnnJ1lBM8oLQjHceys8R7PMFms4HwD2lRhzeEe-EsvluSrHe2TJdo4wMTLY48XKwPzm0KGm2r5ajFtRYU4TWOY7-ddWHfxhDP0QkQhnf5PWRnVVkKnIx8fZsOb5dR16nwG4TCCRdCMphWQ7z1_DoOcp3zA2SCGbPZBa5jd0G_TRxmc36Me-mG6A7l60XIlMs8ce2-OXtrDyBItdz6qVjPadObzx-RZdV1nJjx64tXad1sz962njceOHfAzmk9JzrbXqg1lw3NkZL7vgE257t-uMDcO6attSSokpmgFqVMO2U93e_dDlzOUKsc-3t6zNZp6K9cG3sS2KGSUqiUiUmq8tNYoJwbmvpTAoXA96GyjCojI26xNglk6DpwOPm7NdRYp4ia0JL94bTqRiGB5WJxqFY37RGPoz3c6i4jP3rcUA7wmhqNywQW7om_YQ2L4UQdUBdCHSPiOQJ8bFcxHzeK0jKBY0XcV95SkCWlD9t-9eOM3TLKucauiyktJdpaPqT19ddF4wFHntsqgS-_XE01e48GMwnw02AtWZP02QyGVOkcNfk072CU4PkduZSWpVYt9SkcmJ64hPwHpWF5ziVls3wIFmmW89Y83vMeGf5PBxjcyPSkXNy10J18t3x6-a6CDtBq6SGklNKeazFyLahB3PVIGo2UbhOgGi9vKjzW_j6xVFFD17difXx5ebll0vwvkcGpn4sZ9MN3vqFYsJoL6gUuK9TcPrO_PxgzWMRfflSEr2NHPJf6lj1957rRpH8CNMG84JgHidUtXt4u_wK21LXERAgAAA==)\n\n\u003C!-- prettier-ignore -->\n```svelte\n\u003Cscript>\n\timport { ---beforeUpdate, afterUpdate,--- tick } from 'svelte';\n\n\t---let updatingMessages = false;---\n\tlet theme = +++$state('dark')+++;\n\tlet messages = +++$state([])+++;\n\n\tlet viewport;\n\n\t---beforeUpdate(() => {---\n\t+++$effect.pre(() => {+++\n\t\t---if (!updatingMessages) return;---\n\t\t+++messages;+++\n\t\tconst autoscroll = viewport && viewport.offsetHeight + viewport.scrollTop > viewport.scrollHeight - 50;\n\n\t\tif (autoscroll) {\n\t\t\ttick().then(() => {\n\t\t\t\tviewport.scrollTo(0, viewport.scrollHeight);\n\t\t\t});\n\t\t}\n\n\t\t---updatingMessages = false;---\n\t});\n\n\tfunction handleKeydown(event) {\n\t\tif (event.key === 'Enter') {\n\t\t\tconst text = event.target.value;\n\t\t\tif (!text) return;\n\n\t\t\t---updatingMessages = true;---\n\t\t\tmessages = [...messages, text];\n\t\t\tevent.target.value = '';\n\t\t}\n\t}\n\n\tfunction toggle() {\n\t\ttheme = theme === 'dark' ? 'light' : 'dark';\n\t}\n\u003C/script>\n\n\u003Cdiv class:dark={theme === 'dark'}>\n\t\u003Cdiv bind:this={viewport}>\n\t\t{#each messages as message}\n\t\t\t\u003Cp>{message}\u003C/p>\n\t\t{/each}\n\t\u003C/div>\n\n\t\u003Cinput +++onkeydown+++={handleKeydown} />\n\n\t\u003Cbutton +++onclick+++={toggle}> Toggle dark mode \u003C/button>\n\u003C/div>\n```\n","## onMount\n\nSchedules a callback to run when the component mounts to the DOM. Must be called during component initialization. Does not run on server-side rendered components.\n\nIf a function is returned from `onMount`, it will be called when the component unmounts. Note: this only works with synchronous returns; async functions always return a Promise.\n\n```svelte\n\u003Cscript>\n\timport { onMount } from 'svelte';\n\n\tonMount(() => {\n\t\tconst interval = setInterval(() => console.log('beep'), 1000);\n\t\treturn () => clearInterval(interval);\n\t});\n\u003C/script>\n```\n\n## onDestroy\n\nSchedules a callback to run immediately before the component unmounts. This is the only lifecycle hook that runs in server-side rendered components.\n\n```svelte\n\u003Cscript>\n\timport { onDestroy } from 'svelte';\n\n\tonDestroy(() => {\n\t\tconsole.log('the component is being destroyed');\n\t});\n\u003C/script>\n```\n\n## tick\n\nReturns a promise that resolves once pending state changes have been applied, or in the next microtask if there are none. Use this when you need to ensure the UI is updated before continuing.\n\n```svelte\n\u003Cscript>\n\timport { tick } from 'svelte';\n\n\t$effect.pre(() => {\n\t\tconsole.log('about to update');\n\t\ttick().then(() => console.log('just updated'));\n\t});\n\u003C/script>\n```\n\n## Deprecated: beforeUpdate / afterUpdate\n\nSvelte 4 had hooks that ran before/after component updates. These are shimmed in Svelte 5 for backwards compatibility but not available in components using runes.\n\nUse `$effect.pre` instead of `beforeUpdate` and `$effect` instead of `afterUpdate`. These runes offer more granular control and only react to changes you explicitly reference.\n\nExample: autoscrolling chat window that only scrolls when messages change, not when theme changes:\n\n```svelte\n\u003Cscript>\n\timport { tick } from 'svelte';\n\n\tlet theme = $state('dark');\n\tlet messages = $state([]);\n\tlet viewport;\n\n\t$effect.pre(() => {\n\t\tmessages;\n\t\tconst autoscroll = viewport && viewport.offsetHeight + viewport.scrollTop > viewport.scrollHeight - 50;\n\t\tif (autoscroll) {\n\t\t\ttick().then(() => viewport.scrollTo(0, viewport.scrollHeight));\n\t\t}\n\t});\n\n\tfunction handleKeydown(event) {\n\t\tif (event.key === 'Enter') {\n\t\t\tmessages = [...messages, event.target.value];\n\t\t\tevent.target.value = '';\n\t\t}\n\t}\n\n\tfunction toggle() {\n\t\ttheme = theme === 'dark' ? 'light' : 'dark';\n\t}\n\u003C/script>\n\n\u003Cdiv class:dark={theme === 'dark'}>\n\t\u003Cdiv bind:this={viewport}>\n\t\t{#each messages as message}\n\t\t\t\u003Cp>{message}\u003C/p>\n\t\t{/each}\n\t\u003C/div>\n\t\u003Cinput onkeydown={handleKeydown} />\n\t\u003Cbutton onclick={toggle}>Toggle dark mode\u003C/button>\n\u003C/div>\n```\n\nIn Svelte 5, the component lifecycle consists only of creation and destruction. State updates don't trigger component-level hooks; instead, effects react to specific state changes.","## onMount\nRuns when component mounts to DOM. Can return cleanup function (must be synchronous). Doesn't run on server.\n\n## onDestroy\nRuns before component unmounts. Only lifecycle hook that runs on server.\n\n## tick\nReturns promise that resolves after pending state changes apply. Use to ensure UI updates before continuing.\n\n## Deprecated: beforeUpdate / afterUpdate\nUse `$effect.pre` and `$effect` instead. These runes offer granular control—only react to explicitly referenced state.\n\nExample: autoscroll chat only when messages change:\n```svelte\n$effect.pre(() => {\n\tmessages;\n\tconst autoscroll = viewport?.offsetHeight + viewport?.scrollTop > viewport?.scrollHeight - 50;\n\tif (autoscroll) tick().then(() => viewport.scrollTo(0, viewport.scrollHeight));\n});\n```","Svelte 5 lifecycle consists of onMount and onDestroy hooks; use $effect runes instead of deprecated beforeUpdate/afterUpdate for granular state-change reactions."],"uses":{"params":["name","path"]}}]}
