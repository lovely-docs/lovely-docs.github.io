{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-sveltekit","core-concepts/loading-data",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","20-core-concepts/20-load.md",true,{"fulltext":8,"digest":9,"short_digest":10},9097,1844,331,{"input":12,"output":13,"details":14},10140,2292,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: Loading data\n---\n\nBefore a [`+page.svelte`](routing#page-page.svelte) component (and its containing [`+layout.svelte`](routing#layout-layout.svelte) components) can be rendered, we often need to get some data. This is done by defining `load` functions.\n\n## Page data\n\nA `+page.svelte` file can have a sibling `+page.js` that exports a `load` function, the return value of which is available to the page via the `data` prop:\n\n```js\n/// file: src/routes/blog/[slug]/+page.js\n/** @type {import('./$types').PageLoad} */\nexport function load({ params }) {\n\treturn {\n\t\tpost: {\n\t\t\ttitle: `Title for ${params.slug} goes here`,\n\t\t\tcontent: `Content for ${params.slug} goes here`\n\t\t}\n\t};\n}\n```\n\n```svelte\n\u003C!--- file: src/routes/blog/[slug]/+page.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\u003C/script>\n\n\u003Ch1>{data.post.title}\u003C/h1>\n\u003Cdiv>{@html data.post.content}\u003C/div>\n```\n\n> [!LEGACY]\n> Before version 2.16.0, the props of a page and layout had to be typed individually:\n> ```js\n> /// file: +page.svelte\n> /** @type {{ data: import('./$types').PageData }} */\n> let { data } = $props();\n> ```\n>\n> In Svelte 4, you'd use `export let data` instead.\n\nThanks to the generated `$types` module, we get full type safety.\n\nA `load` function in a `+page.js` file runs both on the server and in the browser (unless combined with `export const ssr = false`, in which case it will [only run in the browser](page-options#ssr)). If your `load` function should _always_ run on the server (because it uses private environment variables, for example, or accesses a database) then it would go in a `+page.server.js` instead.\n\nA more realistic version of your blog post's `load` function, that only runs on the server and pulls data from a database, might look like this:\n\n```js\n/// file: src/routes/blog/[slug]/+page.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function getPost(slug: string): Promise\u003C{ title: string, content: string }>\n}\n\n// @filename: index.js\n// ---cut---\nimport * as db from '$lib/server/database';\n\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\treturn {\n\t\tpost: await db.getPost(params.slug)\n\t};\n}\n```\n\nNotice that the type changed from `PageLoad` to `PageServerLoad`, because server `load` functions can access additional arguments. To understand when to use `+page.js` and when to use `+page.server.js`, see [Universal vs server](load#Universal-vs-server).\n\n## Layout data\n\nYour `+layout.svelte` files can also load data, via `+layout.js` or `+layout.server.js`.\n\n```js\n/// file: src/routes/blog/[slug]/+layout.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function getPostSummaries(): Promise\u003CArray\u003C{ title: string, slug: string }>>\n}\n\n// @filename: index.js\n// ---cut---\nimport * as db from '$lib/server/database';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport async function load() {\n\treturn {\n\t\tposts: await db.getPostSummaries()\n\t};\n}\n```\n\n```svelte\n\u003C!--- file: src/routes/blog/[slug]/+layout.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').LayoutProps} */\n\tlet { data, children } = $props();\n\u003C/script>\n\n\u003Cmain>\n\t\u003C!-- +page.svelte is `@render`ed here -->\n\t{@render children()}\n\u003C/main>\n\n\u003Caside>\n\t\u003Ch2>More posts\u003C/h2>\n\t\u003Cul>\n\t\t{#each data.posts as post}\n\t\t\t\u003Cli>\n\t\t\t\t\u003Ca href=\"/blog/{post.slug}\">\n\t\t\t\t\t{post.title}\n\t\t\t\t\u003C/a>\n\t\t\t\u003C/li>\n\t\t{/each}\n\t\u003C/ul>\n\u003C/aside>\n```\n\n> [!LEGACY]\n> `LayoutProps` was added in 2.16.0. In earlier versions, properties had to be typed individually:\n> ```js\n> /// file: +layout.svelte\n> /** @type {{ data: import('./$types').LayoutData, children: Snippet }} */\n> let { data, children } = $props();\n> ```\n\nData returned from layout `load` functions is available to child `+layout.svelte` components and the `+page.svelte` component as well as the layout that it 'belongs' to.\n\n```svelte\n/// file: src/routes/blog/[slug]/+page.svelte\n\u003Cscript>\n\t+++import { page } from '$app/state';+++\n\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\n+++\t// we can access `data.posts` because it's returned from\n\t// the parent layout `load` function\n\tlet index = $derived(data.posts.findIndex(post => post.slug === page.params.slug));\n\tlet next = $derived(data.posts[index + 1]);+++\n\u003C/script>\n\n\u003Ch1>{data.post.title}\u003C/h1>\n\u003Cdiv>{@html data.post.content}\u003C/div>\n\n+++{#if next}\n\t\u003Cp>Next post: \u003Ca href=\"/blog/{next.slug}\">{next.title}\u003C/a>\u003C/p>\n{/if}+++\n```\n\n> [!NOTE] If multiple `load` functions return data with the same key, the last one 'wins' — the result of a layout `load` returning `{ a: 1, b: 2 }` and a page `load` returning `{ b: 3, c: 4 }` would be `{ a: 1, b: 3, c: 4 }`.\n\n## page.data\n\nThe `+page.svelte` component, and each `+layout.svelte` component above it, has access to its own data plus all the data from its parents.\n\nIn some cases, we might need the opposite — a parent layout might need to access page data or data from a child layout. For example, the root layout might want to access a `title` property returned from a `load` function in `+page.js` or `+page.server.js`. This can be done with `page.data`:\n\n```svelte\n\u003C!--- file: src/routes/+layout.svelte --->\n\u003Cscript>\n\timport { page } from '$app/state';\n\u003C/script>\n\n\u003Csvelte:head>\n\t\u003Ctitle>{page.data.title}\u003C/title>\n\u003C/svelte:head>\n```\n\nType information for `page.data` is provided by `App.PageData`.\n\n> [!LEGACY]\n> `$app/state` was added in SvelteKit 2.12. If you're using an earlier version or are using Svelte 4, use `$app/stores` instead.\n> It provides a `page` store with the same interface that you can subscribe to, e.g. `$page.data.title`.\n\n## Universal vs server\n\nAs we've seen, there are two types of `load` function:\n\n* `+page.js` and `+layout.js` files export _universal_ `load` functions that run both on the server and in the browser\n* `+page.server.js` and `+layout.server.js` files export _server_ `load` functions that only run server-side\n\nConceptually, they're the same thing, but there are some important differences to be aware of.\n\n### When does which load function run?\n\nServer `load` functions _always_ run on the server.\n\nBy default, universal `load` functions run on the server during SSR when the user first visits your page. They will then run again during hydration, reusing any responses from [fetch requests](#Making-fetch-requests). All subsequent invocations of universal `load` functions happen in the browser. You can customize the behavior through [page options](page-options). If you disable [server-side rendering](page-options#ssr), you'll get an SPA and universal `load` functions _always_ run on the client.\n\nIf a route contains both universal and server `load` functions, the server `load` runs first.\n\nA `load` function is invoked at runtime, unless you [prerender](page-options#prerender) the page — in that case, it's invoked at build time.\n\n### Input\n\nBoth universal and server `load` functions have access to properties describing the request (`params`, `route` and `url`) and various functions (`fetch`, `setHeaders`, `parent`, `depends` and `untrack`). These are described in the following sections.\n\nServer `load` functions are called with a `ServerLoadEvent`, which inherits `clientAddress`, `cookies`, `locals`, `platform` and `request` from `RequestEvent`.\n\nUniversal `load` functions are called with a `LoadEvent`, which has a `data` property. If you have `load` functions in both `+page.js` and `+page.server.js` (or `+layout.js` and `+layout.server.js`), the return value of the server `load` function is the `data` property of the universal `load` function's argument.\n\n### Output\n\nA universal `load` function can return an object containing any values, including things like custom classes and component constructors.\n\nA server `load` function must return data that can be serialized with [devalue](https://github.com/rich-harris/devalue) — anything that can be represented as JSON plus things like `BigInt`, `Date`, `Map`, `Set` and `RegExp`, or repeated/cyclical references — so that it can be transported over the network. Your data can include [promises](#Streaming-with-promises), in which case it will be streamed to browsers. If you need to serialize/deserialize custom types, use [transport hooks](hooks#Universal-hooks-transport).\n\n### When to use which\n\nServer `load` functions are convenient when you need to access data directly from a database or filesystem, or need to use private environment variables.\n\nUniversal `load` functions are useful when you need to `fetch` data from an external API and don't need private credentials, since SvelteKit can get the data directly from the API rather than going via your server. They are also useful when you need to return something that can't be serialized, such as a Svelte component constructor.\n\nIn rare cases, you might need to use both together — for example, you might need to return an instance of a custom class that was initialised with data from your server. When using both, the server `load` return value is _not_ passed directly to the page, but to the universal `load` function (as the `data` property):\n\n```js\n/// file: src/routes/+page.server.js\n/** @type {import('./$types').PageServerLoad} */\nexport async function load() {\n\treturn {\n\t\tserverMessage: 'hello from server load function'\n\t};\n}\n```\n\n```js\n/// file: src/routes/+page.js\n// @errors: 18047\n/** @type {import('./$types').PageLoad} */\nexport async function load({ data }) {\n\treturn {\n\t\tserverMessage: data.serverMessage,\n\t\tuniversalMessage: 'hello from universal load function'\n\t};\n}\n```\n\n## Using URL data\n\nOften the `load` function depends on the URL in one way or another. For this, the `load` function provides you with `url`, `route` and `params`.\n\n### url\n\nAn instance of [`URL`](https://developer.mozilla.org/en-US/docs/Web/API/URL), containing properties like the `origin`, `hostname`, `pathname` and `searchParams` (which contains the parsed query string as a [`URLSearchParams`](https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams) object). `url.hash` cannot be accessed during `load`, since it is unavailable on the server.\n\n> [!NOTE] In some environments this is derived from request headers during server-side rendering. If you're using [adapter-node](adapter-node), for example, you may need to configure the adapter in order for the URL to be correct.\n\n### route\n\nContains the name of the current route directory, relative to `src/routes`:\n\n```js\n/// file: src/routes/a/[b]/[...c]/+page.js\n/** @type {import('./$types').PageLoad} */\nexport function load({ route }) {\n\tconsole.log(route.id); // '/a/[b]/[...c]'\n}\n```\n\n### params\n\n`params` is derived from `url.pathname` and `route.id`.\n\nGiven a `route.id` of `/a/[b]/[...c]` and a `url.pathname` of `/a/x/y/z`, the `params` object would look like this:\n\n```json\n{\n\t\"b\": \"x\",\n\t\"c\": \"y/z\"\n}\n```\n\n## Making fetch requests\n\nTo get data from an external API or a `+server.js` handler, you can use the provided `fetch` function, which behaves identically to the [native `fetch` web API](https://developer.mozilla.org/en-US/docs/Web/API/fetch) with a few additional features:\n\n- It can be used to make credentialed requests on the server, as it inherits the `cookie` and `authorization` headers for the page request.\n- It can make relative requests on the server (ordinarily, `fetch` requires a URL with an origin when used in a server context).\n- Internal requests (e.g. for `+server.js` routes) go directly to the handler function when running on the server, without the overhead of an HTTP call.\n- During server-side rendering, the response will be captured and inlined into the rendered HTML by hooking into the `text`, `json` and `arrayBuffer` methods of the `Response` object. Note that headers will _not_ be serialized, unless explicitly included via [`filterSerializedResponseHeaders`](hooks#Server-hooks-handle).\n- During hydration, the response will be read from the HTML, guaranteeing consistency and preventing an additional network request - if you received a warning in your browser console when using the browser `fetch` instead of the `load` `fetch`, this is why.\n\n```js\n/// file: src/routes/items/[id]/+page.js\n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\tconst item = await res.json();\n\n\treturn { item };\n}\n```\n\n## Cookies\n\nA server `load` function can get and set [`cookies`](@sveltejs-kit#Cookies).\n\n```js\n/// file: src/routes/+layout.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function getUser(sessionid: string | undefined): Promise\u003C{ name: string, avatar: string }>\n}\n\n// @filename: index.js\n// ---cut---\nimport * as db from '$lib/server/database';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\n\treturn {\n\t\tuser: await db.getUser(sessionid)\n\t};\n}\n```\n\nCookies will only be passed through the provided `fetch` function if the target host is the same as the SvelteKit application or a more specific subdomain of it.\n\nFor example, if SvelteKit is serving my.domain.com:\n- domain.com WILL NOT receive cookies\n- my.domain.com WILL receive cookies\n- api.domain.com WILL NOT receive cookies\n- sub.my.domain.com WILL receive cookies\n\nOther cookies will not be passed when `credentials: 'include'` is set, because SvelteKit does not know which domain which cookie belongs to (the browser does not pass this information along), so it's not safe to forward any of them. Use the [handleFetch hook](hooks#Server-hooks-handleFetch) to work around it.\n\n## Headers\n\nBoth server and universal `load` functions have access to a `setHeaders` function that, when running on the server, can set headers for the response. (When running in the browser, `setHeaders` has no effect.) This is useful if you want the page to be cached, for example:\n\n```js\n// @errors: 2322 1360\n/// file: src/routes/products/+page.js\n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch, setHeaders }) {\n\tconst url = `https://cms.example.com/products.json`;\n\tconst response = await fetch(url);\n\n\t// Headers are only set during SSR, caching the page's HTML\n\t// for the same length of time as the underlying data.\n\tsetHeaders({\n\t\tage: response.headers.get('age'),\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\n\treturn response.json();\n}\n```\n\nSetting the same header multiple times (even in separate `load` functions) is an error. You can only set a given header once using the `setHeaders` function. You cannot add a `set-cookie` header with `setHeaders` — use `cookies.set(name, value, options)` instead.\n\n## Using parent data\n\nOccasionally it's useful for a `load` function to access data from a parent `load` function, which can be done with `await parent()`:\n\n```js\n/// file: src/routes/+layout.js\n/** @type {import('./$types').LayoutLoad} */\nexport function load() {\n\treturn { a: 1 };\n}\n```\n\n```js\n/// file: src/routes/abc/+layout.js\n/** @type {import('./$types').LayoutLoad} */\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { b: a + 1 };\n}\n```\n\n```js\n/// file: src/routes/abc/+page.js\n/** @type {import('./$types').PageLoad} */\nexport async function load({ parent }) {\n\tconst { a, b } = await parent();\n\treturn { c: a + b };\n}\n```\n\n```svelte\n\u003C!--- file: src/routes/abc/+page.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\u003C/script>\n\n\u003C!-- renders `1 + 2 = 3` -->\n\u003Cp>{data.a} + {data.b} = {data.c}\u003C/p>\n```\n\n> [!NOTE] Notice that the `load` function in `+page.js` receives the merged data from both layout `load` functions, not just the immediate parent.\n\nInside `+page.server.js` and `+layout.server.js`, `parent` returns data from parent `+layout.server.js` files.\n\nIn `+page.js` or `+layout.js` it will return data from parent `+layout.js` files. However, a missing `+layout.js` is treated as a `({ data }) => data` function, meaning that it will also return data from parent `+layout.server.js` files that are not 'shadowed' by a `+layout.js` file\n\nTake care not to introduce waterfalls when using `await parent()`. Here, for example, `getData(params)` does not depend on the result of calling `parent()`, so we should call it first to avoid a delayed render.\n\n```js\n/// file: +page.js\n// @filename: ambient.d.ts\ndeclare function getData(params: Record\u003Cstring, string>): Promise\u003C{ meta: any }>\n\n// @filename: index.js\n// ---cut---\n/** @type {import('./$types').PageLoad} */\nexport async function load({ params, parent }) {\n\t---const parentData = await parent();---\n\tconst data = await getData(params);\n\t+++const parentData = await parent();+++\n\n\treturn {\n\t\t...data,\n\t\tmeta: { ...parentData.meta, ...data.meta }\n\t};\n}\n```\n\n## Errors\n\nIf an error is thrown during `load`, the nearest [`+error.svelte`](routing#error) will be rendered. For [_expected_](errors#Expected-errors) errors, use the `error` helper from `@sveltejs/kit` to specify the HTTP status code and an optional message:\n\n```js\n/// file: src/routes/admin/+layout.server.js\n// @filename: ambient.d.ts\ndeclare namespace App {\n\tinterface Locals {\n\t\tuser?: {\n\t\t\tname: string;\n\t\t\tisAdmin: boolean;\n\t\t}\n\t}\n}\n\n// @filename: index.js\n// ---cut---\nimport { error } from '@sveltejs/kit';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n\n\tif (!locals.user.isAdmin) {\n\t\terror(403, 'not an admin');\n\t}\n}\n```\n\nCalling `error(...)` will throw an exception, making it easy to stop execution from inside helper functions.\n\nIf an [_unexpected_](errors#Unexpected-errors) error is thrown, SvelteKit will invoke [`handleError`](hooks#Shared-hooks-handleError) and treat it as a 500 Internal Error.\n\n> [!NOTE] [In SvelteKit 1.x](migrating-to-sveltekit-2#redirect-and-error-are-no-longer-thrown-by-you) you had to `throw` the error yourself\n\n## Redirects\n\nTo redirect users, use the `redirect` helper from `@sveltejs/kit` to specify the location to which they should be redirected alongside a `3xx` status code. Like `error(...)`, calling `redirect(...)` will throw an exception, making it easy to stop execution from inside helper functions.\n\n```js\n/// file: src/routes/user/+layout.server.js\n// @filename: ambient.d.ts\ndeclare namespace App {\n\tinterface Locals {\n\t\tuser?: {\n\t\t\tname: string;\n\t\t}\n\t}\n}\n\n// @filename: index.js\n// ---cut---\nimport { redirect } from '@sveltejs/kit';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\n> [!NOTE] Don't use `redirect()` inside a `try {...}` block, as the redirect will immediately trigger the catch statement.\n\nIn the browser, you can also navigate programmatically outside of a `load` function using [`goto`]($app-navigation#goto) from [`$app.navigation`]($app-navigation).\n\n> [!NOTE] [In SvelteKit 1.x](migrating-to-sveltekit-2#redirect-and-error-are-no-longer-thrown-by-you) you had to `throw` the `redirect` yourself\n\n## Streaming with promises\n\nWhen using a server `load`, promises will be streamed to the browser as they resolve. This is useful if you have slow, non-essential data, since you can start rendering the page before all the data is available:\n\n```js\n/// file: src/routes/blog/[slug]/+page.server.js\n// @filename: ambient.d.ts\ndeclare global {\n\tconst loadPost: (slug: string) => Promise\u003C{ title: string, content: string }>;\n\tconst loadComments: (slug: string) => Promise\u003C{ content: string }>;\n}\n\nexport {};\n\n// @filename: index.js\n// ---cut---\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\treturn {\n\t\t// make sure the `await` happens at the end, otherwise we\n\t\t// can't start loading comments until we've loaded the post\n\t\tcomments: loadComments(params.slug),\n\t\tpost: await loadPost(params.slug)\n\t};\n}\n```\n\nThis is useful for creating skeleton loading states, for example:\n\n```svelte\n\u003C!--- file: src/routes/blog/[slug]/+page.svelte --->\n\u003Cscript>\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\u003C/script>\n\n\u003Ch1>{data.post.title}\u003C/h1>\n\u003Cdiv>{@html data.post.content}\u003C/div>\n\n{#await data.comments}\n\tLoading comments...\n{:then comments}\n\t{#each comments as comment}\n\t\t\u003Cp>{comment.content}\u003C/p>\n\t{/each}\n{:catch error}\n\t\u003Cp>error loading comments: {error.message}\u003C/p>\n{/await}\n```\n\nWhen streaming data, be careful to handle promise rejections correctly. More specifically, the server could crash with an \"unhandled promise rejection\" error if a lazy-loaded promise fails before rendering starts (at which point it's caught) and isn't handling the error in some way. When using SvelteKit's `fetch` directly in the `load` function, SvelteKit will handle this case for you. For other promises, it is enough to attach a noop-`catch` to the promise to mark it as handled.\n\n```js\n/// file: src/routes/+page.server.js\n/** @type {import('./$types').PageServerLoad} */\nexport function load({ fetch }) {\n\tconst ok_manual = Promise.reject();\n\tok_manual.catch(() => {});\n\n\treturn {\n\t\tok_manual,\n\t\tok_fetch: fetch('/fetch/that/could/fail'),\n\t\tdangerous_unhandled: Promise.reject()\n\t};\n}\n```\n\n> [!NOTE] On platforms that do not support streaming, such as AWS Lambda or Firebase, responses will be buffered. This means the page will only render once all promises resolve. If you are using a proxy (e.g. NGINX), make sure it does not buffer responses from the proxied server.\n\n> [!NOTE] Streaming data will only work when JavaScript is enabled. You should avoid returning promises from a universal `load` function if the page is server rendered, as these are _not_ streamed — instead, the promise is recreated when the function reruns in the browser.\n\n> [!NOTE] The headers and status code of a response cannot be changed once the response has started streaming, therefore you cannot `setHeaders` or throw redirects inside a streamed promise.\n\n> [!NOTE] [In SvelteKit 1.x](migrating-to-sveltekit-2#Top-level-promises-are-no-longer-awaited) top-level promises were automatically awaited, only nested promises were streamed.\n\n## Parallel loading\n\nWhen rendering (or navigating to) a page, SvelteKit runs all `load` functions concurrently, avoiding a waterfall of requests. During client-side navigation, the result of calling multiple server `load` functions are grouped into a single response. Once all `load` functions have returned, the page is rendered.\n\n## Rerunning load functions\n\nSvelteKit tracks the dependencies of each `load` function to avoid rerunning it unnecessarily during navigation.\n\nFor example, given a pair of `load` functions like these...\n\n```js\n/// file: src/routes/blog/[slug]/+page.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function getPost(slug: string): Promise\u003C{ title: string, content: string }>\n}\n\n// @filename: index.js\n// ---cut---\nimport * as db from '$lib/server/database';\n\n/** @type {import('./$types').PageServerLoad} */\nexport async function load({ params }) {\n\treturn {\n\t\tpost: await db.getPost(params.slug)\n\t};\n}\n```\n\n```js\n/// file: src/routes/blog/[slug]/+layout.server.js\n// @filename: ambient.d.ts\ndeclare module '$lib/server/database' {\n\texport function getPostSummaries(): Promise\u003CArray\u003C{ title: string, slug: string }>>\n}\n\n// @filename: index.js\n// ---cut---\nimport * as db from '$lib/server/database';\n\n/** @type {import('./$types').LayoutServerLoad} */\nexport async function load() {\n\treturn {\n\t\tposts: await db.getPostSummaries()\n\t};\n}\n```\n\n...the one in `+page.server.js` will rerun if we navigate from `/blog/trying-the-raw-meat-diet` to `/blog/i-regret-my-choices` because `params.slug` has changed. The one in `+layout.server.js` will not, because the data is still valid. In other words, we won't call `db.getPostSummaries()` a second time.\n\nA `load` function that calls `await parent()` will also rerun if a parent `load` function is rerun.\n\nDependency tracking does not apply _after_ the `load` function has returned — for example, accessing `params.x` inside a nested [promise](#Streaming-with-promises) will not cause the function to rerun when `params.x` changes. (Don't worry, you'll get a warning in development if you accidentally do this.) Instead, access the parameter in the main body of your `load` function.\n\nSearch parameters are tracked independently from the rest of the url. For example, accessing `event.url.searchParams.get(\"x\")` inside a `load` function will make that `load` function re-run when navigating from `?x=1` to `?x=2`, but not when navigating from `?x=1&y=1` to `?x=1&y=2`.\n\n### Untracking dependencies\n\nIn rare cases, you may wish to exclude something from the dependency tracking mechanism. You can do this with the provided `untrack` function:\n\n```js\n/// file: src/routes/+page.js\n/** @type {import('./$types').PageLoad} */\nexport async function load({ untrack, url }) {\n\t// Untrack url.pathname so that path changes don't trigger a rerun\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n### Manual invalidation\n\nYou can also rerun `load` functions that apply to the current page using [`invalidate(url)`]($app-navigation#invalidate), which reruns all `load` functions that depend on `url`, and [`invalidateAll()`]($app-navigation#invalidateAll), which reruns every `load` function. Server load functions will never automatically depend on a fetched `url` to avoid leaking secrets to the client.\n\nA `load` function depends on `url` if it calls `fetch(url)` or `depends(url)`. Note that `url` can be a custom identifier that starts with `[a-z]:`:\n\n```js\n/// file: src/routes/random-number/+page.js\n/** @type {import('./$types').PageLoad} */\nexport async function load({ fetch, depends }) {\n\t// load reruns when `invalidate('https://api.example.com/random-number')` is called...\n\tconst response = await fetch('https://api.example.com/random-number');\n\n\t// ...or when `invalidate('app:random')` is called\n\tdepends('app:random');\n\n\treturn {\n\t\tnumber: await response.json()\n\t};\n}\n```\n\n```svelte\n\u003C!--- file: src/routes/random-number/+page.svelte --->\n\u003Cscript>\n\timport { invalidate, invalidateAll } from '$app/navigation';\n\n\t/** @type {import('./$types').PageProps} */\n\tlet { data } = $props();\n\n\tfunction rerunLoadFunction() {\n\t\t// any of these will cause the `load` function to rerun\n\t\tinvalidate('app:random');\n\t\tinvalidate('https://api.example.com/random-number');\n\t\tinvalidate(url => url.href.includes('random-number'));\n\t\tinvalidateAll();\n\t}\n\u003C/script>\n\n\u003Cp>random number: {data.number}\u003C/p>\n\u003Cbutton onclick={rerunLoadFunction}>Update random number\u003C/button>\n```\n\n### When do load functions rerun?\n\nTo summarize, a `load` function will rerun in the following situations:\n\n- It references a property of `params` whose value has changed\n- It references a property of `url` (such as `url.pathname` or `url.search`) whose value has changed. Properties in `request.url` are _not_ tracked\n- It calls `url.searchParams.get(...)`, `url.searchParams.getAll(...)` or `url.searchParams.has(...)` and the parameter in question changes. Accessing other properties of `url.searchParams` will have the same effect as accessing `url.search`.\n- It calls `await parent()` and a parent `load` function reran\n- A child `load` function calls `await parent()` and is rerunning, and the parent is a server load function\n- It declared a dependency on a specific URL via [`fetch`](#Making-fetch-requests) (universal load only) or [`depends`](@sveltejs-kit#LoadEvent), and that URL was marked invalid with [`invalidate(url)`]($app-navigation#invalidate)\n- All active `load` functions were forcibly rerun with [`invalidateAll()`]($app-navigation#invalidateAll)\n\n`params` and `url` can change in response to a `\u003Ca href=\"..\">` link click, a [`\u003Cform>` interaction](form-actions#GET-vs-POST), a [`goto`]($app-navigation#goto) invocation, or a [`redirect`](@sveltejs-kit#redirect).\n\nNote that rerunning a `load` function will update the `data` prop inside the corresponding `+layout.svelte` or `+page.svelte`; it does _not_ cause the component to be recreated. As a result, internal state is preserved. If this isn't what you want, you can reset whatever you need to reset inside an [`afterNavigate`]($app-navigation#afterNavigate) callback, and/or wrap your component in a [`{#key ...}`](../svelte/key) block.\n\n## Implications for authentication\n\nA couple features of loading data have important implications for auth checks:\n- Layout `load` functions do not run on every request, such as during client side navigation between child routes. [(When do load functions rerun?)](load#Rerunning-load-functions-When-do-load-functions-rerun)\n- Layout and page `load` functions run concurrently unless `await parent()` is called. If a layout `load` throws, the page `load` function runs, but the client will not receive the returned data.\n\nThere are a few possible strategies to ensure an auth check occurs before protected code.\n\nTo prevent data waterfalls and preserve layout `load` caches:\n- Use [hooks](hooks) to protect multiple routes before any `load` functions run\n- Use auth guards directly in `+page.server.js` `load` functions for route specific protection\n\nPutting an auth guard in `+layout.server.js` requires all child pages to call `await parent()` before protected code. Unless every child page depends on returned data from `await parent()`, the other options will be more performant.\n\n## Using `getRequestEvent`\n\nWhen running server `load` functions, the `event` object passed to the function as an argument can also be retrieved with [`getRequestEvent`]($app-server#getRequestEvent). This allows shared logic (such as authentication guards) to access information about the current request without it needing to be passed around.\n\nFor example, you might have a function that requires users to be logged in, and redirects them to `/login` if not:\n\n```js\n/// file: src/lib/server/auth.js\n// @filename: ambient.d.ts\ninterface User {\n\tname: string;\n}\n\ndeclare namespace App {\n\tinterface Locals {\n\t\tuser?: User;\n\t}\n}\n\n// @filename: index.ts\n// ---cut---\nimport { redirect } from '@sveltejs/kit';\nimport { getRequestEvent } from '$app/server';\n\nexport function requireLogin() {\n\tconst { locals, url } = getRequestEvent();\n\n\t// assume `locals.user` is populated in `handle`\n\tif (!locals.user) {\n\t\tconst redirectTo = url.pathname + url.search;\n\t\tconst params = new URLSearchParams({ redirectTo });\n\n\t\tredirect(307, `/login?${params}`);\n\t}\n\n\treturn locals.user;\n}\n```\n\nNow, you can call `requireLogin` in any `load` function (or [form action](form-actions), for example) to guarantee that the user is logged in:\n\n```js\n/// file: +page.server.js\n// @filename: ambient.d.ts\n\ndeclare module '$lib/server/auth' {\n\tinterface User {\n\t\tname: string;\n\t}\n\n\texport function requireLogin(): User;\n}\n\n// @filename: index.ts\n// ---cut---\nimport { requireLogin } from '$lib/server/auth';\n\nexport function load() {\n\tconst user = requireLogin();\n\n\t// `user` is guaranteed to be a user object here, because otherwise\n\t// `requireLogin` would throw a redirect and we wouldn't get here\n\treturn {\n\t\tmessage: `hello ${user.name}!`\n\t};\n}\n```\n\n## Further reading\n\n- [Tutorial: Loading data](/tutorial/kit/page-data)\n- [Tutorial: Errors and redirects](/tutorial/kit/error-basics)\n- [Tutorial: Advanced loading](/tutorial/kit/await-parent)\n","## Load Functions\n\nDefine `load` functions in `+page.js`/`+page.server.js` or `+layout.js`/`+layout.server.js` files. Return values are available to components via the `data` prop.\n\n```js\n// +page.js - runs on server and browser\nexport function load({ params }) {\n\treturn { post: { title: `Title for ${params.slug}` } };\n}\n\n// +page.server.js - runs only on server\nimport * as db from '$lib/server/database';\nexport async function load({ params }) {\n\treturn { post: await db.getPost(params.slug) };\n}\n```\n\n```svelte\n\u003Cscript>\n\tlet { data } = $props();\n\u003C/script>\n\u003Ch1>{data.post.title}\u003C/h1>\n```\n\n## Universal vs Server Load\n\n- **Universal** (`+page.js`, `+layout.js`): Run on server during SSR, then in browser. Can return non-serializable data (classes, components). Use for external API calls.\n- **Server** (`+page.server.js`, `+layout.server.js`): Run only on server. Must return serializable data (JSON, BigInt, Date, Map, Set, RegExp). Use for database access and private environment variables.\n\nWhen both exist, server load runs first and its return value becomes the `data` property of the universal load's argument.\n\n## Layout Data\n\nLayout `load` functions return data available to child layouts and pages. Data from multiple `load` functions merges, with later values overwriting earlier ones.\n\n```js\n// +layout.server.js\nexport async function load() {\n\treturn { posts: await db.getPostSummaries() };\n}\n```\n\n```svelte\n\u003C!-- +layout.svelte -->\n\u003Cscript>\n\tlet { data, children } = $props();\n\u003C/script>\n\u003Cmain>{@render children()}\u003C/main>\n\u003Caside>\n\t{#each data.posts as post}\n\t\t\u003Ca href=\"/blog/{post.slug}\">{post.title}\u003C/a>\n\t{/each}\n\u003C/aside>\n```\n\nAccess parent data in child pages via `page.data` or by importing `page` from `$app/state`.\n\n## URL Data\n\nLoad functions receive:\n- **`url`**: URL instance with `origin`, `hostname`, `pathname`, `searchParams`\n- **`route`**: Route directory name (e.g., `/a/[b]/[...c]`)\n- **`params`**: Parsed route parameters (e.g., `{ b: 'x', c: 'y/z' }`)\n\n## Fetch Requests\n\nUse the provided `fetch` function (not native fetch):\n- Inherits cookies and authorization headers on server\n- Allows relative URLs on server\n- Internal requests bypass HTTP overhead\n- Responses are captured and inlined during SSR\n- Responses are reused during hydration\n\n```js\nexport async function load({ fetch, params }) {\n\tconst res = await fetch(`/api/items/${params.id}`);\n\treturn { item: await res.json() };\n}\n```\n\n## Cookies\n\nServer load functions can access and set cookies:\n\n```js\nexport async function load({ cookies }) {\n\tconst sessionid = cookies.get('sessionid');\n\treturn { user: await db.getUser(sessionid) };\n}\n```\n\nCookies are only passed through `fetch` if the target is the same host or a subdomain.\n\n## Headers\n\nBoth universal and server load functions can call `setHeaders()` to set response headers (server-side only):\n\n```js\nexport async function load({ fetch, setHeaders }) {\n\tconst response = await fetch('https://cms.example.com/products.json');\n\tsetHeaders({\n\t\t'cache-control': response.headers.get('cache-control')\n\t});\n\treturn response.json();\n}\n```\n\nCannot set `set-cookie` headers; use `cookies.set()` instead.\n\n## Parent Data\n\nAccess parent load function data with `await parent()`:\n\n```js\n// +layout.js\nexport function load() {\n\treturn { a: 1 };\n}\n\n// +page.js\nexport async function load({ parent }) {\n\tconst { a } = await parent();\n\treturn { c: a + 1 };\n}\n```\n\nIn server load functions, `parent()` returns data from parent server layouts. In universal load functions, it returns data from parent universal layouts (treating missing layouts as pass-through functions).\n\n## Errors and Redirects\n\nThrow errors with the `error` helper to render the nearest `+error.svelte`:\n\n```js\nimport { error } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\terror(401, 'not logged in');\n\t}\n}\n```\n\nUse `redirect` helper to redirect users:\n\n```js\nimport { redirect } from '@sveltejs/kit';\n\nexport function load({ locals }) {\n\tif (!locals.user) {\n\t\tredirect(307, '/login');\n\t}\n}\n```\n\n## Streaming Promises\n\nServer load functions can return unresolved promises, which stream to the browser as they resolve:\n\n```js\nexport async function load({ params }) {\n\treturn {\n\t\tpost: await loadPost(params.slug),\n\t\tcomments: loadComments(params.slug) // unresolved\n\t};\n}\n```\n\n```svelte\n{#await data.comments}\n\tLoading...\n{:then comments}\n\t{#each comments as comment}\n\t\t\u003Cp>{comment.content}\u003C/p>\n\t{/each}\n{:catch error}\n\t\u003Cp>Error: {error.message}\u003C/p>\n{/await}\n```\n\nAttach a noop `.catch()` to unhandled promises to prevent crashes.\n\n## Dependency Tracking and Rerunning\n\nLoad functions rerun when:\n- Referenced `params` properties change\n- Referenced `url` properties change (pathname, search, searchParams)\n- `await parent()` is called and parent reruns\n- A dependency declared via `fetch(url)` or `depends(url)` is invalidated\n\nManually rerun load functions with `invalidate(url)` or `invalidateAll()`:\n\n```js\nexport async function load({ fetch, depends }) {\n\tdepends('app:random');\n\treturn { number: await fetch('/api/random').json() };\n}\n```\n\n```svelte\n\u003Cscript>\n\timport { invalidate } from '$app/navigation';\n\tfunction refresh() {\n\t\tinvalidate('app:random');\n\t}\n\u003C/script>\n\u003Cbutton onclick={refresh}>Refresh\u003C/button>\n```\n\nExclude values from tracking with `untrack()`:\n\n```js\nexport async function load({ untrack, url }) {\n\tif (untrack(() => url.pathname === '/')) {\n\t\treturn { message: 'Welcome!' };\n\t}\n}\n```\n\n## Authentication\n\nFor auth checks:\n- Use hooks to protect routes before load functions run\n- Use auth guards in `+page.server.js` for route-specific protection\n- Use `getRequestEvent()` from `$app/server` to access request context in shared functions\n\n```js\n// src/lib/server/auth.js\nimport { redirect } from '@sveltejs/kit';\nimport { getRequestEvent } from '$app/server';\n\nexport function requireLogin() {\n\tconst { locals, url } = getRequestEvent();\n\tif (!locals.user) {\n\t\tredirect(307, `/login?redirectTo=${url.pathname}`);\n\t}\n\treturn locals.user;\n}\n```\n\n```js\n// +page.server.js\nimport { requireLogin } from '$lib/server/auth';\n\nexport function load() {\n\tconst user = requireLogin();\n\treturn { message: `hello ${user.name}!` };\n}\n```","## Load Functions\n\nDefine in `+page.js`/`+page.server.js` or `+layout.js`/`+layout.server.js`:\n\n```js\n// Universal (server + browser)\nexport function load({ params }) {\n\treturn { data: 'value' };\n}\n\n// Server-only\nexport async function load({ params }) {\n\treturn { data: await db.query() };\n}\n```\n\n## Universal vs Server\n\n- **Universal**: Run on server (SSR) then browser. Can return non-serializable data.\n- **Server**: Run only on server. Must return serializable data. Use for DB/secrets.\n\n## Key Features\n\n- **Layout data**: Available to child layouts and pages\n- **URL data**: Access `url`, `route`, `params`\n- **Fetch**: Use provided `fetch()` (inherits cookies, allows relative URLs)\n- **Cookies**: Server load can access/set via `cookies.get/set()`\n- **Headers**: Set response headers with `setHeaders()`\n- **Parent data**: Access parent load data with `await parent()`\n- **Errors/Redirects**: Use `error()` and `redirect()` helpers\n- **Streaming**: Return unresolved promises from server load\n- **Rerun**: Triggered by param/url changes or `invalidate()`\n- **Auth**: Use `getRequestEvent()` in shared auth functions","Define load functions in route files to fetch and return data to components, with separate universal and server-only variants offering different capabilities and execution contexts."],"uses":{"params":["name","path"]}}]}
