{"type":"data","nodes":[{"type":"data","data":[null],"uses":{}},{"type":"data","data":[{"libraryName":1,"itemPath":2,"docItem":3},"sveltejs-svelte","Runtime APIs/stores",{"type":4,"path":5,"relevant":6,"token_counts":7,"usage":11,"markdown":15},"page","06-runtime/01-stores.md",true,{"fulltext":8,"digest":9,"short_digest":10},2836,655,218,{"input":12,"output":13,"details":14},3873,989,null,{"fulltext":16,"digest":17,"short_digest":18,"essence":19},"---\ntitle: Stores\n---\n\n\u003C!-- - how to use\n- how to write\n- TODO should the details for the store methods belong to the reference section? -->\n\nA _store_ is an object that allows reactive access to a value via a simple _store contract_. The [`svelte/store` module](../svelte-store) contains minimal store implementations which fulfil this contract.\n\nAny time you have a reference to a store, you can access its value inside a component by prefixing it with the `$` character. This causes Svelte to declare the prefixed variable, subscribe to the store at component initialisation and unsubscribe when appropriate.\n\nAssignments to `$`-prefixed variables require that the variable be a writable store, and will result in a call to the store's `.set` method.\n\nNote that the store must be declared at the top level of the component — not inside an `if` block or a function, for example.\n\nLocal variables (that do not represent store values) must _not_ have a `$` prefix.\n\n```svelte\n\u003Cscript>\n\timport { writable } from 'svelte/store';\n\n\tconst count = writable(0);\n\tconsole.log($count); // logs 0\n\n\tcount.set(1);\n\tconsole.log($count); // logs 1\n\n\t$count = 2;\n\tconsole.log($count); // logs 2\n\u003C/script>\n```\n\n## When to use stores\n\nPrior to Svelte 5, stores were the go-to solution for creating cross-component reactive states or extracting logic. With runes, these use cases have greatly diminished.\n\n- when extracting logic, it's better to take advantage of runes' universal reactivity: You can use runes outside the top level of components and even place them into JavaScript or TypeScript files (using a `.svelte.js` or `.svelte.ts` file ending)\n- when creating shared state, you can create a `$state` object containing the values you need and then manipulate said state\n\n```ts\n/// file: state.svelte.js\nexport const userState = $state({\n\tname: 'name',\n\t/* ... */\n});\n```\n\n```svelte\n\u003C!--- file: App.svelte --->\n\u003Cscript>\n\timport { userState } from './state.svelte.js';\n\u003C/script>\n\n\u003Cp>User name: {userState.name}\u003C/p>\n\u003Cbutton onclick={() => {\n\tuserState.name = 'new name';\n}}>\n\tchange name\n\u003C/button>\n```\n\nStores are still a good solution when you have complex asynchronous data streams or it's important to have more manual control over updating values or listening to changes. If you're familiar with RxJs and want to reuse that knowledge, the `$` also comes in handy for you.\n\n## svelte/store\n\nThe `svelte/store` module contains a minimal store implementation which fulfil the store contract. It provides methods for creating stores that you can update from the outside, stores you can only update from the inside, and for combining and deriving stores.\n\n### `writable`\n\nFunction that creates a store which has values that can be set from 'outside' components. It gets created as an object with additional `set` and `update` methods.\n\n`set` is a method that takes one argument which is the value to be set. The store value gets set to the value of the argument if the store value is not already equal to it.\n\n`update` is a method that takes one argument which is a callback. The callback takes the existing store value as its argument and returns the new value to be set to the store.\n\n```js\n/// file: store.js\nimport { writable } from 'svelte/store';\n\nconst count = writable(0);\n\ncount.subscribe((value) => {\n\tconsole.log(value);\n}); // logs '0'\n\ncount.set(1); // logs '1'\n\ncount.update((n) => n + 1); // logs '2'\n```\n\nIf a function is passed as the second argument, it will be called when the number of subscribers goes from zero to one (but not from one to two, etc). That function will be passed a `set` function which changes the value of the store, and an `update` function which works like the `update` method on the store, taking a callback to calculate the store's new value from its old value. It must return a `stop` function that is called when the subscriber count goes from one to zero.\n\n```js\n/// file: store.js\nimport { writable } from 'svelte/store';\n\nconst count = writable(0, () => {\n\tconsole.log('got a subscriber');\n\treturn () => console.log('no more subscribers');\n});\n\ncount.set(1); // does nothing\n\nconst unsubscribe = count.subscribe((value) => {\n\tconsole.log(value);\n}); // logs 'got a subscriber', then '1'\n\nunsubscribe(); // logs 'no more subscribers'\n```\n\nNote that the value of a `writable` is lost when it is destroyed, for example when the page is refreshed. However, you can write your own logic to sync the value to for example the `localStorage`.\n\n### `readable`\n\nCreates a store whose value cannot be set from 'outside', the first argument is the store's initial value, and the second argument to `readable` is the same as the second argument to `writable`.\n\n```ts\nimport { readable } from 'svelte/store';\n\nconst time = readable(new Date(), (set) => {\n\tset(new Date());\n\n\tconst interval = setInterval(() => {\n\t\tset(new Date());\n\t}, 1000);\n\n\treturn () => clearInterval(interval);\n});\n\nconst ticktock = readable('tick', (set, update) => {\n\tconst interval = setInterval(() => {\n\t\tupdate((sound) => (sound === 'tick' ? 'tock' : 'tick'));\n\t}, 1000);\n\n\treturn () => clearInterval(interval);\n});\n```\n\n### `derived`\n\nDerives a store from one or more other stores. The callback runs initially when the first subscriber subscribes and then whenever the store dependencies change.\n\nIn the simplest version, `derived` takes a single store, and the callback returns a derived value.\n\n```ts\n// @filename: ambient.d.ts\nimport { type Writable } from 'svelte/store';\n\ndeclare global {\n\tconst a: Writable\u003Cnumber>;\n}\n\nexport {};\n\n// @filename: index.ts\n// ---cut---\nimport { derived } from 'svelte/store';\n\nconst doubled = derived(a, ($a) => $a * 2);\n```\n\nThe callback can set a value asynchronously by accepting a second argument, `set`, and an optional third argument, `update`, calling either or both of them when appropriate.\n\nIn this case, you can also pass a third argument to `derived` — the initial value of the derived store before `set` or `update` is first called. If no initial value is specified, the store's initial value will be `undefined`.\n\n```ts\n// @filename: ambient.d.ts\nimport { type Writable } from 'svelte/store';\n\ndeclare global {\n\tconst a: Writable\u003Cnumber>;\n}\n\nexport {};\n\n// @filename: index.ts\n// @errors: 18046 2769 7006\n// ---cut---\nimport { derived } from 'svelte/store';\n\nconst delayed = derived(\n\ta,\n\t($a, set) => {\n\t\tsetTimeout(() => set($a), 1000);\n\t},\n\t2000\n);\n\nconst delayedIncrement = derived(a, ($a, set, update) => {\n\tset($a);\n\tsetTimeout(() => update((x) => x + 1), 1000);\n\t// every time $a produces a value, this produces two\n\t// values, $a immediately and then $a + 1 a second later\n});\n```\n\nIf you return a function from the callback, it will be called when a) the callback runs again, or b) the last subscriber unsubscribes.\n\n```ts\n// @filename: ambient.d.ts\nimport { type Writable } from 'svelte/store';\n\ndeclare global {\n\tconst frequency: Writable\u003Cnumber>;\n}\n\nexport {};\n\n// @filename: index.ts\n// ---cut---\nimport { derived } from 'svelte/store';\n\nconst tick = derived(\n\tfrequency,\n\t($frequency, set) => {\n\t\tconst interval = setInterval(() => {\n\t\t\tset(Date.now());\n\t\t}, 1000 / $frequency);\n\n\t\treturn () => {\n\t\t\tclearInterval(interval);\n\t\t};\n\t},\n\t2000\n);\n```\n\nIn both cases, an array of arguments can be passed as the first argument instead of a single store.\n\n```ts\n// @filename: ambient.d.ts\nimport { type Writable } from 'svelte/store';\n\ndeclare global {\n\tconst a: Writable\u003Cnumber>;\n\tconst b: Writable\u003Cnumber>;\n}\n\nexport {};\n\n// @filename: index.ts\n\n// ---cut---\nimport { derived } from 'svelte/store';\n\nconst summed = derived([a, b], ([$a, $b]) => $a + $b);\n\nconst delayed = derived([a, b], ([$a, $b], set) => {\n\tsetTimeout(() => set($a + $b), 1000);\n});\n```\n\n### `readonly`\n\nThis simple helper function makes a store readonly. You can still subscribe to the changes from the original one using this new readable store.\n\n```js\nimport { readonly, writable } from 'svelte/store';\n\nconst writableStore = writable(1);\nconst readableStore = readonly(writableStore);\n\nreadableStore.subscribe(console.log);\n\nwritableStore.set(2); // console: 2\n// @errors: 2339\nreadableStore.set(2); // ERROR\n```\n\n### `get`\n\nGenerally, you should read the value of a store by subscribing to it and using the value as it changes over time. Occasionally, you may need to retrieve the value of a store to which you're not subscribed. `get` allows you to do so.\n\n> [!NOTE] This works by creating a subscription, reading the value, then unsubscribing. It's therefore not recommended in hot code paths.\n\n```ts\n// @filename: ambient.d.ts\nimport { type Writable } from 'svelte/store';\n\ndeclare global {\n\tconst store: Writable\u003Cstring>;\n}\n\nexport {};\n\n// @filename: index.ts\n// ---cut---\nimport { get } from 'svelte/store';\n\nconst value = get(store);\n```\n\n## Store contract\n\n```ts\n// @noErrors\nstore = { subscribe: (subscription: (value: any) => void) => (() => void), set?: (value: any) => void }\n```\n\nYou can create your own stores without relying on [`svelte/store`](../svelte-store), by implementing the _store contract_:\n\n1. A store must contain a `.subscribe` method, which must accept as its argument a subscription function. This subscription function must be immediately and synchronously called with the store's current value upon calling `.subscribe`. All of a store's active subscription functions must later be synchronously called whenever the store's value changes.\n2. The `.subscribe` method must return an unsubscribe function. Calling an unsubscribe function must stop its subscription, and its corresponding subscription function must not be called again by the store.\n3. A store may _optionally_ contain a `.set` method, which must accept as its argument a new value for the store, and which synchronously calls all of the store's active subscription functions. Such a store is called a _writable store_.\n\nFor interoperability with RxJS Observables, the `.subscribe` method is also allowed to return an object with an `.unsubscribe` method, rather than return the unsubscription function directly. Note however that unless `.subscribe` synchronously calls the subscription (which is not required by the Observable spec), Svelte will see the value of the store as `undefined` until it does.\n","## Stores Overview\n\nA store is an object providing reactive access to a value via a simple contract. Access store values in components using the `$` prefix, which automatically subscribes/unsubscribes.\n\n```svelte\n\u003Cscript>\n\timport { writable } from 'svelte/store';\n\tconst count = writable(0);\n\t$count = 2; // assignment calls .set()\n\u003C/script>\n```\n\n## When to Use Stores\n\nWith Svelte 5 runes, stores are less necessary:\n- For extracting logic: use runes in `.svelte.js`/`.svelte.ts` files instead\n- For shared state: use `$state` objects\n- Stores remain useful for complex async data streams or when you need manual control over updates/subscriptions\n\n## svelte/store API\n\n**writable(initialValue, startFunction?)** - Creates a store with `.set()` and `.update()` methods. The optional start function receives `set`/`update` functions and must return a stop function.\n\n```js\nconst count = writable(0, () => {\n\tconsole.log('got subscriber');\n\treturn () => console.log('no subscribers');\n});\ncount.set(1);\nconst unsubscribe = count.subscribe(v => console.log(v)); // logs 'got subscriber', then '1'\nunsubscribe(); // logs 'no subscribers'\n```\n\n**readable(initialValue, startFunction)** - Store whose value cannot be set externally. Start function works like writable's.\n\n```ts\nconst time = readable(new Date(), (set) => {\n\tconst interval = setInterval(() => set(new Date()), 1000);\n\treturn () => clearInterval(interval);\n});\n```\n\n**derived(store(s), callback, initialValue?)** - Derives a store from one or more stores. Callback runs when first subscriber subscribes and when dependencies change. Can accept `set` and `update` arguments for async operations.\n\n```ts\nconst doubled = derived(a, ($a) => $a * 2);\nconst delayed = derived([a, b], ([$a, $b], set) => {\n\tsetTimeout(() => set($a + $b), 1000);\n});\n```\n\n**readonly(store)** - Makes a store readonly while preserving subscriptions to the original.\n\n**get(store)** - Retrieves store value without subscribing (creates temporary subscription). Not recommended in hot code paths.\n\n## Store Contract\n\nImplement custom stores by providing:\n1. `.subscribe(subscription)` method that immediately calls subscription with current value, returns unsubscribe function\n2. Optional `.set(value)` method for writable stores\n3. For RxJS interoperability, `.subscribe()` can return object with `.unsubscribe()` method instead of function","## Stores\n\nReactive values accessed via `$` prefix in components. Svelte 5 runes reduce store necessity, but stores remain useful for async data streams and manual control.\n\n**API:**\n- `writable(initial, startFn?)` - Mutable store with `.set()` and `.update()`\n- `readable(initial, startFn)` - Immutable store\n- `derived(store(s), callback, initial?)` - Computed store\n- `readonly(store)` - Wraps store as read-only\n- `get(store)` - Get value without subscribing\n\n**Store Contract:** Must have `.subscribe(fn)` returning unsubscribe function, optionally `.set()` for writable stores.\n\n```js\nconst count = writable(0);\ncount.subscribe(v => console.log(v)); // logs 0\ncount.set(1); // logs 1\n```","Reactive state management through stores with a simple contract, with built-in implementations for writable, readable, derived, and readonly stores."],"uses":{"params":["name","path"]}}]}
